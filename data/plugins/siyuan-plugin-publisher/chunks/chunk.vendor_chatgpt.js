import{K as L}from"./chunk.vendor_keyv.js";import{p as G}from"./chunk.vendor_p-timeout.js";import{Q as B}from"./chunk.vendor_quick-lru.js";import{g as D}from"./chunk.vendor_js-tiktoken.js";import{c as K}from"./chunk.vendor_eventsource-parser.js";import{v as O}from"./chunk.vendor_uuid.js";import"./chunk.vendor_asn1-js.js";import"./chunk.vendor_bn-js.js";import"./chunk.vendor_vite-plugin-node-polyfills.js";import"./chunk.vendor_inherits.js";import"./chunk.vendor_minimalistic-assert.js";import"./chunk.vendor_vm-browserify.js";import"./chunk.vendor_crypto-js.js";import"./chunk.vendor_crypto-browserify.js";import"./chunk.vendor_randombytes.js";import"./chunk.vendor_safe-buffer.js";import"./chunk.vendor_create-hash.js";import"./chunk.vendor_md5-js.js";import"./chunk.vendor_hash-base.js";import"./chunk.vendor_readable-stream.js";import"./chunk.vendor_events.js";import"./chunk.vendor_util.js";import"./chunk.vendor_is-arguments.js";import"./chunk.vendor_has-tostringtag.js";import"./chunk.vendor_has-symbols.js";import"./chunk.vendor_call-bind.js";import"./chunk.vendor_get-intrinsic.js";import"./chunk.vendor_es-errors.js";import"./chunk.vendor_has-proto.js";import"./chunk.vendor_function-bind.js";import"./chunk.vendor_hasown.js";import"./chunk.vendor_set-function-length.js";import"./chunk.vendor_define-data-property.js";import"./chunk.vendor_es-define-property.js";import"./chunk.vendor_gopd.js";import"./chunk.vendor_has-property-descriptors.js";import"./chunk.vendor_is-generator-function.js";import"./chunk.vendor_which-typed-array.js";import"./chunk.vendor_for-each.js";import"./chunk.vendor_is-callable.js";import"./chunk.vendor_available-typed-arrays.js";import"./chunk.vendor_possible-typed-array-names.js";import"./chunk.vendor_is-typed-array.js";import"./chunk.vendor_util-deprecate.js";import"./chunk.vendor_string_decoder.js";import"./chunk.vendor_process-nextick-args.js";import"./chunk.vendor_isarray.js";import"./chunk.vendor_core-util-is.js";import"./chunk.vendor_ripemd160.js";import"./chunk.vendor_sha-js.js";import"./chunk.vendor_cipher-base.js";import"./chunk.vendor_stream-browserify.js";import"./chunk.vendor_create-hmac.js";import"./chunk.vendor_browserify-sign.js";import"./chunk.vendor_browserify-rsa.js";import"./chunk.vendor_elliptic.js";import"./chunk.vendor_minimalistic-crypto-utils.js";import"./chunk.vendor_brorand.js";import"./chunk.vendor_hash-js.js";import"./chunk.vendor_hmac-drbg.js";import"./chunk.vendor_parse-asn1.js";import"./chunk.vendor_evp_bytestokey.js";import"./chunk.vendor_browserify-aes.js";import"./chunk.vendor_buffer-xor.js";import"./chunk.vendor_pbkdf2.js";import"./chunk.vendor_browserify-cipher.js";import"./chunk.vendor_browserify-des.js";import"./chunk.vendor_des-js.js";import"./chunk.vendor_diffie-hellman.js";import"./chunk.vendor_miller-rabin.js";import"./chunk.vendor_create-ecdh.js";import"./chunk.vendor_public-encrypt.js";import"./chunk.vendor_randomfill.js";import"./chunk.vendor_json-buffer.js";import"./chunk.vendor_base64-js.js";var N=D("cl100k_base");function J(e){return new Uint32Array(N.encode(e))}var S=class extends Error{},$;$||($={});var U=globalThis.fetch;async function*z(e){const s=e.getReader();try{for(;;){const{done:l,value:d}=await s.read();if(l)return;yield d}}finally{s.releaseLock()}}async function R(e,s,l=U){const{onMessage:d,onError:m,...u}=s,n=await l(e,u);if(!n.ok){let t;try{t=await n.text()}catch{t=n.statusText}const r=`ChatGPT error ${n.status}: ${t}`,o=new S(r,{cause:n});throw o.statusCode=n.status,o.statusText=n.statusText,o}const p=K(t=>{t.type==="event"&&d(t.data)}),f=t=>{var r;let o=null;try{o=JSON.parse(t)}catch{}if(((r=o==null?void 0:o.detail)==null?void 0:r.type)==="invalid_request_error"){const _=`ChatGPT error ${o.detail.message}: ${o.detail.code} (${o.detail.type})`,g=new S(_,{cause:o});g.statusCode=o.detail.code,g.statusText=o.detail.message,m?m(g):console.error(g);return}p.feed(t)};if(n.body.getReader)for await(const t of z(n.body)){const r=new TextDecoder().decode(t);f(r)}else{const t=n.body;if(!t.on||!t.read)throw new S('unsupported "fetch" implementation');t.on("readable",()=>{let r;for(;(r=t.read())!==null;)f(r.toString())})}}var Q="gpt-3.5-turbo",q="User",F="ChatGPT",ft=class{constructor(e){const{apiKey:s,apiOrg:l,apiBaseUrl:d="https://api.openai.com/v1",debug:m=!1,messageStore:u,completionParams:n,systemMessage:p,maxModelTokens:f=4e3,maxResponseTokens:t=1e3,getMessageById:r,upsertMessage:o,fetch:_=U}=e;if(this._apiKey=s,this._apiOrg=l,this._apiBaseUrl=d,this._debug=!!m,this._fetch=_,this._completionParams={model:Q,temperature:.8,top_p:1,presence_penalty:1,...n},this._systemMessage=p,this._systemMessage===void 0){const g=new Date().toISOString().split("T")[0];this._systemMessage=`You are ChatGPT, a large language model trained by OpenAI. Answer as concisely as possible.
Knowledge cutoff: 2021-09-01
Current date: ${g}`}if(this._maxModelTokens=f,this._maxResponseTokens=t,this._getMessageById=r??this._defaultGetMessageById,this._upsertMessage=o??this._defaultUpsertMessage,u?this._messageStore=u:this._messageStore=new L({store:new B({maxSize:1e4})}),!this._apiKey)throw new Error("OpenAI missing required apiKey");if(!this._fetch)throw new Error("Invalid environment; fetch is not defined");if(typeof this._fetch!="function")throw new Error('Invalid "fetch" is not a function')}async sendMessage(e,s={}){const{parentMessageId:l,messageId:d=O(),timeoutMs:m,onProgress:u,stream:n=!!u,completionParams:p,conversationId:f}=s;let{abortSignal:t}=s,r=null;m&&!t&&(r=new AbortController,t=r.signal);const _={role:"user",id:d,conversationId:f,parentMessageId:l,text:e},{messages:g,maxTokens:b,numTokens:w}=await this._buildMessages(e,s),a={role:"assistant",id:O(),conversationId:f,parentMessageId:d,text:""},h=new Promise(async(i,v)=>{var M,I;const k=`${this._apiBaseUrl}/chat/completions`,P={"Content-Type":"application/json",Authorization:`Bearer ${this._apiKey}`},E={max_tokens:b,...this._completionParams,...p,messages:g,stream:n};if(this._apiOrg&&(P["OpenAI-Organization"]=this._apiOrg),this._debug&&console.log(`sendMessage (${w} tokens)`,E),n)R(k,{method:"POST",headers:P,body:JSON.stringify(E),signal:t,onMessage:y=>{var T;if(y==="[DONE]")return a.text=a.text.trim(),i(a);try{const c=JSON.parse(y);if(c.id&&(a.id=c.id),(T=c.choices)!=null&&T.length){const x=c.choices[0].delta;a.delta=x.content,x!=null&&x.content&&(a.text+=x.content),x.role&&(a.role=x.role),a.detail=c,u==null||u(a)}}catch(c){return console.warn("OpenAI stream SEE event unexpected error",c),v(c)}}},this._fetch).catch(v);else try{const y=await this._fetch(k,{method:"POST",headers:P,body:JSON.stringify(E),signal:t});if(!y.ok){const c=await y.text(),x=`OpenAI error ${y.status||y.statusText}: ${c}`,A=new S(x,{cause:y});return A.statusCode=y.status,A.statusText=y.statusText,v(A)}const T=await y.json();if(this._debug&&console.log(T),T!=null&&T.id&&(a.id=T.id),(M=T==null?void 0:T.choices)!=null&&M.length){const c=T.choices[0].message;a.text=c.content,c.role&&(a.role=c.role)}else{const c=T;return v(new Error(`OpenAI error: ${((I=c==null?void 0:c.detail)==null?void 0:I.message)||(c==null?void 0:c.detail)||"unknown"}`))}return a.detail=T,i(a)}catch(y){return v(y)}}).then(async i=>{if(i.detail&&!i.detail.usage)try{const v=w,M=await this._getTokenCount(i.text);i.detail.usage={prompt_tokens:v,completion_tokens:M,total_tokens:v+M,estimated:!0}}catch{}return Promise.all([this._upsertMessage(_),this._upsertMessage(i)]).then(()=>i)});return m?(r&&(h.cancel=()=>{r.abort()}),G(h,{milliseconds:m,message:"OpenAI timed out waiting for response"})):h}get apiKey(){return this._apiKey}set apiKey(e){this._apiKey=e}get apiOrg(){return this._apiOrg}set apiOrg(e){this._apiOrg=e}async _buildMessages(e,s){const{systemMessage:l=this._systemMessage}=s;let{parentMessageId:d}=s;const m=q,u=F,n=this._maxModelTokens-this._maxResponseTokens;let p=[];l&&p.push({role:"system",content:l});const f=p.length;let t=e?p.concat([{role:"user",content:e,name:s.name}]):p,r=0;do{const _=t.reduce((h,i)=>{switch(i.role){case"system":return h.concat([`Instructions:
${i.content}`]);case"user":return h.concat([`${m}:
${i.content}`]);default:return h.concat([`${u}:
${i.content}`])}},[]).join(`

`),g=await this._getTokenCount(_),b=g<=n;if(_&&!b||(p=t,r=g,!b)||!d)break;const w=await this._getMessageById(d);if(!w)break;const a=w.role||"user";t=t.slice(0,f).concat([{role:a,content:w.text,name:w.name},...t.slice(f)]),d=w.parentMessageId}while(!0);const o=Math.max(1,Math.min(this._maxModelTokens-r,this._maxResponseTokens));return{messages:p,maxTokens:o,numTokens:r}}async _getTokenCount(e){return e=e.replace(/<\|endoftext\|>/g,""),J(e).length}async _defaultGetMessageById(e){return await this._messageStore.get(e)}async _defaultUpsertMessage(e){await this._messageStore.set(e.id,e)}},V=/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;function C(e){return e&&V.test(e)}var gt=class{constructor(e){const{accessToken:s,apiReverseProxyUrl:l="https://bypass.duti.tech/api/conversation",model:d="text-davinci-002-render-sha",debug:m=!1,headers:u,fetch:n=U}=e;if(this._accessToken=s,this._apiReverseProxyUrl=l,this._debug=!!m,this._model=d,this._fetch=n,this._headers=u,!this._accessToken)throw new Error("ChatGPT invalid accessToken");if(!this._fetch)throw new Error("Invalid environment; fetch is not defined");if(typeof this._fetch!="function")throw new Error('Invalid "fetch" is not a function')}get accessToken(){return this._accessToken}set accessToken(e){this._accessToken=e}async sendMessage(e,s={}){if(!!s.conversationId!=!!s.parentMessageId)throw new Error("ChatGPTUnofficialProxyAPI.sendMessage: conversationId and parentMessageId must both be set or both be undefined");if(s.conversationId&&!C(s.conversationId))throw new Error("ChatGPTUnofficialProxyAPI.sendMessage: conversationId is not a valid v4 UUID");if(s.parentMessageId&&!C(s.parentMessageId))throw new Error("ChatGPTUnofficialProxyAPI.sendMessage: parentMessageId is not a valid v4 UUID");if(s.messageId&&!C(s.messageId))throw new Error("ChatGPTUnofficialProxyAPI.sendMessage: messageId is not a valid v4 UUID");const{conversationId:l,parentMessageId:d=O(),messageId:m=O(),action:u="next",timeoutMs:n,onProgress:p}=s;let{abortSignal:f}=s,t=null;n&&!f&&(t=new AbortController,f=t.signal);const r={action:u,messages:[{id:m,role:"user",content:{content_type:"text",parts:[e]}}],model:this._model,parent_message_id:d};l&&(r.conversation_id=l);const o={role:"assistant",id:O(),parentMessageId:m,conversationId:l,text:""},_=new Promise((g,b)=>{const w=this._apiReverseProxyUrl,a={...this._headers,Authorization:`Bearer ${this._accessToken}`,Accept:"text/event-stream","Content-Type":"application/json"};this._debug&&console.log("POST",w,{body:r,headers:a}),R(w,{method:"POST",headers:a,body:JSON.stringify(r),signal:f,onMessage:h=>{var i,v,M;if(h==="[DONE]")return g(o);try{const I=JSON.parse(h);I.conversation_id&&(o.conversationId=I.conversation_id),(i=I.message)!=null&&i.id&&(o.id=I.message.id);const k=I.message;if(k){let P=(M=(v=k==null?void 0:k.content)==null?void 0:v.parts)==null?void 0:M[0];P&&(o.text=P,p&&p(o))}}catch(I){this._debug&&console.warn("chatgpt unexpected JSON error",I)}},onError:h=>{b(h)}},this._fetch).catch(h=>{const i=h.toString().toLowerCase();return o.text&&(i==="error: typeerror: terminated"||i==="typeerror: terminated")?g(o):b(h)})});return n?(t&&(_.cancel=()=>{t.abort()}),G(_,{milliseconds:n,message:"ChatGPT timed out waiting for response"})):_}};export{ft as ChatGPTAPI,S as ChatGPTError,gt as ChatGPTUnofficialProxyAPI,$ as openai};
