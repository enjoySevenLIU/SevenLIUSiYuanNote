{"ID":"20241128125933-atvirum","Spec":"1","Type":"NodeDocument","Properties":{"id":"20241128125933-atvirum","title":"US3S5L6——多种光源综合实现","type":"doc","updated":"20241206125021"},"Children":[{"ID":"20241128125933-u8bs7l9","Type":"NodeBlockquote","Properties":{"id":"20241128125933-u8bs7l9","updated":"20241202135148"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20241202114459-l264y6q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241202114459-l264y6q","updated":"20241202135148"},"Children":[{"Type":"NodeText","Data":"知识回顾"}]},{"ID":"20241202114504-hl3nlim","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20241202114504-hl3nlim","updated":"20241202135148"},"Children":[{"ID":"20241202114506-bfj3wpe","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20241202114506-bfj3wpe","updated":"20241202114506"},"Children":[{"ID":"20241202114506-43il2vo","Type":"NodeParagraph","Properties":{"id":"20241202114506-43il2vo","updated":"20241202114513"},"Children":[{"Type":"NodeText","Data":"前向渲染路径中如何处理光源"}]},{"ID":"20241202114551-dse6a1f","Type":"NodeParagraph","Properties":{"id":"20241202114551-dse6a1f","updated":"20241202114601"},"Children":[{"Type":"NodeText","Data":"两个Pass"}]},{"ID":"20241202114601-qi4esy4","Type":"NodeList","ListData":{},"Properties":{"id":"20241202114601-qi4esy4","updated":"20241202114601"},"Children":[{"ID":"20241202114601-1ztlzlr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241202114601-1ztlzlr","updated":"20241202114601"},"Children":[{"ID":"20241202114601-qdb9niz","Type":"NodeParagraph","Properties":{"id":"20241202114601-qdb9niz","updated":"20241202114601"},"Children":[{"Type":"NodeText","Data":"Base Pass（基础渲染通道）\n"}]}]},{"ID":"20241202114602-a4nellq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241202114602-a4nellq","updated":"20241202114602"},"Children":[{"ID":"20241202114602-on82hta","Type":"NodeParagraph","Properties":{"id":"20241202114602-on82hta","updated":"20241202114602"},"Children":[{"Type":"NodeText","Data":"Additional Pass（附加渲染通道）"}]}]}]}]},{"ID":"20241202114514-4n0bxd4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20241202114514-4n0bxd4","updated":"20241202135148"},"Children":[{"ID":"20241202114514-9b7s758","Type":"NodeParagraph","Properties":{"id":"20241202114514-9b7s758","updated":"20241202114527"},"Children":[{"Type":"NodeText","Data":"在 Shader 当中如何判断多种光源"}]},{"ID":"20241202114614-35ik723","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241202114614-35ik723","updated":"20241202135148"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"#ifdef USING_DIRECTIONAL_LIGHT​\n    // 平行光逻辑\n#else\n    #if defined(POINT)\n    // 点光源逻辑\n    #elif defined(SPOT)\n    // 聚光灯逻辑\n    #else\n    // 其他逻辑\n    #endif\n#endif"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20241202114525-pf17b98","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20241202114525-pf17b98","updated":"20241202114525"},"Children":[{"ID":"20241202114525-diz5d7n","Type":"NodeParagraph","Properties":{"id":"20241202114525-diz5d7n","updated":"20241202114535"},"Children":[{"Type":"NodeText","Data":"点光源衰减值计算"}]},{"ID":"20241202114713-02pjjpp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241202114713-02pjjpp","updated":"20241202114756"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"float3 lightCoord = mul(unity_WorldToLight, float4(worldPos, 1)).xyz;\t\t\t\t\t\t// 计算光源坐标\nfixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).xx).UNITY_ATTEN_CHANNEL;\t// 从光照衰减纹理内取出衰减值\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20241202114540-vmd4bau","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20241202114540-vmd4bau","updated":"20241202114841"},"Children":[{"ID":"20241202114540-hnpn6gh","Type":"NodeParagraph","Properties":{"id":"20241202114540-hnpn6gh","updated":"20241202114759"},"Children":[{"Type":"NodeText","Data":"聚光灯衰减值计算"}]},{"ID":"20241202114759-svgsne0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241202114759-svgsne0","updated":"20241202114841"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1));\t\t\t\t// 计算光源坐标\nfixed atten = (lightCoord.z \u003e 0) * \t                                            // 第一步，通过z分量判断目标点是否在聚光灯背面\n    tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w *               // 第二步，将坐标进行变换后从cookie纹理内取出遮罩衰减值\n    tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL; // 第三步，根据坐标从光照衰减纹理内取出距离衰减值\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]}]},{"ID":"20241202114548-efn1o4p","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241202114548-efn1o4p","updated":"20241206125021"},"Children":[{"Type":"NodeText","Data":"前向渲染路径中处理多种光源的综合实现"}]},{"ID":"20241202114933-tpsn1lx","Type":"NodeParagraph","Properties":{"id":"20241202114933-tpsn1lx","updated":"20241202114955"},"Children":[{"Type":"NodeText","Data":"主要步骤："}]},{"ID":"20241202114959-mpopi97","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20241202114959-mpopi97","updated":"20241206125021"},"Children":[{"ID":"20241202115025-cl63v1x","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20241202115025-cl63v1x","updated":"20241202212555"},"Children":[{"ID":"20241202115025-3kyb30k","Type":"NodeParagraph","Properties":{"id":"20241202115025-3kyb30k","updated":"20241202212555"},"Children":[{"Type":"NodeText","Data":"新建一个 Shader 文件，删除其中无用代码"}]}]},{"ID":"20241202115025-nunf7e0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20241202115025-nunf7e0","updated":"20241202134103"},"Children":[{"ID":"20241202115025-16ymfcj","Type":"NodeParagraph","Properties":{"id":"20241202115025-16ymfcj","updated":"20241202134103"},"Children":[{"Type":"NodeText","Data":"复用之前的 "},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240707130106-869nhts","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"Blinn-Phong 光照模型的逐片元光照"}]},{"ID":"20241202115404-mwcutyd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241202115404-mwcutyd","updated":"20241202115414"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"Shader \"TeachShader/Lesson64\"\n{\n    Properties\n    {\n        _MainColor(\"MainColor\", Color) = (1, 1, 1, 1)           //材质的漫反射颜色\n        _SpecularColor(\"SpecularColor\", Color) = (1, 1, 1, 1)   //材质高光反射颜色\n        _SpecularNum(\"SpecularNum\", Range(0, 20)) = 0.5         //光泽度\n    }\n    SubShader\n    {\n        Pass\n        {\n            Tags { \"LightMode\" = \"ForwardBase\" }\n\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n            #include \"Lighting.cginc\"\n\n            struct v2f\n            {\n                float4 svPos : SV_POSITION;     //裁剪空间下的顶点坐标\n                float3 wNormal : NORMAL;        //世界空间下的法线\n                float3 wPos : TEXCOORD0;        //世界空间下的顶点坐标\n            };\n\n            fixed4 _MainColor;      //属性设置的漫反射颜色\n            fixed4 _SpecularColor;  //属性设置的材质高光颜色\n            float _SpecularNum;     //属性设置的光泽度\n\n            //计算兰伯特光照模型 颜色相关函数（逐片元）\n            //参数：\n            //  wNormal: 世界空间下顶点的法线信息\n            fixed3 getFragLambertColor(in float3 wNormal)\n            {\n                float3 lightDir = normalize(_WorldSpaceLightPos0.xyz);  //将光源0的位置标准化，得到方向，用于计算夹角\n                //兰伯特光照模型的实现，这里的颜色计算只取rgb，不考虑透明度的情况\n                fixed3 color = _LightColor0.rgb * _MainColor.rgb * max(0, dot(wNormal, lightDir));\n                return color;\n            }\n\n            //计算Blinn-Phong高光反射光照模型 颜色相关函数（逐片元）\n            //参数：\n            //  wPos: 世界空间下顶点坐标\n            //  wNormal: 世界空间下顶点的法线信息\n            fixed3 getFragSpecularColor(in float3 wPos, in float3 wNormal)\n            {\n                float3 viewDir = normalize(_WorldSpaceCameraPos.xyz - wPos);    //计算观察方向\n                float3 lightDir = normalize(_WorldSpaceLightPos0.xyz);          //标准化光源方向\n                float3 halfA = normalize(viewDir + lightDir);                   //将光源方向和观察方向相加得到其半角向量，并标准化\n                //Blinn-Phong高光反射模型的实现，这里的颜色计算只取rgb，不考虑透明度的情况\n                fixed3 color = _LightColor0.rgb * _SpecularColor.rgb * pow(max(0, dot(wNormal, halfA)), _SpecularNum);\n                return color;\n            }\n\n            v2f vert (appdata_base v)\n            {\n                v2f v2fData;\n                v2fData.svPos = UnityObjectToClipPos(v.vertex);             //顶点转换到裁剪空间\n                v2fData.wNormal = UnityObjectToWorldNormal(v.normal);       //法线转换到世界空间\n                v2fData.wPos = mul(unity_ObjectToWorld, v.vertex).xyz;      //顶点转换到世界空间\n                return v2fData;\n            }\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                //计算Blinn-Phong式光照模型需要的各种颜色\n                fixed3 lambertColor = getFragLambertColor(i.wNormal);                                   //计算漫反射\n                fixed3 specularColor = getFragSpecularColor(i.wPos, i.wNormal);                         //计算高光反射颜色\n                fixed3 blinnPhongColor = UNITY_LIGHTMODEL_AMBIENT.rgb + lambertColor + specularColor;   //计算Blinn-Phong式光照模型颜色\n          \n                return fixed4(blinnPhongColor.rgb, 1);  //因为传递过来的颜色变量不包括透明度，因此这里需要手动指定透明度\n            }\n            ENDCG\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20241202115025-ifnxp0y","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20241202115025-ifnxp0y","updated":"20241206125021"},"Children":[{"ID":"20241202115025-dvdrqs4","Type":"NodeParagraph","Properties":{"id":"20241202115025-dvdrqs4","updated":"20241202115047"},"Children":[{"Type":"NodeText","Data":"其中已存在的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Pass"},{"Type":"NodeText","Data":"​，即 Base Pass（基础渲染通道）\n"}]},{"ID":"20241202115049-0y1sg8v","Type":"NodeParagraph","Properties":{"id":"20241202115049-0y1sg8v","updated":"20241206125021"},"Children":[{"Type":"NodeText","Data":"我们需要为它加上一个编译指令 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"#pragma multi_compile_fwdbase"},{"Type":"NodeText","Data":"​\n该指令可以保证我们在 Shader 中使用光照衰减等光照等变量可以被正确赋值，并且会帮助我们编译 Base Pass 中所有变体"}]},{"ID":"20241202115432-xo5n4ty","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241202115432-xo5n4ty","updated":"20241202124613"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"// Bass Pass 基础渲染通道\nPass\n{\n    Tags { \"LightMode\" = \"ForwardBase\" }\n\n    CGPROGRAM\n    #pragma vertex vert\n    #pragma fragment frag\n    // 帮助我们编译所有光照变体，并确保光照衰减相关的变量能够正确复制到对应的变量中\n    #pragma multi_compile_fwdbase\n\n    #include \"UnityCG.cginc\"\n    #include \"Lighting.cginc\"\n    // ...\n    ENDCG\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20241202115025-o75xsbv","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20241202115025-o75xsbv","updated":"20241202115025"},"Children":[{"ID":"20241202115025-zz32061","Type":"NodeParagraph","Properties":{"id":"20241202115025-zz32061","updated":"20241202115117"},"Children":[{"Type":"NodeText","Data":"复制 Base Pass，基于它来修改我们的 Additional Pass（附加渲染通道）"}]}]},{"ID":"20241202115025-6g1p068","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20241202115025-6g1p068","updated":"20241202115025"},"Children":[{"ID":"20241202115025-8yn9aqp","Type":"NodeParagraph","Properties":{"id":"20241202115025-8yn9aqp","updated":"20241202115125"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"LightMode"},{"Type":"NodeText","Data":"​ 改为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ForwardAdd"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20241202115025-eytng68","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ni4=","Num":6},"Properties":{"id":"20241202115025-eytng68","updated":"20241202115025"},"Children":[{"ID":"20241202115025-9v0tlb4","Type":"NodeParagraph","Properties":{"id":"20241202115025-9v0tlb4","updated":"20241202115130"},"Children":[{"Type":"NodeText","Data":"加入混合命令 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Blend One One"},{"Type":"NodeText","Data":"​ 表示开启混合 线性减淡效果"}]}]},{"ID":"20241202115025-3ixi1cv","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ny4=","Num":7},"Properties":{"id":"20241202115025-3ixi1cv","updated":"20241202115025"},"Children":[{"ID":"20241202115025-suanrpj","Type":"NodeParagraph","Properties":{"id":"20241202115025-suanrpj","updated":"20241202115139"},"Children":[{"Type":"NodeText","Data":"加入编译指令 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"#pragma multi_compile_fwdadd"},{"Type":"NodeText","Data":"​\n"}]},{"ID":"20241202115153-5tbr9hc","Type":"NodeParagraph","Properties":{"id":"20241202115153-5tbr9hc","updated":"20241202115155"},"Children":[{"Type":"NodeText","Data":"该指令保证我们在附加渲染通道中能访问到正确的光照变量，并且会帮助我们编译 Additional Pass 中所有变体"}]},{"ID":"20241202120548-tecajvt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241202120548-tecajvt","updated":"20241202120601"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"// Additional Pass 附加渲染通道\nPass\n{\n    Tags { \"LightMode\" = \"ForwardAdd\" }\n    // 使用线性减淡效果进行光照混合\n    Blend One One\n\n    CGPROGRAM\n    #pragma vertex vert\n    #pragma fragment frag\n    // 帮助我们编译所有光照变体，并确保光照衰减相关的变量能够正确复制到对应的变量中\n    #pragma multi_compile_fwdadd\n\n    #include \"UnityCG.cginc\"\n    #include \"Lighting.cginc\"\n    // ...\n    ENDCG\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20241202115025-a8n6a8f","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"OC4=","Num":8},"Properties":{"id":"20241202115025-a8n6a8f","updated":"20241202134030"},"Children":[{"ID":"20241202115025-d3lcjka","Type":"NodeParagraph","Properties":{"id":"20241202115025-d3lcjka","updated":"20241202115149"},"Children":[{"Type":"NodeText","Data":"修改相关代码，基于不同的光照类型来计算衰减值"}]},{"ID":"20241202115149-lm245cg","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20241202115149-lm245cg","updated":"20241202115149"},"Children":[{"ID":"20241202115149-itmuovd","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20241202115149-itmuovd","updated":"20241202115149"},"Children":[{"ID":"20241202115149-g8ya95a","Type":"NodeParagraph","Properties":{"id":"20241202115149-g8ya95a","updated":"20241202115149"},"Children":[{"Type":"NodeText","Data":"光的方向计算方向修改"}]}]},{"ID":"20241202115149-1ykfv27","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20241202115149-1ykfv27","updated":"20241202115149"},"Children":[{"ID":"20241202115149-kdmvc53","Type":"NodeParagraph","Properties":{"id":"20241202115149-kdmvc53","updated":"20241202115149"},"Children":[{"Type":"NodeText","Data":"基于不同光照类型计算衰减值"}]}]}]},{"ID":"20241202131312-was4ssg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241202131312-was4ssg","updated":"20241202134030"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"fixed4 frag (v2f i) : SV_Target\n{\n    // 漫反射颜色的计算\n    fixed3 worldNormal = normalize(i.wNormal);\n    // 光的方向\n#if defined(_DIRECTIONAL_LIGHT)\n    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);             // 平行光 光的方向就是它的位置\n#else\n    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.wPos);    // 点光源和聚光灯 光的方向 是 光的位置 - 顶点位置\n#endif\n    fixed3 diffuse = _LightColor0.rgb * _MainColor.rgb * max(0, dot(worldNormal, worldLightDir));\n\n    // 高光反射颜色的计算\n    fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.wPos.xyz);  // 视角方向\n    fixed3 halfDir = normalize(worldLightDir + viewDir);                // 半角向量\n    fixed3 specular = _LightColor0.rgb * _SpecularColor.rgb * pow(max(0, dot(worldNormal, halfDir)), _SpecularNum);\n\n    // 衰减值的计算\n#ifdef USING_DIRECTIONAL_LIGHT  //如果光源是平行光，Unity就会定义USING_DIRECTIONAL_LIGHT这个宏，因此会进入这段逻辑\n    // 平行光逻辑\n    fixed atten = 1;\n#else\n    // 如果未定义USING_DIRECTIONAL_LIGHT，则说明此光源非平行光\n#if defined(POINT)\n    // 点光源逻辑\n    float3 lightCoord = mul(unity_WorldToLight, float4(i.wPos, 1)).xyz;\n    fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).xx).UNITY_ATTEN_CHANNEL;\n#elif defined(SPOT)\n    // 聚光灯逻辑\n    float4 lightCoord = mul(unity_WorldToLight, float4(i.wPos, 1));\n    fixed atten = (lightCoord.z \u003e 0) *\n                  tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w *\n                  tex2D(_LightTextureB0, dot(lightCoord, lightCoord).xx).UNITY_ATTEN_CHANNEL;\n#else\n    // 其他逻辑\n    fixed atten = 1;\n#endif\n#endif\n\n    // 附加渲染通道内不需要再加上环境光颜色了，因为它只需要计算一次，而之前已经在基础渲染通道中计算了\n    fixed3 blinnPhongColor = (diffuse + specular) * atten;\n    return fixed4(blinnPhongColor.rgb, 1);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]},{"ID":"20241202132506-l4vv83z","Type":"NodeParagraph","Properties":{"id":"20241202132506-l4vv83z","updated":"20241202132513"},"Children":[{"Type":"NodeText","Data":"完整 Shader 代码如下："}]},{"ID":"20241202132513-hdbp8t8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241202132513-hdbp8t8","updated":"20241202134052"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"Shader \"TeachShader/Lesson64\"\n{\n    Properties\n    {\n        _MainColor(\"MainColor\", Color) = (1, 1, 1, 1)           //材质的漫反射颜色\n        _SpecularColor(\"SpecularColor\", Color) = (1, 1, 1, 1)   //材质高光反射颜色\n        _SpecularNum(\"SpecularNum\", Range(0, 20)) = 0.5         //光泽度\n    }\n    SubShader\n    {\n        // Bass Pass 基础渲染通道\n        Pass\n        {\n            Tags { \"LightMode\" = \"ForwardBase\" }\n\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            // 帮助我们编译所有光照变体，并确保光照衰减相关的变量能够正确复制到对应的变量中\n            #pragma multi_compile_fwdbase\n\n            #include \"UnityCG.cginc\"\n            #include \"Lighting.cginc\"\n\n            struct v2f\n            {\n                float4 svPos : SV_POSITION;     //裁剪空间下的顶点坐标\n                float3 wNormal : NORMAL;        //世界空间下的法线\n                float3 wPos : TEXCOORD0;        //世界空间下的顶点坐标\n            };\n\n            fixed4 _MainColor;      //属性设置的漫反射颜色\n            fixed4 _SpecularColor;  //属性设置的材质高光颜色\n            float _SpecularNum;     //属性设置的光泽度\n\n            //计算兰伯特光照模型 颜色相关函数（逐片元）\n            //参数：\n            //  wNormal: 世界空间下顶点的法线信息\n            fixed3 getFragLambertColor(in float3 wNormal)\n            {\n                float3 lightDir = normalize(_WorldSpaceLightPos0.xyz);  //将光源0的位置标准化，得到方向，用于计算夹角\n                //兰伯特光照模型的实现，这里的颜色计算只取rgb，不考虑透明度的情况\n                fixed3 color = _LightColor0.rgb * _MainColor.rgb * max(0, dot(wNormal, lightDir));\n                return color;\n            }\n\n            //计算Blinn-Phong高光反射光照模型 颜色相关函数（逐片元）\n            //参数：\n            //  wPos: 世界空间下顶点坐标\n            //  wNormal: 世界空间下顶点的法线信息\n            fixed3 getFragSpecularColor(in float3 wPos, in float3 wNormal)\n            {\n                float3 viewDir = normalize(_WorldSpaceCameraPos.xyz - wPos);    //计算观察方向\n                float3 lightDir = normalize(_WorldSpaceLightPos0.xyz);          //标准化光源方向\n                float3 halfA = normalize(viewDir + lightDir);                   //将光源方向和观察方向相加得到其半角向量，并标准化\n                //Blinn-Phong高光反射模型的实现，这里的颜色计算只取rgb，不考虑透明度的情况\n                fixed3 color = _LightColor0.rgb * _SpecularColor.rgb * pow(max(0, dot(wNormal, halfA)), _SpecularNum);\n                return color;\n            }\n\n            v2f vert (appdata_base v)\n            {\n                v2f v2fData;\n                v2fData.svPos = UnityObjectToClipPos(v.vertex);             //顶点转换到裁剪空间\n                v2fData.wNormal = UnityObjectToWorldNormal(v.normal);       //法线转换到世界空间\n                v2fData.wPos = mul(unity_ObjectToWorld, v.vertex).xyz;      //顶点转换到世界空间\n                return v2fData;\n            }\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                //计算Blinn-Phong式光照模型需要的各种颜色\n                fixed3 lambertColor = getFragLambertColor(i.wNormal);           //计算漫反射\n                fixed3 specularColor = getFragSpecularColor(i.wPos, i.wNormal); //计算高光反射颜色\n                fixed atten = 1;                                                //衰减值，由于Bass Pass只处理平行光，因此衰减值默认为1\n                //计算Blinn-Phong式光照模型颜色，衰减值 需要乘以 漫反射颜色 和 高光反射颜色 的和\n                fixed3 blinnPhongColor = UNITY_LIGHTMODEL_AMBIENT.rgb + (lambertColor + specularColor) * atten;\n          \n                return fixed4(blinnPhongColor.rgb, 1);  //因为传递过来的颜色变量不包括透明度，因此这里需要手动指定透明度\n            }\n            ENDCG\n        }\n\n        // Additional Pass 附加渲染通道\n        Pass\n        {\n            Tags { \"LightMode\" = \"ForwardAdd\" }\n            // 使用线性减淡效果进行光照混合\n            Blend One One\n\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            // 帮助我们编译所有光照变体，并确保光照衰减相关的变量能够正确复制到对应的变量中\n            #pragma multi_compile_fwdadd\n\n            #include \"UnityCG.cginc\"\n            #include \"Lighting.cginc\"\n            #include \"AutoLight.cginc\"\n\n            struct v2f\n            {\n                float4 svPos : SV_POSITION;     //裁剪空间下的顶点坐标\n                float3 wNormal : NORMAL;        //世界空间下的法线\n                float3 wPos : TEXCOORD0;        //世界空间下的顶点坐标\n            };\n\n            fixed4 _MainColor;      //属性设置的漫反射颜色\n            fixed4 _SpecularColor;  //属性设置的材质高光颜色\n            float _SpecularNum;     //属性设置的光泽度\n\n            v2f vert (appdata_base v)\n            {\n                v2f v2fData;\n                v2fData.svPos = UnityObjectToClipPos(v.vertex);             //顶点转换到裁剪空间\n                v2fData.wNormal = UnityObjectToWorldNormal(v.normal);       //法线转换到世界空间\n                v2fData.wPos = mul(unity_ObjectToWorld, v.vertex).xyz;      //顶点转换到世界空间\n                return v2fData;\n            }\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                // 漫反射颜色的计算\n                fixed3 worldNormal = normalize(i.wNormal);\n                // 光的方向\n            #if defined(_DIRECTIONAL_LIGHT)\n                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);             // 平行光 光的方向就是它的位置\n            #else\n                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.wPos);    // 点光源和聚光灯 光的方向 是 光的位置 - 顶点位置\n            #endif\n                fixed3 diffuse = _LightColor0.rgb * _MainColor.rgb * max(0, dot(worldNormal, worldLightDir));\n\n                // 高光反射颜色的计算\n                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.wPos.xyz);  // 视角方向\n                fixed3 halfDir = normalize(worldLightDir + viewDir);                // 半角向量\n                fixed3 specular = _LightColor0.rgb * _SpecularColor.rgb * pow(max(0, dot(worldNormal, halfDir)), _SpecularNum);\n\n                // 衰减值的计算\n            #ifdef USING_DIRECTIONAL_LIGHT  //如果光源是平行光，Unity就会定义USING_DIRECTIONAL_LIGHT这个宏，因此会进入这段逻辑\n                // 平行光逻辑\n                fixed atten = 1;\n            #else\n                // 如果未定义USING_DIRECTIONAL_LIGHT，则说明此光源非平行光\n            #if defined(POINT)\n                // 点光源逻辑\n                float3 lightCoord = mul(unity_WorldToLight, float4(i.wPos, 1)).xyz;\n                fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).xx).UNITY_ATTEN_CHANNEL;\n            #elif defined(SPOT)\n                // 聚光灯逻辑\n                float4 lightCoord = mul(unity_WorldToLight, float4(i.wPos, 1));\n                fixed atten = (lightCoord.z \u003e 0) *\n                              tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w *\n                              tex2D(_LightTextureB0, dot(lightCoord, lightCoord).xx).UNITY_ATTEN_CHANNEL;\n            #else\n                // 其他逻辑\n                fixed atten = 1;\n            #endif\n            #endif\n\n                // 附加渲染通道内不需要再加上环境光颜色了，因为它只需要计算一次，而之前已经在基础渲染通道中计算了\n                fixed3 blinnPhongColor = (diffuse + specular) * atten;\n                return fixed4(blinnPhongColor.rgb, 1);\n            }\n            ENDCG\n        }\n    }\n}"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241202132219-n9a8h4q","Type":"NodeParagraph","Properties":{"id":"20241202132219-n9a8h4q","updated":"20241202132249"},"Children":[{"Type":"NodeText","Data":"显示效果（漫反射颜色改为灰色，且光泽度调到20）："}]},{"ID":"20241202133702-lrf4x0m","Type":"NodeParagraph","Properties":{"id":"20241202133702-lrf4x0m","updated":"20241202133702"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20241202133702-dtsmnqz.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241202132229-557qqxb","Type":"NodeParagraph","Properties":{"id":"20241202132229-557qqxb","updated":"20241202132521"},"Children":[{"Type":"NodeText","Data":"可以看到，这样的 Shader 可以受到多种光源的影响，并反射出正确的颜色"}]}]}