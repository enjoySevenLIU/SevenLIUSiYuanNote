{"ID":"20250122115219-lcofa31","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250122115219-lcofa31","title":"US3S11L4——利用深度纹理实现运动模糊效果","type":"doc","updated":"20250123184104"},"Children":[{"ID":"20250122115219-u9ec6mv","Type":"NodeBlockquote","Properties":{"id":"20250122115219-u9ec6mv","updated":"20250122123207"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250122123024-gbk9v7b","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250122123024-gbk9v7b","updated":"20250122123207"},"Children":[{"Type":"NodeText","Data":"知识回顾 运动模糊效果"}]},{"ID":"20250122123034-otgree3","Type":"NodeParagraph","Properties":{"id":"20250122123034-otgree3","updated":"20250122123050"},"Children":[{"Type":"NodeText","Data":"运动模糊效果，是一种 用于模拟真实世界中快速移动物体产生的模糊现象 的图像处理技术。\n一般有两种常用方式："}]},{"ID":"20250122123050-dclndcs","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250122123050-dclndcs","updated":"20250122123139"},"Children":[{"ID":"20250122123050-ndct1p1","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250122123050-ndct1p1","updated":"20250122123050"},"Children":[{"ID":"20250122123050-tgtqgb3","Type":"NodeParagraph","Properties":{"id":"20250122123050-tgtqgb3","updated":"20250122123050"},"Children":[{"Type":"NodeText","Data":"累积缓存：物体快速移动时存储多帧图像信息，取它们之间的加权平均值作为最后的运动模糊图像\n"}]},{"ID":"20250122123131-qx77udx","Type":"NodeList","ListData":{},"Properties":{"id":"20250122123131-qx77udx","updated":"20250122123133"},"Children":[{"ID":"20250122123133-nuhc0x4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250122123133-nuhc0x4","updated":"20250122123133"},"Children":[{"ID":"20250122123133-wnynxqn","Type":"NodeParagraph","Properties":{"id":"20250122123133-wnynxqn","updated":"20250122123135"},"Children":[{"Type":"NodeText","Data":"优点：质量高、效果好"}]}]},{"ID":"20250122123135-mzyjqnc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250122123135-mzyjqnc","updated":"20250122123135"},"Children":[{"ID":"20250122123135-os73gk6","Type":"NodeParagraph","Properties":{"id":"20250122123135-os73gk6","updated":"20250122123135"},"Children":[{"Type":"NodeText","Data":"缺点：计算量大，存储开销大"}]}]}]}]},{"ID":"20250122123050-cbtu1gw","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250122123050-cbtu1gw","updated":"20250122123139"},"Children":[{"ID":"20250122123050-7v6qqn7","Type":"NodeParagraph","Properties":{"id":"20250122123050-7v6qqn7","updated":"20250122123053"},"Children":[{"Type":"NodeText","Data":"速度缓存：物体快速移动时存储多帧运动速度信息，利用速度来决定模糊的方向和大小\n"}]},{"ID":"20250122123138-q9iw1n6","Type":"NodeList","ListData":{},"Properties":{"id":"20250122123138-q9iw1n6","updated":"20250122123139"},"Children":[{"ID":"20250122123139-1lsmtr3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250122123139-1lsmtr3","updated":"20250122123139"},"Children":[{"ID":"20250122123139-udomna0","Type":"NodeParagraph","Properties":{"id":"20250122123139-udomna0","updated":"20250122123141"},"Children":[{"Type":"NodeText","Data":"优点：性能较累积缓存好"}]}]},{"ID":"20250122123141-ecnkxbr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250122123141-ecnkxbr","updated":"20250122123141"},"Children":[{"ID":"20250122123141-1d8r6cy","Type":"NodeParagraph","Properties":{"id":"20250122123141-1d8r6cy","updated":"20250122123141"},"Children":[{"Type":"NodeText","Data":"缺点：效果较差，可能产生重影和伪影"}]}]}]}]}]},{"ID":"20250122123055-ipxwsoi","Type":"NodeParagraph","Properties":{"id":"20250122123055-ipxwsoi","updated":"20250122123122"},"Children":[{"Type":"NodeText","Data":"我们之前学习的方式是基于累积缓存的，但是并没有存储多张场景信息，而是采用一张渲染纹理 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RenderTexture"},{"Type":"NodeText","Data":"​ 保存之前的渲染结果，\n不断把当前渲染图像叠加到之前的渲染图像中，从而产生一种运动轨迹视觉效果"}]},{"ID":"20250122123125-yl6xcxy","Type":"NodeParagraph","Properties":{"id":"20250122123125-yl6xcxy","updated":"20250122123207"},"Children":[{"Type":"NodeText","Data":"详见："},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20250105181135-tiars4j","TextMarkBlockRefSubtype":"d","TextMarkTextContent":"US3S10L9——基于累积缓存的运动模糊"}]}]},{"ID":"20250122123232-8qiduls","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250122123232-8qiduls","updated":"20250122125642"},"Children":[{"Type":"NodeText","Data":"基于速度缓存的运动模糊效果"}]},{"ID":"20250122123246-cl6nouw","Type":"NodeParagraph","Properties":{"id":"20250122123246-cl6nouw","updated":"20250122123334"},"Children":[{"Type":"NodeText","Data":"这节课是利用深度纹理实现运动模糊，它其实就是基于我们之前提到的 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"速度缓存"},{"Type":"NodeText","Data":" 的方式来进行。\n但是和我们之前学习的运动模糊效果一样，我们会基于速度缓存基本规则进行修改，即："}]},{"ID":"20250122123319-l83wqpq","Type":"NodeParagraph","Properties":{"id":"20250122123319-l83wqpq","updated":"20250122123326"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"只需要用当前帧位置和上一帧位置进行计算，得到位置差，从而得到该像素的速度矢量。想要得到位置差，我们可以利用深度纹理中的信息来进行计算。"}]},{"ID":"20250122123335-44ndure","Type":"NodeParagraph","Properties":{"id":"20250122123335-44ndure","updated":"20250122123420"},"Children":[{"Type":"NodeText","Data":"利用 深度纹理实现运动模糊效果 的这种方式有以下两点需要注意："}]},{"ID":"20250122123420-0x5h9l2","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250122123420-0x5h9l2","updated":"20250122123444"},"Children":[{"ID":"20250122123420-4kk1yeg","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250122123420-4kk1yeg","updated":"20250122123438"},"Children":[{"ID":"20250122123420-vk7hvzp","Type":"NodeParagraph","Properties":{"id":"20250122123420-vk7hvzp","updated":"20250122123438"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这种实现方式 只适合 场景静止，即摄像机快速移动的情况"}]},{"ID":"20250122123425-jfaobgb","Type":"NodeParagraph","Properties":{"id":"20250122123425-jfaobgb","updated":"20250122123425"},"Children":[{"Type":"NodeText","Data":"它不太适用于物体快速移动产生的运动模糊效果，只有摄像机移动时才能看到运动模糊效果"}]}]},{"ID":"20250122123421-g9phv6f","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250122123421-g9phv6f","updated":"20250122123444"},"Children":[{"ID":"20250122123421-03l17qz","Type":"NodeParagraph","Properties":{"id":"20250122123421-03l17qz","updated":"20250122123444"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这种实现方式 并不是基于真实的物理运动规律来计算的，只是一种近似计算！"}]},{"ID":"20250122123429-ojym9ta","Type":"NodeParagraph","Properties":{"id":"20250122123429-ojym9ta","updated":"20250122123429"},"Children":[{"Type":"NodeText","Data":"它符合图形学基本规则：看起来对那么就是对的"}]}]}]},{"ID":"20250122123418-0rhbzkw","Type":"NodeParagraph","Properties":{"id":"20250122123418-0rhbzkw","updated":"20250122123509"},"Children":[{"Type":"NodeText","Data":"虽然它使用上有局限性，并且实现上也不符合物理计算规则，但是由于它实现出来的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"效果和性能消耗都还不错"},{"Type":"NodeText","Data":"，因此它也是一种常用的运动模糊处理方案。"}]},{"ID":"20250122123459-55eala2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250122123459-55eala2","updated":"20250122125642"},"Children":[{"Type":"NodeText","Data":"利用深度纹理实现运动模糊基本原理"}]},{"ID":"20250122123538-5rvjod3","Type":"NodeParagraph","Properties":{"id":"20250122123538-5rvjod3","updated":"20250122123547"},"Children":[{"Type":"NodeText","Data":"首先，一句话描述它的基本原理："},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"得到像素当前帧和上一帧中在裁剪空间下的位置，利用两个位置计算出物体的运动方向，从而模拟出运动模糊的效果。"}]},{"ID":"20250122123538-6t0yms3","Type":"NodeParagraph","Properties":{"id":"20250122123538-6t0yms3","updated":"20250122123538"},"Children":[{"Type":"NodeText","Data":"其中的关键点："}]},{"ID":"20250122123538-e0hh3ov","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250122123538-e0hh3ov","updated":"20250122123538"},"Children":[{"ID":"20250122123538-sz0gj37","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250122123538-sz0gj37","updated":"20250122123538"},"Children":[{"ID":"20250122123538-barevnv","Type":"NodeParagraph","Properties":{"id":"20250122123538-barevnv","updated":"20250122123538"},"Children":[{"Type":"NodeText","Data":"如何得到像素当前帧和上一帧在裁剪空间下的位置"}]}]},{"ID":"20250122123538-xjg1ozq","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250122123538-xjg1ozq","updated":"20250122123538"},"Children":[{"ID":"20250122123538-jghbdlo","Type":"NodeParagraph","Properties":{"id":"20250122123538-jghbdlo","updated":"20250122123538"},"Children":[{"Type":"NodeText","Data":"如何得到运动方向"}]}]},{"ID":"20250122123538-zrt1eec","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250122123538-zrt1eec","updated":"20250122123538"},"Children":[{"ID":"20250122123538-wyo8w3p","Type":"NodeParagraph","Properties":{"id":"20250122123538-wyo8w3p","updated":"20250122123538"},"Children":[{"Type":"NodeText","Data":"如何模拟运动模糊效果"}]}]}]},{"ID":"20250122123618-53hkwl1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250122123618-53hkwl1","updated":"20250122125642"},"Children":[{"Type":"NodeText","Data":"如何得到像素当前帧和上一帧在裁剪空间下的位置"}]},{"ID":"20250122123615-qm91nrs","Type":"NodeParagraph","Properties":{"id":"20250122123615-qm91nrs","updated":"20250122123615"},"Children":[{"Type":"NodeText","Data":"关键步骤："}]},{"ID":"20250122123615-e17iite","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250122123615-e17iite","updated":"20250122125642"},"Children":[{"ID":"20250122123615-a6udwbb","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250122123615-a6udwbb","updated":"20250122123615"},"Children":[{"ID":"20250122123615-6sfjo2m","Type":"NodeParagraph","Properties":{"id":"20250122123615-6sfjo2m","updated":"20250122123724"},"Children":[{"Type":"NodeText","Data":"利用 UV 坐标和深度值组合成一个裁剪空间下的组合坐标 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"nowClipPos"},{"Type":"NodeText","Data":"\n"}]},{"ID":"20250122124308-a64e29g","Type":"NodeParagraph","Properties":{"id":"20250122124308-a64e29g","updated":"20250122124308"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Properties":{"style":"width: 292px;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250122124308-bg3c7q9.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"width: 292px;\"}"},{"Type":"NodeText","Data":"​"}]},{"ID":"20250122125058-arsnr0w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250122125058-arsnr0w","updated":"20250122125221"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"float4 nowClipPos = float4(uv.x, uv.y, depth, 1);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250122125050-dad1yah","Type":"NodeParagraph","Properties":{"id":"20250122125050-dad1yah","updated":"20250122125231"},"Children":[{"Type":"NodeText","Data":"我们知道 UV 坐标空间下的值是 0"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"~"}]},{"Type":"NodeText","Data":"1，通过宏取出来的深度值也是0"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"~"}]},{"Type":"NodeText","Data":"1，而裁剪空间下的坐标范围是-1"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"~"}]},{"Type":"NodeText","Data":"1\n因此，我们需要将它利用简单的公式转换到裁剪空间坐标系下："}]},{"ID":"20250122125154-hptrr83","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250122125154-hptrr83","updated":"20250122125222"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"float4 nowClipPos = float4(uv.x * 2 - 1, uv.y * 2 - 1, depth * 2 - 1, 1);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250122125123-t37sg6b","Type":"NodeParagraph","Properties":{"id":"20250122125123-t37sg6b","updated":"20250122125321"},"Children":[{"Type":"NodeText","Data":"可以认为这一步是把带有深度值的 UV 坐标转换到了裁剪空间下（范围从 0"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"~"}]},{"Type":"NodeText","Data":"1 转换到 -1"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"~"}]},{"Type":"NodeText","Data":"1 之间），\n之所以加入深度值是为了让之后的裁剪空间转到世界空间或其他坐标空间更合理，相当于是把 UV 的 2D 坐标系转换到了 3D 坐标系中"}]}]},{"ID":"20250122123615-y5r7ror","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250122123615-y5r7ror","updated":"20250122125642"},"Children":[{"ID":"20250122123615-odeq5d1","Type":"NodeParagraph","Properties":{"id":"20250122123615-odeq5d1","updated":"20250122123741"},"Children":[{"Type":"NodeText","Data":"利用 这一帧 世界空间 —\u003e 裁剪空间 的变换矩阵 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"nowM"},{"Type":"NodeText","Data":" 的逆矩阵 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"nowM^{−1}"},{"Type":"NodeText","Data":"\n"}]},{"ID":"20250122123642-715ncf2","Type":"NodeParagraph","Properties":{"id":"20250122123642-715ncf2","updated":"20250122123749"},"Children":[{"Type":"NodeText","Data":"将刚才裁剪空间下的组合坐标 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"nowClipPos"},{"Type":"NodeText","Data":" 转换到世界空间中"}]},{"ID":"20250122124650-a16x7pf","Type":"NodeParagraph","Properties":{"id":"20250122124650-a16x7pf","updated":"20250122124650"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250122124650-bxmo4mw.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250122125538-ytpvu8x","Type":"NodeParagraph","Properties":{"id":"20250122125538-ytpvu8x","updated":"20250122125642"},"Children":[{"Type":"NodeText","Data":"C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":" 代码中获取空间变换矩阵的方式（"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240513223822-l6ucnnx","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"逆矩阵"},{"Type":"NodeText","Data":"的几何性质之一就是可以用它来进行逆向变换）："}]},{"ID":"20250122125326-pf8j3r8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250122125326-pf8j3r8","updated":"20250122125516"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"camera.projectionMatrix;\t\t// 相机投影矩阵到裁剪空间的变换矩阵\ncamera.worldToCameraMatrix;\t\t// 世界空间到观察空间的变换矩阵\n//世界空间 到 裁剪空间的变换矩阵\nMatrix4x4 worldToClipMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;\n//裁剪空间 到 世界空间的变换矩阵 (是worldToClipMatrix的逆矩阵)\nMatrix4x4 clipToWorldMatrix = worldToclipMatrix.inverse;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250122125607-it1ksi0","Type":"NodeParagraph","Properties":{"id":"20250122125607-it1ksi0","updated":"20250122125607"},"Children":[{"Type":"NodeText","Data":"我们只需要利用上面的这个裁剪空间到世界空间的变换矩阵，就可以将刚才得到的裁剪空间下的组合坐标变换到世界空间下了。"}]}]},{"ID":"20250122123649-3q1bmq6","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250122123649-3q1bmq6","updated":"20250122123649"},"Children":[{"ID":"20250122123649-la0dvm7","Type":"NodeParagraph","Properties":{"id":"20250122123649-la0dvm7","updated":"20250122124819"},"Children":[{"Type":"NodeText","Data":"再利用 上一帧的 世界空间 —\u003e 裁剪空间 的变换矩阵 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"oldM"},{"Type":"NodeText","Data":" 将上一步得到的世界空间的坐标进行转换"}]},{"ID":"20250122123653-zj5tal4","Type":"NodeParagraph","Properties":{"id":"20250122123653-zj5tal4","updated":"20250122124842"},"Children":[{"Type":"NodeText","Data":"即可得到上一帧该世界空间下的组合坐标 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"oldClipPos"},{"Type":"NodeText","Data":" 在裁剪空间下的位置"}]},{"ID":"20250122124942-v6f38jd","Type":"NodeParagraph","Properties":{"id":"20250122124942-v6f38jd","updated":"20250122124942"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250122124942-lfwojgi.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20250122123805-ktq1w1z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250122123805-ktq1w1z","updated":"20250122125812"},"Children":[{"Type":"NodeText","Data":"如何得到运动方向"}]},{"ID":"20250122125751-wrjbac3","Type":"NodeParagraph","Properties":{"id":"20250122125751-wrjbac3","updated":"20250122125759"},"Children":[{"Type":"NodeText","Data":"我们已经知道如何得到像素当前帧和上一帧在裁剪空间下的位置，直接用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"当前位置.xy – 上一帧位置.xy"},{"Type":"NodeText","Data":"​ 便可以得到移动方向"}]},{"ID":"20250122125804-5xbmz0f","Type":"NodeParagraph","Properties":{"id":"20250122125804-5xbmz0f","updated":"20250122125805"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Properties":{"style":"width: 292px;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250122124308-bg3c7q9.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"width: 292px;\"}"},{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Properties":{"style":"width: 294px;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250122124942-lfwojgi.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"width: 294px;\"}"},{"Type":"NodeText","Data":"​"}]},{"ID":"20250122125812-r9downb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250122125812-r9downb","updated":"20250123164502"},"Children":[{"Type":"NodeText","Data":"如何模拟运动模糊效果"}]},{"ID":"20250122125842-5vzvxo2","Type":"NodeParagraph","Properties":{"id":"20250122125842-5vzvxo2","updated":"20250122125910"},"Children":[{"Type":"NodeText","Data":"有了像素在裁剪空间的移动方向，相当于知道了像素在“UV纹理空间的移动方向”，\n那么我们只需要利用这个方向在纹理中进行多次 UV 坐标偏移采样后，将得到的颜色累加起来，最后进行算数平均值计算即可\n我们会加入一个 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"模糊偏移量"},{"Type":"NodeText","Data":" 来控制模糊程度，只需要在每次采样时进行 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"方向 * 模糊偏移量"},{"Type":"NodeText","Data":"​ 的偏移采样即可"}]},{"ID":"20250122125910-sgr47um","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250122125910-sgr47um","updated":"20250122131118"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"float2 uv = i.uv;\t\t\t\t\t\t// uv初始值\nfloat4 c = float4(0,0,0,0);\t\t\t\t// 用于累加的颜色变量\n// for循环内进行3次采样，每次采样结束后进行一次偏移，3次采样的uv坐标对应为：\n// 第一次：uv\n// 第二次：uv + 移动方向 * 模糊偏移量\n// 第三次：uv + 2 * 移动方向 * 模糊偏移量\nfor (int it = 0; it \u003c 3; it++)\n{\n   c += tex2D(_MainTex, uv);\t\t\t// 颜色累加\n   uv += 移动方向 + 模糊偏移量;            // uv偏移\n}\nc /= 3;\t\t\t\t\t\t\t\t\t// 计算颜色平均值\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250122142904-tvbqs7w","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250122142904-tvbqs7w","name":"material.SetMatrix()","updated":"20250123164521"},"Children":[{"Type":"NodeText","Data":"利用深度纹理实现运动模糊具体实现"}]},{"ID":"20250123164521-2ztp27k","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250123164521-2ztp27k","updated":"20250123174851"},"Children":[{"Type":"NodeText","Data":"在C#中为Shader内直接设置Shader变量"}]},{"ID":"20250123164533-4ohbtkv","Type":"NodeParagraph","Properties":{"id":"20250123164533-4ohbtkv","updated":"20250123164622"},"Children":[{"Type":"NodeText","Data":"我们需要通过 C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":" 代码为 Shader 设置矩阵变量，但是 ShaderLab 语法中的属性中并没有矩阵类型的变量，\n因此我们只需要在 CG 语句中声明矩阵属性即可，这样 C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":" 中通过矩阵的属性名同样可以进行设置\n举例："}]},{"ID":"20250123164622-siuvcnt","Type":"NodeList","ListData":{},"Properties":{"id":"20250123164622-siuvcnt","updated":"20250123164640"},"Children":[{"ID":"20250123164622-0nvongc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250123164622-0nvongc","updated":"20250123164640"},"Children":[{"ID":"20250123164622-xqqd3g7","Type":"NodeParagraph","Properties":{"id":"20250123164622-xqqd3g7","updated":"20250123164640"},"Children":[{"Type":"NodeText","Data":"CG 代码中声明 4*4 矩阵 —— "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float4x4 _ClipToWorldMatrix;"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20250123164622-gkbbyxa","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250123164622-gkbbyxa","updated":"20250123164640"},"Children":[{"ID":"20250123164622-mqinj0v","Type":"NodeParagraph","Properties":{"id":"20250123164622-mqinj0v","updated":"20250123164640"},"Children":[{"Type":"NodeText","Data":"C# 代码中声明 4*4 矩阵 —— "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Matrix4x4 frontClipToWorldMatrix;"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20250123164613-40ldg00","Type":"NodeParagraph","Properties":{"id":"20250123164613-40ldg00","updated":"20250123164842"},"Children":[{"Type":"NodeText","Data":"通过材质球指明变量使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"SetMatrix"},{"Type":"NodeText","Data":"​ 进行设置即可："}]},{"ID":"20250123164616-9pmm4bn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123164616-9pmm4bn","updated":"20250123164910"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"public Material material;\nprivate Matrix4x4 frontClipToWorldMatrix;\n\nvoid Start()\n{\n    material.SetMatrix(\"_ClipToWorldMatrix\", frontClipToWorldMatrix);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250123164658-yxzm66u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250123164658-yxzm66u","updated":"20250123174851"},"Children":[{"Type":"NodeText","Data":"实现 利用深度纹理实现运动模糊屏幕后期处理效果 对应 Shader"}]},{"ID":"20250123164927-v9feamn","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250123164927-v9feamn","updated":"20250123164939"},"Children":[{"ID":"20250123164939-ohgf51x","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250123164939-ohgf51x","updated":"20250123164939"},"Children":[{"ID":"20250123164939-9gkxjls","Type":"NodeParagraph","Properties":{"id":"20250123164939-9gkxjls","updated":"20250123172147"},"Children":[{"Type":"NodeText","Data":"新建 Shader 文件，取名 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MotionBlurWithDepthTexture"},{"Type":"NodeText","Data":"​，即深度纹理运动模糊效果"}]}]},{"ID":"20250123164939-2fz0de2","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250123164939-2fz0de2","updated":"20250123164939"},"Children":[{"ID":"20250123164939-tg3ei8e","Type":"NodeParagraph","Properties":{"id":"20250123164939-tg3ei8e","updated":"20250123164939"},"Children":[{"Type":"NodeText","Data":"声明属性，进行属性映射\n"}]},{"ID":"20250123164958-anastcw","Type":"NodeList","ListData":{},"Properties":{"id":"20250123164958-anastcw","updated":"20250123164959"},"Children":[{"ID":"20250123164959-pmsonbc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250123164959-pmsonbc","updated":"20250123164959"},"Children":[{"ID":"20250123164959-qmljlua","Type":"NodeParagraph","Properties":{"id":"20250123164959-qmljlua","updated":"20250123165030"},"Children":[{"Type":"NodeText","Data":"主纹理 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"_MainTex"},{"Type":"NodeText","Data":"​\n"}]}]},{"ID":"20250123165000-kgqgepb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250123165000-kgqgepb","updated":"20250123165000"},"Children":[{"ID":"20250123165000-bftupio","Type":"NodeParagraph","Properties":{"id":"20250123165000-bftupio","updated":"20250123165032"},"Children":[{"Type":"NodeText","Data":"模糊偏移量 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"_BlurSize"},{"Type":"NodeText","Data":"​\n"}]}]},{"ID":"20250123165001-ciz2pt4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250123165001-ciz2pt4","updated":"20250123165001"},"Children":[{"ID":"20250123165001-auljal4","Type":"NodeParagraph","Properties":{"id":"20250123165001-auljal4","updated":"20250123165958"},"Children":[{"Type":"NodeText","Data":"深度纹理 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"_CameraDepthTexture"},{"Type":"NodeText","Data":"​（不需要声明对应 ShaderLab 属性）"}]}]},{"ID":"20250123165001-d0pz9lf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250123165001-d0pz9lf","updated":"20250123165001"},"Children":[{"ID":"20250123165001-qjyxho4","Type":"NodeParagraph","Properties":{"id":"20250123165001-qjyxho4","updated":"20250123170000"},"Children":[{"Type":"NodeText","Data":"当前帧裁剪到世界空间变换矩阵 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float4x4 _ClipToWorldMatrix"},{"Type":"NodeText","Data":"​（不需要声明对应 ShaderLab 属性）"}]}]},{"ID":"20250123165002-8irtgla","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250123165002-8irtgla","updated":"20250123165002"},"Children":[{"ID":"20250123165002-60htchz","Type":"NodeParagraph","Properties":{"id":"20250123165002-60htchz","updated":"20250123170002"},"Children":[{"Type":"NodeText","Data":"上一帧世界到裁剪空间变换矩阵 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float4x4 _FrontWorldToClipMatrix"},{"Type":"NodeText","Data":"​（不需要声明对应 ShaderLab 属性）"}]}]}]},{"ID":"20250123165902-mz4v0hu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123165902-mz4v0hu","updated":"20250123172106"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"Properties\n{\n    _MainTex(\"Texture\", 2D) = \"white\"{}\n    _BlurSize(\"BlurSize\" Float) = 0.5       // 用于控制模糊程度的模糊偏移量\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250123165906-ipnewc5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123165906-ipnewc5","updated":"20250123172103"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"CGPROGRAM\n#pragma vertex vert\n#pragma fragment frag\n\n#include \"UnityCG.cginc\"\n\nsampler2D _MainTex;                 // 屏幕主纹理\nfloat4 _MainTex_ST;\nfixed _BlurSize;                    // 用于控制模糊程度的模糊偏移量\nsampler2D _CameraDepthTexture;      // 深度纹理\nfloat4x4 _ClipToWorldMatrix;        // 裁剪空间到世界空间的变换矩阵\nfloat4x4 _FrontWorldToClipMatrix;   // 上一帧裁剪空间到世界空间的变换矩阵\n//...\nENDCG\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20250123164939-kr23ewh","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250123164939-kr23ewh","updated":"20250123164939"},"Children":[{"ID":"20250123164939-9v5u86d","Type":"NodeParagraph","Properties":{"id":"20250123164939-9v5u86d","updated":"20250123165020"},"Children":[{"Type":"NodeText","Data":"屏幕后处理标配设置"}]},{"ID":"20250123165005-1pj208k","Type":"NodeParagraph","Properties":{"id":"20250123165005-1pj208k","updated":"20250123170008"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ZTest Always"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Cull Off"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ZWrite Off"},{"Type":"NodeText","Data":"​"}]},{"ID":"20250123170046-2li0vsj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123170046-2li0vsj","updated":"20250123172100"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"Pass\n{\n    ZTest Always\n    Cull Off\n    ZWrite Off\n\n    CGPROGRAM\n    /*...*/\n    ENDCG\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20250123164939-bp44vm0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250123164939-bp44vm0","updated":"20250123164939"},"Children":[{"ID":"20250123164939-8ujtges","Type":"NodeParagraph","Properties":{"id":"20250123164939-8ujtges","updated":"20250123164939"},"Children":[{"Type":"NodeText","Data":"结构体\n"}]},{"ID":"20250123165043-oeye4qj","Type":"NodeParagraph","Properties":{"id":"20250123165043-oeye4qj","updated":"20250123165202"},"Children":[{"Type":"NodeText","Data":"顶点和 UV 坐标"}]},{"ID":"20250123170127-gfyvlb4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123170127-gfyvlb4","updated":"20250123172058"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"struct v2f\n{\n    float2 uv : TEXCOORD0;\n    float4 vertex : SV_POSITION;\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20250123164939-vh4pcj8","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20250123164939-vh4pcj8","updated":"20250123164939"},"Children":[{"ID":"20250123164939-ge5kqma","Type":"NodeParagraph","Properties":{"id":"20250123164939-ge5kqma","updated":"20250123164939"},"Children":[{"Type":"NodeText","Data":"顶点着色器\n"}]},{"ID":"20250123165045-adywq6v","Type":"NodeParagraph","Properties":{"id":"20250123165045-adywq6v","updated":"20250123165200"},"Children":[{"Type":"NodeText","Data":"坐标转换，UV 坐标赋值"}]},{"ID":"20250123170202-zl2wem5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123170202-zl2wem5","updated":"20250123172056"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"v2f vert (appdata_base v)\n{\n    v2f o;\n    o.vertex = UnityObjectToClipPos(v.vertex);\n    o.uv = v.texcoord;\n    return o;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20250123164939-xfkpbnu","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ni4=","Num":6},"Properties":{"id":"20250123164939-xfkpbnu","updated":"20250123164939"},"Children":[{"ID":"20250123164939-x1yufrx","Type":"NodeParagraph","Properties":{"id":"20250123164939-x1yufrx","updated":"20250123165054"},"Children":[{"Type":"NodeText","Data":"片元着色器\n"}]},{"ID":"20250123165054-m0jqa2s","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250123165054-m0jqa2s","updated":"20250123165055"},"Children":[{"ID":"20250123165055-wwmqa7g","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250123165055-wwmqa7g","updated":"20250123165055"},"Children":[{"ID":"20250123165055-kzravot","Type":"NodeParagraph","Properties":{"id":"20250123165055-kzravot","updated":"20250123165055"},"Children":[{"Type":"NodeText","Data":"得到裁剪空间下的两个点\n"}]},{"ID":"20250123165056-ghsu84f","Type":"NodeList","ListData":{},"Properties":{"id":"20250123165056-ghsu84f","updated":"20250123165113"},"Children":[{"ID":"20250123165113-1qj3g7o","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250123165113-1qj3g7o","updated":"20250123165113"},"Children":[{"ID":"20250123165113-8w6k1o6","Type":"NodeParagraph","Properties":{"id":"20250123165113-8w6k1o6","updated":"20250123165120"},"Children":[{"Type":"NodeText","Data":"得到点一：深度值获取，构建裁剪空间下组合坐标 uv 和 深度"}]}]},{"ID":"20250123165115-rbqlebz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250123165115-rbqlebz","updated":"20250123165115"},"Children":[{"ID":"20250123165115-2bigrbd","Type":"NodeParagraph","Properties":{"id":"20250123165115-2bigrbd","updated":"20250123165132"},"Children":[{"Type":"NodeText","Data":"得到点二：裁剪空间坐标转世界空间（注意进行齐次除法），利用上一帧变换矩阵将世界空间坐标转裁剪空间（注意进行齐次除法）"}]}]}]}]},{"ID":"20250123165101-smlug4i","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250123165101-smlug4i","updated":"20250123165101"},"Children":[{"ID":"20250123165101-hhazvtg","Type":"NodeParagraph","Properties":{"id":"20250123165101-hhazvtg","updated":"20250123165138"},"Children":[{"Type":"NodeText","Data":"得到运动方向\n"}]},{"ID":"20250123165141-qz78rns","Type":"NodeParagraph","Properties":{"id":"20250123165141-qz78rns","updated":"20250123165148"},"Children":[{"Type":"NodeText","Data":"用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"当前帧点 - 上一帧点"},{"Type":"NodeText","Data":"​ 得到运动方向"}]}]},{"ID":"20250123165104-6sbeb82","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250123165104-6sbeb82","updated":"20250123165104"},"Children":[{"ID":"20250123165104-9dz35e2","Type":"NodeParagraph","Properties":{"id":"20250123165104-9dz35e2","updated":"20250123165104"},"Children":[{"Type":"NodeText","Data":"进行模糊处理\n"}]},{"ID":"20250123165107-7mrhlnk","Type":"NodeParagraph","Properties":{"id":"20250123165107-7mrhlnk","updated":"20250123165151"},"Children":[{"Type":"NodeText","Data":"利用模糊偏移量变量进行 3 次偏移采样颜色后进行平均值计算"}]}]}]},{"ID":"20250123170211-h2x37ch","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123170211-h2x37ch","updated":"20250123172117"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"fixed4 frag (v2f i) : SV_Target\n{\n    float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);  // 采集深度值\n    // 将UV坐标和深度值作为组合坐标，并从0~1范围扩大到-1~1范围\n    float4 nowClipPos = float4(i.uv.x * 2 - 1, i.uv.y * 2 - 1, depth * 2 - 1, 1);\n    float4 worldPos = mul(_ClipToWorldMatrix, nowClipPos);          // 计算世界空间下的点\n    worldPos /= worldPos.w;                                         // 透视除法，保证w分量为1，为标准坐标\n    float4 oldClipPos = mul(_FrontWorldToClipMatrix, worldPos);     // 计算上一帧的裁剪空间下的点\n    oldClipPos /= worldPos.w;                                       // 透视除法，保证w分量为1，为标准坐标\n    float2 moveDir = nowClipPos.xy - oldClipPos.xy;                 // 得到运动方向\n    // 进行两次偏移采样叠加到原颜色上，取平均，以达到模糊效果\n    float2 uv = i.uv;\n    fixed4 color = float4(0, 0, 0, 0);\n    for (int index = 0; index \u003c 3; index++)\n    {\n        color += tex2D(_MainTex, uv);\n        uv += moveDir * _BlurSize;                                  // 每次循环就偏移采样坐标，叠加偏移后的颜色\n    }\n    color /= 3;\n\n    return fixed4(color.rgb, 1);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20250123164939-1ld650p","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ny4=","Num":7},"Properties":{"id":"20250123164939-1ld650p","updated":"20250123164939"},"Children":[{"ID":"20250123164939-n8a64l4","Type":"NodeParagraph","Properties":{"id":"20250123164939-n8a64l4","updated":"20250123172119"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"FallBack Off"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20250123174851-umywhv6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250123174851-umywhv6","updated":"20250123182126"},"Children":[{"Type":"NodeText","Data":"其他注意点"}]},{"ID":"20250123174851-htli3jz","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250123174851-htli3jz","updated":"20250123175509"},"Children":[{"ID":"20250123174900-c0w27zm","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250123174900-c0w27zm","updated":"20250123174900"},"Children":[{"ID":"20250123174900-3w27dmx","Type":"NodeParagraph","Properties":{"id":"20250123174900-3w27dmx","updated":"20250123174902"},"Children":[{"Type":"NodeText","Data":"考虑不同平台可能存在的垂直翻转问题"}]},{"ID":"20250123174902-kvazq8z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123174902-kvazq8z","updated":"20250123174904"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"#if UNITY_UV_STARTS_AT_TOP\nif (_MainTex_TexelSize.y \u003c 0)\n\to.uv_depth.y = 1 - o.uv_depth.y;\n#endif\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250123175423-y05fbbo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123175423-y05fbbo","updated":"20250123175431"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"struct v2f\n{\n    float2 uv : TEXCOORD0;\n    float2 uv_depth : TEXCOORD1;\n    float4 vertex : SV_POSITION;\n};\n\nsampler2D _MainTex;                 // 屏幕主纹理\nfloat4 _MainTex_ST;\nfloat4 _MainTex_TexelSize;          // 屏幕主纹理纹素\n\nv2f vert (appdata_base v)\n{\n    v2f o;\n    o.vertex = UnityObjectToClipPos(v.vertex);\n    o.uv = v.texcoord;\n    o.uv_depth = v.texcoord;\n    // 多平台时需要判断纹理是否翻转\n#if UNITY_UV_STARTS_AT_TOP\n    if (_MainTex_TexelSize.y \u003c 0)\n    \to.uv_depth.y = 1 - o.uv_depth.y;\n#endif\n    return o;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20250123174900-jdfpwiw","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250123174900-jdfpwiw","updated":"20250123175509"},"Children":[{"ID":"20250123174900-er9k5bk","Type":"NodeParagraph","Properties":{"id":"20250123174900-er9k5bk","updated":"20250123174943"},"Children":[{"Type":"NodeText","Data":"让移动方向向量除以 2"}]},{"ID":"20250123174912-rpb1ssf","Type":"NodeParagraph","Properties":{"id":"20250123174912-rpb1ssf","updated":"20250123174912"},"Children":[{"Type":"NodeText","Data":"从而降低运动模糊效果的强度，不要过于强烈"}]},{"ID":"20250123175507-69imbg3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123175507-69imbg3","updated":"20250123175509"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"float2 moveDir = (nowClipPos.xy - oldClipPos.xy) / 2;           // 得到运动方向\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]},{"ID":"20250123172123-9k7ukj4","Type":"NodeParagraph","Properties":{"id":"20250123172123-9k7ukj4","updated":"20250123172132"},"Children":[{"Type":"NodeText","Data":"完整 Shader 代码如下："}]},{"ID":"20250123172132-bi1jah0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123172132-bi1jah0","updated":"20250123182126"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yw=="},{"Type":"NodeCodeBlockCode","Data":"Shader \"PostEffect/MotionBlurWithDepthTexture\"\n{\n    Properties\n    {\n        _MainTex(\"Texture\", 2D) = \"white\"{}\n        _BlurSize(\"BlurSize\", Float) = 0.5      // 用于控制模糊程度的模糊偏移量\n    }\n\n    SubShader\n    {\n        Pass\n        {\n            ZTest Always\n            Cull Off\n            ZWrite Off\n\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float2 uv_depth : TEXCOORD1;\n                float4 vertex : SV_POSITION;\n            };\n\n            sampler2D _MainTex;                 // 屏幕主纹理\n            float4 _MainTex_ST;\n            float4 _MainTex_TexelSize;          // 屏幕主纹理纹素\n            fixed _BlurSize;                    // 用于控制模糊程度的模糊偏移量\n            sampler2D _CameraDepthTexture;      // 深度纹理\n            float4x4 _ClipToWorldMatrix;        // 裁剪空间到世界空间的变换矩阵\n            float4x4 _FrontWorldToClipMatrix;   // 上一帧裁剪空间到世界空间的变换矩阵\n\n            v2f vert (appdata_base v)\n            {\n                v2f o;\n                o.vertex = UnityObjectToClipPos(v.vertex);\n                o.uv = v.texcoord;\n                o.uv_depth = v.texcoord;\n                // 多平台时需要判断纹理是否翻转\n            #if UNITY_UV_STARTS_AT_TOP\n                if (_MainTex_TexelSize.y \u003c 0)\n                \to.uv_depth.y = 1 - o.uv_depth.y;\n            #endif\n                return o;\n            }\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);  // 采集深度值\n                // 将UV坐标和深度值作为组合坐标，并从0~1范围扩大到-1~1范围\n                float4 nowClipPos = float4(i.uv.x * 2 - 1, i.uv.y * 2 - 1, depth * 2 - 1, 1);\n                float4 worldPos = mul(_ClipToWorldMatrix, nowClipPos);          // 计算世界空间下的点\n                worldPos /= worldPos.w;                                         // 透视除法，保证w分量为1，为标准坐标\n                float4 oldClipPos = mul(_FrontWorldToClipMatrix, worldPos);     // 计算上一帧的裁剪空间下的点\n                oldClipPos /= oldClipPos.w;                                     // 透视除法，保证w分量为1，为标准坐标\n                float2 moveDir = (nowClipPos.xy - oldClipPos.xy) / 2;           // 得到运动方向\n                // 进行两次偏移采样叠加到原颜色上，取平均，以达到模糊效果\n                float2 uv = i.uv;\n                fixed4 color = float4(0, 0, 0, 0);\n                for (int index = 0; index \u003c 3; index++)\n                {\n                    color += tex2D(_MainTex, uv);\n                    uv += moveDir * _BlurSize;                                  // 每次循环就偏移采样坐标，叠加偏移后的颜色\n                }\n                color /= 3;\n\n                return fixed4(color.rgb, 1);\n            }\n            ENDCG\n        }\n    }\n\n    Fallback Off\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250123170213-iy9388r","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250123170213-iy9388r","updated":"20250123182144"},"Children":[{"Type":"NodeText","Data":"实现 利用深度纹理实现运动模糊屏幕后期处理效果 对应 C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":" 脚本"}]},{"ID":"20250123172226-mfxs3ji","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20250123172226-mfxs3ji","updated":"20250123172305"},"Children":[{"ID":"20250123172233-vrag0g6","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20250123172233-vrag0g6","updated":"20250123172233"},"Children":[{"ID":"20250123172233-rp9x0h0","Type":"NodeParagraph","Properties":{"id":"20250123172233-rp9x0h0","updated":"20250123172234"},"Children":[{"Type":"NodeText","Data":"创建 C# 代码，命名和Shader一样"}]}]},{"ID":"20250123172233-vx0aua2","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20250123172233-vx0aua2","updated":"20250123172233"},"Children":[{"ID":"20250123172233-9tepgs7","Type":"NodeParagraph","Properties":{"id":"20250123172233-9tepgs7","updated":"20250123172240"},"Children":[{"Type":"NodeText","Data":"继承屏幕后处理基类 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"PostEffect"},{"Type":"NodeText","Data":"​"}]},{"ID":"20250123172251-h05iloe","Type":"NodeParagraph","Properties":{"id":"20250123172251-h05iloe","updated":"20250123172301"},"Children":[{"Type":"NodeText","Data":"具体代码详见："},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20250104163836-9iiumg9","TextMarkBlockRefSubtype":"d","TextMarkTextContent":"US3S10L4——屏幕后处理基类"}]}]},{"ID":"20250123172233-7wyk29o","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20250123172233-7wyk29o","updated":"20250123172233"},"Children":[{"ID":"20250123172233-q2cf4qq","Type":"NodeParagraph","Properties":{"id":"20250123172233-q2cf4qq","updated":"20250123172233"},"Children":[{"Type":"NodeText","Data":"声明模糊偏移量变量和用于记录上一次变换矩阵的变量"}]}]},{"ID":"20250123172233-zn0r7gh","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20250123172233-zn0r7gh","updated":"20250123172305"},"Children":[{"ID":"20250123172233-dbwkqpx","Type":"NodeParagraph","Properties":{"id":"20250123172233-dbwkqpx","updated":"20250123172248"},"Children":[{"Type":"NodeText","Data":"重写 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"OnRenderImage"},{"Type":"NodeText","Data":"​ 函数"}]},{"ID":"20250123172248-lhmz9l7","Type":"NodeParagraph","Properties":{"id":"20250123172248-lhmz9l7","updated":"20250123172248"},"Children":[{"Type":"NodeText","Data":"在其中进行属性设置，变换矩阵计算，屏幕后处理"}]}]},{"ID":"20250123172233-9lw17q0","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20250123172233-9lw17q0","updated":"20250123172233"},"Children":[{"ID":"20250123172233-4vivfxh","Type":"NodeParagraph","Properties":{"id":"20250123172233-4vivfxh","updated":"20250123172233"},"Children":[{"Type":"NodeText","Data":"在生命周期函数中启用深度纹理，初始化上一帧变换矩阵"}]}]}]},{"ID":"20250123172309-ze8eoi4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123172309-ze8eoi4","updated":"20250123182144"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"using UnityEngine;\n\npublic class MotionBlurWithDepthTexture : PostEffect\n{\n    [Range(0f, 1f)]\n    public float blurSize = 0.5f;\n    private Matrix4x4 frontWorldToClipMatrix = Matrix4x4.identity;\n\n    private void Start()\n    {\n        Camera.main.depthTextureMode = DepthTextureMode.Depth;\n    }\n\n    private void OnEnable()\n    {\n        // 初始化上一次的变换矩阵，用观察到裁剪变换矩阵（摄像机的透视矩阵）* 世界到观察变换矩阵 得到世界空间到裁剪空间的变换矩阵\n        frontWorldToClipMatrix = Camera.main.projectionMatrix * Camera.main.worldToCameraMatrix;\n    }\n\n    protected override void OnRenderImage(RenderTexture source, RenderTexture destination)\n    {\n        // 如果材质不存在，说明Shader有问题，将原屏幕纹理复制到目标纹理，相对于无后处理效果\n        if (PostEffectMaterial == null)\n        {\n            Graphics.Blit(source, destination);\n            return;\n        }\n\n        PostEffectMaterial.SetFloat(\"_BlurSize\", blurSize);                                 // 设置模糊程度\n        PostEffectMaterial.SetMatrix(\"_FrontWorldToClipMatrix\", frontWorldToClipMatrix);    // 设置上一帧世界到裁剪空间的矩阵\n        frontWorldToClipMatrix = Camera.main.projectionMatrix * Camera.main.worldToCameraMatrix;\n        PostEffectMaterial.SetMatrix(\"_ClipToWorldMatrix\", frontWorldToClipMatrix.inverse); // 设置本帧裁剪到空间空间的矩阵（通过逆矩阵得到）\n        Graphics.Blit(source, destination, PostEffectMaterial);\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250123173410-p6g5oyg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250123173410-p6g5oyg","updated":"20250123184104"},"Children":[{"Type":"NodeText","Data":"效果展示"}]},{"ID":"20250123181300-3ornqgu","Type":"NodeParagraph","Properties":{"id":"20250123181300-3ornqgu","updated":"20250123181319"},"Children":[{"Type":"NodeText","Data":"摄像机旋转效果："}]},{"ID":"20250123181257-vncfxi6","Type":"NodeParagraph","Properties":{"id":"20250123181257-vncfxi6","updated":"20250123181257"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Properties":{"style":"width: 281px;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20250123181257-g5ppkjx.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"width: 281px;\"}"},{"Type":"NodeText","Data":"​"}]},{"ID":"20250123181312-z5l0cqt","Type":"NodeParagraph","Properties":{"id":"20250123181312-z5l0cqt","updated":"20250123184104"},"Children":[{"Type":"NodeText","Data":"物体移动时不会产生模糊效果，摄像机旋转时会产生模糊效果，\n但是，这种方法实现的动态模糊在摄像机位移时会存在抖动、鬼影的问题（尤其是速度发生变化时），效果不是很好"}]},{"ID":"20250123182937-itjdv3y","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250123182937-itjdv3y","updated":"20250123183721"},"Children":[{"Type":"NodeText","Data":"补充"}]},{"ID":"20250123182942-03jcwwe","Type":"NodeParagraph","Properties":{"id":"20250123182942-03jcwwe","updated":"20250123183721"},"Children":[{"Type":"NodeText","Data":"如果要让越之前的帧看上去效果越淡，呈现轨迹逐渐消失的效果，可以使用加权平均的方法来计算颜色叠加\n注意！权数加起来必须等于1，否则就要进行额外的除法使其让颜色的范围回到 [-1,1]"}]},{"ID":"20250123183552-v1jenc5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123183552-v1jenc5","updated":"20250123183603"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"fixed4 frag (v2f i) : SV_Target\n{\n    float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);    // 采集深度值\n    // 将UV坐标和深度值作为组合坐标，并从0~1范围扩大到-1~1范围\n    float4 nowClipPos = float4(i.uv.x * 2 - 1, i.uv.y * 2 - 1, depth * 2 - 1, 1);\n    float4 worldPos = mul(_ClipToWorldMatrix, nowClipPos);          // 计算世界空间下的点\n    worldPos /= worldPos.w;                                         // 透视除法，保证w分量为1，为标准坐标\n    float4 oldClipPos = mul(_FrontWorldToClipMatrix, worldPos);     // 计算上一帧的裁剪空间下的点\n    oldClipPos /= oldClipPos.w;                                     // 透视除法，保证w分量为1，为标准坐标\n    float2 moveDir = (nowClipPos.xy - oldClipPos.xy) / 2;           // 得到运动方向\n    float velColRate[3] = { 0.6, 0.3, 0.1 };                        // 颜色权数\n    // 进行两次偏移采样叠加到原颜色上，取加权平均，以达到模糊效果\n    float2 uv = i.uv;\n    fixed4 color = float4(0, 0, 0, 0);\n    for (int index = 0; index \u003c 3; index++)\n    {\n        color += tex2D(_MainTex, uv) * velColRate[index];           // 为了让越之前的帧看上去效果越淡，需要让颜色乘以权数\n        uv += moveDir * _BlurSize;                                  // 每次循环就偏移采样坐标，叠加偏移后的颜色\n    }\n\n    return fixed4(color.rgb, 1);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250123183603-psblrif","Type":"NodeParagraph","Properties":{"id":"20250123183603-psblrif","updated":"20250123183610"},"Children":[{"Type":"NodeText","Data":"完整 Shader 如下："}]},{"ID":"20250123183610-gxj6yy2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250123183610-gxj6yy2","updated":"20250123183629"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"Shader \"PostEffect/MotionBlurWithDepthTexture\"\n{\n    Properties\n    {\n        _MainTex(\"Texture\", 2D) = \"white\"{}\n        _BlurSize(\"BlurSize\", Float) = 0.5      // 用于控制模糊程度的模糊偏移量\n    }\n\n    SubShader\n    {\n        Pass\n        {\n            ZTest Always\n            Cull Off\n            ZWrite Off\n\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float2 uv_depth : TEXCOORD1;\n                float4 vertex : SV_POSITION;\n            };\n\n            sampler2D _MainTex;                 // 屏幕主纹理\n            float4 _MainTex_ST;\n            float4 _MainTex_TexelSize;          // 屏幕主纹理纹素\n            fixed _BlurSize;                    // 用于控制模糊程度的模糊偏移量\n            sampler2D _CameraDepthTexture;      // 深度纹理\n            float4x4 _ClipToWorldMatrix;        // 裁剪空间到世界空间的变换矩阵\n            float4x4 _FrontWorldToClipMatrix;   // 上一帧裁剪空间到世界空间的变换矩阵\n\n            v2f vert (appdata_base v)\n            {\n                v2f o;\n                o.vertex = UnityObjectToClipPos(v.vertex);\n                o.uv = v.texcoord;\n                o.uv_depth = v.texcoord;\n                // 多平台时需要判断纹理是否翻转\n            #if UNITY_UV_STARTS_AT_TOP\n                if (_MainTex_TexelSize.y \u003c 0)\n                \to.uv_depth.y = 1 - o.uv_depth.y;\n            #endif\n                return o;\n            }\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);    // 采集深度值\n                // 将UV坐标和深度值作为组合坐标，并从0~1范围扩大到-1~1范围\n                float4 nowClipPos = float4(i.uv.x * 2 - 1, i.uv.y * 2 - 1, depth * 2 - 1, 1);\n                float4 worldPos = mul(_ClipToWorldMatrix, nowClipPos);          // 计算世界空间下的点\n                worldPos /= worldPos.w;                                         // 透视除法，保证w分量为1，为标准坐标\n                float4 oldClipPos = mul(_FrontWorldToClipMatrix, worldPos);     // 计算上一帧的裁剪空间下的点\n                oldClipPos /= oldClipPos.w;                                     // 透视除法，保证w分量为1，为标准坐标\n                float2 moveDir = (nowClipPos.xy - oldClipPos.xy) / 2;           // 得到运动方向\n                float velColRate[3] = { 0.6, 0.3, 0.1 };                        // 颜色权数\n                // 进行两次偏移采样叠加到原颜色上，取加权平均，以达到模糊效果\n                float2 uv = i.uv;\n                fixed4 color = float4(0, 0, 0, 0);\n                for (int index = 0; index \u003c 3; index++)\n                {\n                    color += tex2D(_MainTex, uv) * velColRate[index];           // 为了让越之前的帧看上去效果越淡，需要让颜色乘以权数\n                    uv += moveDir * _BlurSize;                                  // 每次循环就偏移采样坐标，叠加偏移后的颜色\n                }\n\n                return fixed4(color.rgb, 1);\n            }\n            ENDCG\n        }\n    }\n\n    Fallback Off\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}