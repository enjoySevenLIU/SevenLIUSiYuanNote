{"ID":"20240204170710-e5jituj","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240204170710-e5jituj","title":"UH2S2L19——Lua调用协程","updated":"20240319232323"},"Children":[{"ID":"20240204172109-jorowmm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240204172109-jorowmm","updated":"20240204172115"},"Children":[{"Type":"NodeText","Data":"本章代码关键字"}]},{"ID":"20240204172116-h3vykpf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240204172116-h3vykpf","style":"line-height: 22px;","updated":"20240204172559"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"bHVh"},{"Type":"NodeCodeBlockCode","Data":"\"xlua.util\"\t\t\t\t--xlua提供的一个工具表，协程相关的内容就在里面\nutil.cs_generator\t\t--将函数转化为MonoBehaviour可用的协程\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240204170724-4m0sru7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240204170724-4m0sru7","name":"util.cs_generator","updated":"20240204170951"},"Children":[{"Type":"NodeText","Data":"调用协程"}]},{"ID":"20240204172733-pssbkqy","Type":"NodeParagraph","Properties":{"id":"20240204172733-pssbkqy","updated":"20240204172752"},"Children":[{"Type":"NodeText","Data":"Lua中调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​的协程分三个部分"}]},{"ID":"20240204172752-ksbfxgz","Type":"NodeList","ListData":{},"Properties":{"id":"20240204172752-ksbfxgz","updated":"20240204173553"},"Children":[{"ID":"20240204172755-rmi2w8z","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240204172755-rmi2w8z","updated":"20240204172755"},"Children":[{"ID":"20240204172755-3x7tood","Type":"NodeParagraph","Properties":{"id":"20240204172755-3x7tood","updated":"20240204172826"},"Children":[{"Type":"NodeText","Data":"首先需要获取一个继承"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​的类，通过它来调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"StartCoroutine"},{"Type":"NodeText","Data":"​方法来启动协程"}]}]},{"ID":"20240204172827-b8bo6zv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240204172827-b8bo6zv"},"Children":[{"ID":"20240204172827-9ps6q9n","Type":"NodeParagraph","Properties":{"id":"20240204172827-9ps6q9n","updated":"20240204173124"},"Children":[{"Type":"NodeText","Data":"作为协程的函数，使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"coroutine.yield"},{"Type":"NodeText","Data":"​可挂起协程，返回的内容还是"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20230712230604-inguwo8","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"Unity挂起协程需要返回的内容"}]}]},{"ID":"20240204173135-nh0efe3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240204173135-nh0efe3","updated":"20240204173553"},"Children":[{"ID":"20240204173135-j9vhmmo","Type":"NodeParagraph","Properties":{"id":"20240204173135-j9vhmmo","updated":"20240204173553"},"Children":[{"Type":"NodeText","Data":"作为协程的Lua函数不能直接传入到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"StartCoroutine"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"strong text","TextMarkTextContent":"需要加载"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"code strong text","TextMarkTextContent":"\u0026quot;xlua.util\u0026quot;"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"strong text","TextMarkTextContent":"并调用"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"code strong text","TextMarkTextContent":"cs_generator"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"strong text","TextMarkTextContent":"来将协程函数转化为可用的协程"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"}]}]}]},{"ID":"20240204170951-5j4coy2","Type":"NodeParagraph","Properties":{"id":"20240204170951-5j4coy2","updated":"20240319232323"},"Children":[{"Type":"NodeText","Data":"在C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":"中协程启动都是通过继承了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​的类，通过里面的启动函数"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"StartCoroutine"},{"Type":"NodeText","Data":"​来启动协程\n但是，"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"strong text","TextMarkTextContent":"我们不能直接将lua函数传入到开启协程中！！！！"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"}]},{"ID":"20240204172037-fmr8iuy","Type":"NodeParagraph","Properties":{"id":"20240204172037-fmr8iuy","updated":"20240204170951"},"Children":[{"Type":"NodeText","Data":"xlua提供了一个工具表，一定是要通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"require"},{"Type":"NodeText","Data":"​调用之后，才能用\n如果要把lua函数当做协程函数传入，必须先调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"xlua.util"},{"Type":"NodeText","Data":"​中的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"cs_generator(lua函数)"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240204170710-nfv49nm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240204170710-nfv49nm","style":"line-height: 22px;","updated":"20240204173341"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"bHVh"},{"Type":"NodeCodeBlockCode","Data":"-- C#中协程启动都是通过继承了Mono的类 通过里面的启动函数StartCoroutine\nGameObject = CS.UnityEngine.GameObject\nWaitForSeconds = CS.UnityEngine.WaitForSeconds\n-- 在场景中新建一个空物体，然后挂一个脚本上去，脚本继承MonoBehaviour，使用它开启协程\nlocal obj = GameObject(\"Coroutine\")\nlocal mono = obj:AddComponent(typeof(CS.LuaCallCSharp))\n\n-- 协程的声明\nfun = function()\n    local a = 1\n    while true do\n        -- lua中 不能直接使用 C#中的yield return\n        -- 不过我们可以使用lua中的协程返回\n        coroutine.yield(WaitForSeconds(1))\n        print(a)\n        a = a + 1\n    end\nend\n\n-- xlua提供的一个工具表\n-- 一定是要通过require调用之后 才能用\nutil = require(\"xlua.util\")\n-- 必须 先调用 xlua.util中的cs_generator(lua函数)\nlocal c = mono:StartCoroutine(util.cs_generator(fun))\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240204173425-30grq6s","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240204173425-30grq6s","updated":"20240204173432"},"Children":[{"Type":"NodeText","Data":"关闭协程"}]},{"ID":"20240204173432-caosace","Type":"NodeParagraph","Properties":{"id":"20240204173432-caosace","updated":"20240204173458"},"Children":[{"Type":"NodeText","Data":"使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"StopCoroutine"},{"Type":"NodeText","Data":"​即可，需要传入协程变量"}]},{"ID":"20240204173510-heqd58o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240204173510-heqd58o","style":"line-height: 22px;","updated":"20240204173519"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"bHVh"},{"Type":"NodeCodeBlockCode","Data":"util = require(\"xlua.util\")\n\n-- C#中协程启动都是通过继承了Mono的类 通过里面的启动函数StartCoroutine\n\nGameObject = CS.UnityEngine.GameObject\nWaitForSeconds = CS.UnityEngine.WaitForSeconds\n-- 在场景中新建一个空物体，然后挂一个脚本上去，脚本继承MonoBehaviour，使用它开启协程\nlocal obj = GameObject(\"Coroutine\")\nlocal mono = obj:AddComponent(typeof(CS.LuaCallCSharp))\n\nfun = function()\n    local a = 1\n    while true do\n        -- lua中 不能直接使用 C#中的yield return\n        -- 不过我们可以使用lua中的协程返回\n        coroutine.yield(WaitForSeconds(1))\n        print(a)\n        a = a + 1\n        if a \u003e 10 then\n            mono:StopCoroutine(c)\t\t\t\t\t--停止协程\n        end\n    end\nend\n\n-- 必须 先调用 xlua.util中的cs_generator(lua函数)\nc = mono:StartCoroutine(util.cs_generator(fun))\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240204172608-fisrl0a","Type":"NodeParagraph","Properties":{"id":"20240204172608-fisrl0a","updated":"20240204173432"}}]}