{
	"ID": "20240108230251-t0jf9ak",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20240108230251-t0jf9ak",
		"title": "ZMUIL3——层级系统",
		"updated": "20240125220959"
	},
	"Children": [
		{
			"ID": "20240123205947-rry6ow1",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240123205947-rry6ow1",
				"updated": "20240123210004"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "层级系统要做的工作"
				}
			]
		},
		{
			"ID": "20240123210004-73dath7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240123210004-73dath7",
				"updated": "20240124235123"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本质是在UI窗口制作时，将窗口划分为不同等级，不同等级的窗口的Canvas层级所在的范围是不同的，具体如下图"
				}
			]
		},
		{
			"ID": "20240110125623-8x3k11d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240110125623-8x3k11d",
				"updated": "20240110125623"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 532px;",
						"style": "width: 522px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240109191544-cuypdh7.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 522px;\" parent-style=\"width: 532px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240124235246-t3k3tah",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124235246-t3k3tah",
				"updated": "20240124235247"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本框架的设计理念是把每个不同等级的弹窗故意留了100个层级去适配特效。\n即基础界面的特效永远不会穿插到二级弹窗上去，因为框架设计就已经避免掉了。\n当然如果是相同等级的弹窗叠加的情况，该设计仍然有100的层级去适配叠加的情况。"
				}
			]
		},
		{
			"ID": "20240123211720-tpjlymn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240123211720-tpjlymn",
				"updated": "20240125220959"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "根据这个思路制作"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "不同等级的窗口的模板预制体，将其Canvas的层级设置为每个等级对应的最小层级"
				},
				{
					"Type": "NodeText",
					"Data": "，\n这样"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "制作UI面板只需要根据面板的等级来选择不同的模板，再修改Canvas层级即可制作"
				}
			]
		},
		{
			"ID": "20240124235146-n89crp5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124235146-n89crp5",
				"updated": "20240124235146"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 862px;",
						"style": "width: 852px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240124235146-jxb8cl0.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 852px;\" parent-style=\"width: 862px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240124235205-q1ov98o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124235205-q1ov98o",
				"updated": "20240124235824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 862px;",
						"style": "width: 852px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240124235205-heewvgq.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 852px;\" parent-style=\"width: 862px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240110130858-kdgbk49",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240110130858-kdgbk49",
				"updated": "20240124235825"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过测试可以发现，单纯的多个Canvas并不会增加DrawCall，只有当Canvas上出现UI控件时才会增加Drawcall"
				}
			]
		},
		{
			"ID": "20240124235336-4995ksv",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240124235336-4995ksv",
				"updated": "20240124235820"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "补充：采用多Canvas的原因"
				}
			]
		},
		{
			"ID": "20240124235540-qezhaqo",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240124235540-qezhaqo",
				"updated": "20240125000125"
			},
			"Children": [
				{
					"ID": "20240124235540-9txzz0q",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240124235540-9txzz0q",
						"updated": "20240125000041"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "UGUI会自动合并批次，也就是说，一个Canvas下的所有元素会合并到一个Mesh内。这意味着，如果一个Canvas下的元素很多，将会造成一个过大的Mesh，而且元素发生改变时，整个Mesh都要重新绘制，开销很大，很可能造成卡顿。"
						}
					]
				},
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240124235540-lr3ohqo",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240124235540-lr3ohqo",
						"updated": "20240124235540"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "因此，一旦UI界面复杂起来时，应当一个界面自成一个Canvas，如果界面很复杂，可能要划分更多的子Canvas。"
						}
					]
				},
				{
					"ID": "20240124235540-sm8lb0s",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240124235540-sm8lb0s",
						"updated": "20240124235540"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "同时还要注意动态元素和静态元素的分离，因为动态元素会导致Canvas的Mesh的重绘"
						}
					]
				},
				{
					"ID": "20240124235540-0cl3v70",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240124235540-0cl3v70",
						"updated": "20240125000125"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "但同时，Canvas不可过多，Canvas的数量提升会造成Drawcall的上升，过多的Drawcall同样会造成性能开销"
						}
					]
				}
			]
		}
	]
}