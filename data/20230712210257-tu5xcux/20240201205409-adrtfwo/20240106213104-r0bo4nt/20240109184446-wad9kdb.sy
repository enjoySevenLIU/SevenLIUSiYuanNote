{
	"ID": "20240109184446-wad9kdb",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20240109184446-wad9kdb",
		"title": "ZMUIL4——自动化系统",
		"updated": "20240126004411"
	},
	"Children": [
		{
			"ID": "20240123170200-b10a3sy",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240123170200-b10a3sy",
				"updated": "20240123211925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "自动化系统要做的工作"
				}
			]
		},
		{
			"ID": "20240123211927-unja748",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240123211927-unja748",
				"updated": "20240125163707"
			},
			"Children": [
				{
					"ID": "20240125000526-nnzopk7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125000526-nnzopk7",
						"updated": "20240125004441"
					},
					"Children": [
						{
							"ID": "20240125000526-gqlqcv1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125000526-gqlqcv1",
								"updated": "20240125150128"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在拼接完UI面板后，自动化系统可以根据特定的解析规则解析UI面板，得到各个需要管理的UI控件的控件类型和控件名\n根据以上的解析结果自动生成对应的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "组件查找脚本/组件数据脚本"
								},
								{
									"Type": "NodeText",
									"Data": "以及"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "Window逻辑类脚本"
								},
								{
									"Type": "NodeText",
									"Data": "\n自动化系统会"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "自动完成繁杂的关联组件，监听函数声明与添加，重写生命周期函数等工作，让我们可重心放在UI控件交互逻辑的编写上"
								}
							]
						}
					]
				},
				{
					"ID": "20240125000527-a925i68",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125000527-a925i68",
						"updated": "20240125004351"
					},
					"Children": [
						{
							"ID": "20240125000527-70kdqc8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125000527-70kdqc8",
								"updated": "20240125004351"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "组件"
								},
								{
									"Type": "NodeText",
									"Data": "查找脚本/"
								},
								{
									"Type": "NodeText",
									"Data": "组件"
								},
								{
									"Type": "NodeText",
									"Data": "数据脚本负责"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "获取并管理UI控件，供Window逻辑类调用UI控件，初始化方法里将Window逻辑类里监听函数添加到控件中"
								}
							]
						}
					]
				},
				{
					"ID": "20240125003045-0u65g8x",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125003045-0u65g8x",
						"updated": "20240125004821"
					},
					"Children": [
						{
							"ID": "20240125003045-jdfmu5w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125003045-jdfmu5w",
								"updated": "20240125004821"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Window逻辑类是我们编写界面的交互的脚本，我们直接在该脚本内生成的各个函数内编写逻辑即可，对外接口函数在"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "API Function"
								},
								{
									"Type": "NodeText",
									"Data": "​​代码块内编写\n"
								},
								{
									"Type": "NodeText",
									"Data": "自动化系统"
								},
								{
									"Type": "NodeText",
									"Data": "会自动让Window逻辑类继承"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBase"
								},
								{
									"Type": "NodeText",
									"Data": "​​，重写各个"
								},
								{
									"Type": "NodeText",
									"Data": "生命周期函数"
								},
								{
									"Type": "NodeText",
									"Data": "，预留对外的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "API Function"
								},
								{
									"Type": "NodeText",
									"Data": "​​代码块，声明各个UI控件的监听函数\n"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "当UI窗口添加控件时，可以重新生成组件查找脚本/组件数据脚本，再生成Window逻辑脚本，原来在Window逻辑脚本编写的内容不会被覆盖"
								}
							]
						}
					]
				},
				{
					"ID": "20240125001727-6k1ner8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125001727-6k1ner8",
						"updated": "20240125163707"
					},
					"Children": [
						{
							"ID": "20240125001727-sbawc48",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125001727-sbawc48",
								"updated": "20240125150150"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "组件查找脚本和组件数据脚本的作用是一致的，区别在于："
								}
							]
						},
						{
							"ID": "20240125150150-mszw1f7",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20240125150150-mszw1f7",
								"updated": "20240125150150"
							},
							"Children": [
								{
									"ID": "20240125150150-3hjlsln",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20240125150150-3hjlsln",
										"updated": "20240125150150"
									},
									"Children": [
										{
											"ID": "20240125150150-zmrlgdf",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240125150150-zmrlgdf",
												"updated": "20240125150150"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "组件查找脚本会在UI窗口刚加载出来时，根据解析出来的路径使用"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Transform.Find"
												},
												{
													"Type": "NodeText",
													"Data": "​查找并关联组件\n"
												}
											]
										}
									]
								},
								{
									"ID": "20240125150151-fummcjd",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20240125150151-fummcjd"
									},
									"Children": [
										{
											"ID": "20240125150151-1awctn8",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240125150151-1awctn8",
												"updated": "20240125150157"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "组件数据脚本继承"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "MonoBehaviour"
												},
												{
													"Type": "NodeText",
													"Data": "​，在脚本编译完毕后会自动的UI窗口对象挂载自己，并通过解析结果将各个组件绑定到自己身上\n"
												}
											]
										}
									]
								}
							]
						},
						{
							"ID": "20240125150158-2ropnju",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125150158-2ropnju",
								"updated": "20240125163707"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "由于组件查找脚本是在运行时使用"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code strong",
									"TextMarkTextContent": "Transform.Find"
								},
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "关联组件，因此性能不如编译结束后就自动关联UI控件的组件数据脚本"
								}
							]
						}
					]
				},
				{
					"ID": "20240125003654-uvppmys",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125003654-uvppmys",
						"updated": "20240125003813"
					},
					"Children": [
						{
							"ID": "20240125003654-6cksaoe",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125003654-6cksaoe",
								"updated": "20240125003813"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "自动化系统"
								},
								{
									"Type": "NodeText",
									"Data": "有两种解析"
								},
								{
									"Type": "NodeText",
									"Data": "组件"
								},
								{
									"Type": "NodeText",
									"Data": "数据的规则"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "："
								}
							]
						},
						{
							"ID": "20240125003742-qk7ynr6",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20240125003742-qk7ynr6",
								"updated": "20240125003754"
							},
							"Children": [
								{
									"ID": "20240125003742-2cd3jo2",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20240125003742-2cd3jo2",
										"updated": "20240125003742"
									},
									"Children": [
										{
											"ID": "20240125003742-2b4bjfp",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240125003742-2b4bjfp",
												"updated": "20240125003742"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "以"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "[Button]"
												},
												{
													"Type": "NodeText",
													"Data": "​​中括号为规范，中间为"
												},
												{
													"Type": "NodeText",
													"Data": "组件"
												},
												{
													"Type": "NodeText",
													"Data": "类型进行解析。"
												}
											]
										}
									]
								},
								{
									"ID": "20240125003742-t26nax9",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20240125003742-t26nax9",
										"updated": "20240125003742"
									},
									"Children": [
										{
											"ID": "20240125003742-jal6rnp",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240125003742-jal6rnp",
												"updated": "20240125003742"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "以打Tag的方式进行解析，Tag需要表明该物体所属"
												},
												{
													"Type": "NodeText",
													"Data": "组件"
												},
												{
													"Type": "NodeText",
													"Data": "类型。"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240125152223-zoouf7p",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240125152223-zoouf7p",
				"updated": "20240125161240"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一、自动化系统配置文件"
				}
			]
		},
		{
			"ID": "20240125152239-lm0u709",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125152239-lm0u709",
				"updated": "20240125161240"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "自动化系统需要配置文件指定使用哪种脚本，使用哪种解析方式，脚本的生成位置，存放解析数据的字符串的键，以及确认对象需要解析的Tag\n"
				}
			]
		},
		{
			"ID": "20240125152734-f3x54fc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125152734-f3x54fc",
				"style": "line-height: 22px;",
				"updated": "20240125161240"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using UnityEngine;\n\npublic enum GeneratorType\n{\n    Find,   //组件查找\n    Bind,   //组件绑定\n}\n\npublic enum ParseType\n{\n    Name,   //名字解析\n    Tag,    //Tag解析\n}\n\npublic class GeneratorConfig\n{\n    //组件绑定脚本生成后存放路径\n    public static string BindComponentGeneratorPath = Application.dataPath + \"/ZMUIFrameWork/Scripts/BindComponent\";\n    //组件查找脚本生成后存放路径\n    public static string FindComponentGeneratorPath = Application.dataPath + \"/ZMUIFrameWork/Scripts/FindComponent\";\n    //窗口逻辑脚本生成后存放路径\n    public static string WindowGeneratorPath = Application.dataPath + \"/ZMUIFrameWork/Scripts/Window\";\n    //存储解析得到的UI控件数据的键，用于PlayerPrefs\n    public static string OBJDATALIST_KEY = \"objdataList\";\n    //使用组件绑定脚本还是组件查找脚本\n    public static GeneratorType GeneratorType = GeneratorType.Bind;\n    //解析规则是使用对象名还是Tag\n    public static ParseType ParseType = ParseType.Name;\n    //解析规则使用Tag时，当对象使用以下数组中的Tag时就解析它\n    public static string[] TAGArr = { \"Image\", \"RawImage\", \"Text\", \"Button\", \"Toggle\", \"Slider\", \"Dropdown\", \"InputField\", \"Canvas\", \"Panel\", \"ScrollRect\" };\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125000523-ng9o6iy",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240125000523-ng9o6iy",
				"updated": "20240125161244"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "二、组件数据查找脚本的生成"
				}
			]
		},
		{
			"ID": "20240125213248-o8dc2wr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125213248-o8dc2wr",
				"updated": "20240125213354"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件查找脚本负责"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "获取并管理UI控件，供Window逻辑类调用UI控件，初始化方法里将Window逻辑类里监听函数添加到控件中"
				}
			]
		},
		{
			"ID": "20240125213344-hzgd87f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125213344-hzgd87f",
				"updated": "20240125213344"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件查找脚本代码需要生成如下部分："
				}
			]
		},
		{
			"ID": "20240125213344-9zlcee4",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240125213344-9zlcee4",
				"updated": "20240125213344"
			},
			"Children": [
				{
					"ID": "20240125213344-vb2r5of",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125213344-vb2r5of",
						"updated": "20240125213344"
					},
					"Children": [
						{
							"ID": "20240125213344-uxn6dxs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125213344-uxn6dxs",
								"updated": "20240125213344"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "脚本为自动生成的提示，命名空间的引用"
								}
							]
						}
					]
				},
				{
					"ID": "20240125213344-6xk3ubl",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125213344-6xk3ubl",
						"updated": "20240125213344"
					},
					"Children": [
						{
							"ID": "20240125213344-j7cwea6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125213344-j7cwea6",
								"updated": "20240125213344"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "命名空间与数据查找类的声明"
								}
							]
						}
					]
				},
				{
					"ID": "20240125213344-l963ocy",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125213344-l963ocy",
						"updated": "20240125213344"
					},
					"Children": [
						{
							"ID": "20240125213344-qz4g8jz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125213344-qz4g8jz",
								"updated": "20240125213344"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "数据查找类要包括所有的需要管理的UI控件的字段"
								}
							]
						}
					]
				},
				{
					"ID": "20240125213344-q23roh7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125213344-q23roh7",
						"updated": "20240125213344"
					},
					"Children": [
						{
							"ID": "20240125213344-3av1lgs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125213344-3av1lgs",
								"updated": "20240125213344"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "数据查找类要包括初始化方法，其中包括使用"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Transform.Find"
								},
								{
									"Type": "NodeText",
									"Data": "​查找并管理组件的语句，以及将对应的Window逻辑类的监听函数添加到UI控件的语句"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240125213344-yxfyr9u",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125213344-yxfyr9u",
				"style": "line-height: 22px;",
				"updated": "20240125213344"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//自动化脚本生成示例\n\n/*-----------------------------------\n *Title: UI自动化组件查找代码工具\n *Author: 铸梦\n *Date:2024/1/25 14:52:13\n *Description: 变量需要以[Text]括号加组件类型格式进行声明，然后右键窗口物体——一键生成UI组件查找脚本即可\n *注意，以下文件是自动生成的，任何手动修改都会被下次生成覆盖，若手动修改后，尽量避免自动生成\n *-----------------------------------*/\nusing UnityEngine.UI;\nusing UnityEngine;\n\nnamespace ZMUIFrameWork\n{\n    public class TempWindowUIComponent\n    {\n        public Button CloseButton;\n\n        public void InitComponent(WindowBase target)\n        {\n            //组件查找\n            CloseButton = target.transform.Find(\"UIContent/[Button]Close\").GetComponent\u003cButton\u003e();\n  \n  \n            //组件事件绑定\n            TempWindow mWindow = (TempWindow)target;\n            target.AddButtonClickListener(CloseButton, mWindow.OnCloseButtonClick);\n        }\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125153939-p278aej",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125153939-p278aej",
				"updated": "20240125221630"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件数据查找脚本的生成主要在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorFindComponentTool"
				},
				{
					"Type": "NodeText",
					"Data": "​内实现，它继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Editor"
				},
				{
					"Type": "NodeText",
					"Data": "​\n它需要"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "为右键菜单提供“生成组件查找脚本”选项（快捷键Shift+U）"
				},
				{
					"Type": "NodeText",
					"Data": "，因此需要为一个函数添加"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "[MenuItem]"
				},
				{
					"Type": "NodeText",
					"Data": "​特性作为入口函数（"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "#U"
				},
				{
					"Type": "NodeText",
					"Data": "​是指定快捷键）"
				}
			]
		},
		{
			"ID": "20240125234202-i9msfcg",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240125234202-i9msfcg",
				"updated": "20240125234206"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240125234203-xow2bg6",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240125234203-xow2bg6",
						"updated": "20240125234206"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "Editor 类是用于拓展和定制 Unity 内置组件的编辑器功能"
						}
					]
				}
			]
		},
		{
			"ID": "20240125234120-a5mdqeh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125234120-a5mdqeh",
				"updated": "20240125234120"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 270px;",
						"style": "width: 260px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240125234107-i24qsae.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 260px;\" parent-style=\"width: 270px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240125234119-o4qvw5d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125234119-o4qvw5d",
				"updated": "20240125234119"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对窗口对象右键选择该选项后对选中的窗口对象进行解析，生成组件数据查找脚本字符串，创建脚本的主函数执行步骤如下："
				}
			]
		},
		{
			"ID": "20240125154242-pipx52r",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125154242-pipx52r",
				"style": "line-height: 22px;",
				"updated": "20240125222948"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//生成组件查找脚本方法，选中游戏对象后在右键菜单点击“生成组件查找脚本”调用\n[MenuItem(\"GameObject/生成组件查找脚本(Shift+U) #U\", false, 0)]\nprivate static void CreateFindComponentScripts()\n{\n    1.获取在编辑器里选中的内容，判断是否为游戏对象，不是则报错并直接返回空\n\t2.设置脚本的生成路径\n\t3.调用PresWindowNodeData或PerseWindowNodeData，将获取到的窗口传入，解析数据\n\t4.将解析到的数据使用PlayerPrefs持久化，后续生成Window数据类脚本还会用到\n\t5.通过解析的内容生成对应脚本字符串\n\t6.将脚本字符串与生成脚本路径传入预览窗口显示\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125153541-4b0sz76",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125153541-4b0sz76",
				"style": "line-height: 22px;",
				"updated": "20240125161244"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class EditorObjectData\n{\n    public int instanceID;\n    public string fieldName;\n    public string fieldType;\n}\n\npublic class GeneratorFindComponentTool : Editor\n{\n    public static Dictionary\u003cint, string\u003e objFindPathDic;   //Key是物体的instanceId，value是物体的查找路径（可通过Transform.Find来寻找对象）\n    public static List\u003cEditorObjectData\u003e objDataList;       //查找对象的数据\n\n    [MenuItem(\"GameObject/生成组件查找脚本(Shift+U) #U\", false, 0)]\n    private static void CreateFindComponentScripts()\n    {\n        //获取在编辑器里选中的内容\n        GameObject obj = Selection.objects.First() as GameObject;\n        if (obj == null)\n        {\n            Debug.LogError(\"需要选择GameObject\");\n            return;\n        }\n        objDataList = new List\u003cEditorObjectData\u003e();\n        objFindPathDic = new Dictionary\u003cint, string\u003e();\n\n        //设置脚本的生成路径\n        if (!Directory.Exists(GeneratorConfig.FindComponentGeneratorPath))\n        {\n            Directory.CreateDirectory(GeneratorConfig.FindComponentGeneratorPath);\n        }\n        //解析窗口所有UI组件数据\n        if (GeneratorConfig.ParseType == ParseType.Tag)\n            ParseWindowDataByTag(obj.transform, obj.name);\n        else\n            PresWindowNodeData(obj.transform, obj.name);\n        //储存字段名称\n        string dataListJson = JsonConvert.SerializeObject(objDataList);\n        PlayerPrefs.SetString(GeneratorConfig.OBJDATALIST_KEY, dataListJson);\n        //生成C#脚本文件\n        string csScriptText = CreateCS(obj.name);\n        string csPath = GeneratorConfig.FindComponentGeneratorPath + \"/\" + obj.name + \"UIComponent.cs\";\n\t\t//显示预览窗口\n        UIWindowEditor.ShowWindow(csScriptText, csPath);\n    }\n\n    // 解析窗口节点数据\n    public static void PresWindowNodeData(Transform transform, string WindowName)...\n\n    // 通过Tag解析窗口节点数据\n    public static void ParseWindowDataByTag(Transform transform, string WindowName)...\n\n    // 生成C#脚本字符串\n    public static string CreateCS(string name)...\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125154613-nchrrmx",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125154613-nchrrmx",
				"updated": "20240125213742"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.解析窗口节点数据"
				}
			]
		},
		{
			"ID": "20240125150740-q9zofjw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125150740-q9zofjw",
				"updated": "20240125213742"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "脚本文本的生成需要对窗口对象解析如下数据："
				}
			]
		},
		{
			"ID": "20240125150908-am74xy2",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240125150908-am74xy2",
				"updated": "20240125213742"
			},
			"Children": [
				{
					"ID": "20240125150909-k2uv1v3",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125150909-k2uv1v3",
						"updated": "20240125150909"
					},
					"Children": [
						{
							"ID": "20240125150909-v48fzwc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125150909-v48fzwc",
								"updated": "20240125150914"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "UI控件的类型"
								}
							]
						}
					]
				},
				{
					"ID": "20240125150914-zngysii",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125150914-zngysii"
					},
					"Children": [
						{
							"ID": "20240125150914-420mh28",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125150914-420mh28",
								"updated": "20240125150918"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "UI控件的名字"
								}
							]
						}
					]
				},
				{
					"ID": "20240125150919-1ssrcn1",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125150919-1ssrcn1"
					},
					"Children": [
						{
							"ID": "20240125150919-u5nac8g",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125150919-u5nac8g",
								"updated": "20240125150942"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "UI控件对象相对于窗口对象的查找路径"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240125160236-2m1m6wf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125160236-2m1m6wf",
				"updated": "20240125213742"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解析方法的思路如下（以解析对象名为例）"
				}
			]
		},
		{
			"ID": "20240125160259-x65uqhx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125160259-x65uqhx",
				"style": "line-height: 22px;",
				"updated": "20240125213742"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//解析窗口节点数据，数据存入到字典与列表，参数一是窗口的Transform，参数二是窗口名（用于确认第一次调用该函数的窗口对象）\npublic static void PresWindowNodeData(Transform transform, string WindowName)\n{\n\t//1.遍历该游戏对象所拥有的子游戏对象，如果有子对象，执行下面的流程，没有就会跳过\n\t//2.如果子游戏对象名字为“[类型名]字段名”，进入解析流程\n\t//3.从游戏对象名中截取类型名和字段名，再获取这个游戏对象的InstanceID，再存入到对应的EditorObjectData对象内，\n\t//4.将EditorObjectData对象存入到objDataList内\n\t//5.向上遍历游戏对象的父节点，直到遍历到最初的传入的窗口对象，获取它们的名字，拼接为查找路径，用于Transform.Find查找对象\n\t//6.以游戏对象的InstanceID为键，查找路径为值，存入到objFindPathDic\n\t//7.将遍历的这个游戏对象再次传入到PresWindowNodeData()，进行递归解析，将所有的子对象都执行上述流程（参数二与最初传入的一致）\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125150832-lqqlz6e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125150832-lqqlz6e",
				"updated": "20240125213742"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们可以通过两种规则让UI控件可以被解析出类型与名字："
				}
			]
		},
		{
			"ID": "20240125151044-24m2yy9",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240125151044-24m2yy9",
				"updated": "20240125213742"
			},
			"Children": [
				{
					"ID": "20240125151045-pihklso",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125151045-pihklso",
						"updated": "20240125151045"
					},
					"Children": [
						{
							"ID": "20240125151045-n24mx42",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125151045-n24mx42",
								"updated": "20240125151342"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将UI控件对象名命名为"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "[控件类型]控件名"
								},
								{
									"Type": "NodeText",
									"Data": "​，如："
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "[Button]Close"
								},
								{
									"Type": "NodeText",
									"Data": "​，解析时针对对象名进行解析，得到类型与名字信息"
								}
							]
						},
						{
							"ID": "20240125151849-yhjw2ed",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240125151849-yhjw2ed",
								"style": "line-height: 22px;",
								"updated": "20240125152029"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "GameObject obj = transform.GetChild(i).gameObject;\t\t\t\t\t//获取窗口下的对象\nstring name = obj.name;\n//如果对象名包括\"[类型名]\"，说明该对象需要作为UI组件进行解析\nif (name.Contains(\"[\") \u0026\u0026 name.Contains(\"]\"))\n{\n    int index = name.IndexOf(\"]\") + 1;                              //得到\"]\"后第一个字符的索引\n    string fieldName = name.Substring(index, name.Length - index);  //获取字段名字\n    string fieldType = name.Substring(1, index - 2);                //获取字段类型\n\t//后略...\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				},
				{
					"ID": "20240125151343-se26xl7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125151343-se26xl7",
						"updated": "20240125152653"
					},
					"Children": [
						{
							"ID": "20240125151343-ww02pv2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125151343-ww02pv2",
								"updated": "20240125151821"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将各种UI控件的类型作为Tag，让UI控件对象使用这些Tag，解析窗口时发现使用控件类型Tag的对象就获取Tag名作为"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "类型"
								},
								{
									"Type": "NodeText",
									"Data": "，对象名来作为"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "名字"
								}
							]
						},
						{
							"ID": "20240125152036-auw5h3h",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240125152036-auw5h3h",
								"style": "line-height: 22px;",
								"updated": "20240125152130"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "GameObject obj = transform.GetChild(i).gameObject;\t\t//获取窗口下的对象\nstring tagName = obj.tag;\n//如果Tag是特定的UI控件Tag，说明该对象需要作为UI组件进行解析\nif (GeneratorConfig.TAGArr.Contains(tagName))\n{\n    string fieldName = obj.name;    //获取字段名字\n    string fieldType = tagName;     //获取字段类型\n\t//后略...\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240125152144-knx8n3k",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125152144-knx8n3k",
								"updated": "20240125152653"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "其中"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "GeneratorConfig.TAGArr"
								},
								{
									"Type": "NodeText",
									"Data": "​是配置文件中设定好的需要解析的对象的Tag"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240125151310-lnyhxtl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125151310-lnyhxtl",
				"updated": "20240125222253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件查找脚本还需要获取UI控件对象相对于窗口对象的查找路径，\n因此需要对传入的对象向上遍历，获取游戏对象的父节点名字，直到遍历到最初的传入的窗口对象，将遍历到的对象名拼接起来，得到查找路径"
				}
			]
		},
		{
			"ID": "20240125155621-c23p2w2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125155621-c23p2w2",
				"updated": "20240125161244"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最终得到的解析方法为："
				}
			]
		},
		{
			"ID": "20240125155632-kxuu7lw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125155632-kxuu7lw",
				"style": "line-height: 22px;",
				"updated": "20240125213742"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public static Dictionary\u003cint, string\u003e objFindPathDic;   //Key是物体的instanceId，value是物体的查找路径（可通过Transform.Find来寻找对象）\npublic static List\u003cEditorObjectData\u003e objDataList;       //查找对象的数据\n\n/// \u003csummary\u003e\n/// 解析窗口节点数据\n/// \u003c/summary\u003e\n/// \u003cparam name=\"transform\"\u003e要解析的窗口的Transform\u003c/param\u003e\n/// \u003cparam name=\"WindowName\"\u003e窗口名\u003c/param\u003e\npublic static void PresWindowNodeData(Transform transform, string WindowName)\n{\n\t//当传入的对象下已无子对象，这个函数流程都会跳过\n    for (int i = 0; i \u003c transform.childCount; i++)\n    {\n    \tGameObject obj = transform.GetChild(i).gameObject;\n        string name = obj.name;\n        //如果对象名包括\"[类型名]\"，说明该对象需要作为UI组件进行解析\n        if (name.Contains(\"[\") \u0026\u0026 name.Contains(\"]\"))\n        {\n\t\t\t//字段名与字段类型的获取\n            int index = name.IndexOf(\"]\") + 1;                              //得到\"]\"后第一个字符的索引\n            string fieldName = name.Substring(index, name.Length - index);  //获取字段名字\n            string fieldType = name.Substring(1, index - 2);                //获取字段类型\n\t\t\t//将获取到的字段名与类型名以及insID存入到列表内\n            objDataList.Add(new EditorObjectData { fieldName = fieldName, fieldType = fieldType, instanceID = obj.GetInstanceID() });\n\n            //计算该节点的查找路径，向上遍历游戏对象的父节点，直到遍历到最初的传入的窗口对象，获取它们的名字，拼接为查找路径\n            string objPath = name;\t\t\t\t//该游戏对象的查找路径\n            bool isFindOver = false;\t\t\t//查找路径是否拼接完成\n            Transform parent = obj.transform;\t//当前遍历到的父对象\n\t\t\t//这里的循环可以理解为记录已经向上遍历的层数，每走完一次这个循环流程，查找路径都会多一段，j \u003c 20即最高就遍历20层\n            for (int j = 0; j \u003c 20; j++)\n            {\n\t\t\t\t//这里的循环是每次都从本游戏对象出发，向上计数，判断是否查找完整的逻辑也在这里\n\t\t\t\t//踩坑，切勿搞反了这里的k \u003c= j，否则导致循环空转，浪费性能\n                for (int k = 0; k \u003c= j; k++)\n                {\n\t\t\t\t\t//当k == j，说明需要到了需要进行判断的层级\n                    if (k == j)\n                    {\n                    \tparent = parent.parent;     //使parent指向它的父对象，接下来用于确认是否再次向上获取父对象名字\n                        //对比父对象名字是否为最初传入的窗口名，若相等，即父节点是当前窗口，如果父节点是当前窗口，说明查找路径已经完整\n                        if (string.Equals(parent.name, WindowName))\n                        {\n                        \tisFindOver = true;\n                            break;\n                        }\n                        //若不相等，说明查找路径不完整，在路径字符串前拼上本次遍历的父对象的名字，继续循环\n                        else\n                        {\n                            objPath = objPath.Insert(0, parent.name + \"/\");\n                        }\n                    }\n                }\t//end for k\n                //若查找结束，说明这个控件的查找路径已经完整，应当跳出循环\n                if (isFindOver)\n                {\n                    break;\n                }\n            }\t//end for j\n\t\t\t//将拼接完成的路径传入到字典内\n            objFindPathDic.Add(obj.GetInstanceID(), objPath);\n        }\n\t\t//传入对象，重复上述流程，以递归的形式将所有的子对象全部解析一遍\n        PresWindowNodeData(transform.GetChild(i), WindowName);\n    }\t//end for i\n}\n\n/// \u003csummary\u003e\n/// 通过Tag解析窗口节点数据\n/// \u003c/summary\u003e\n/// \u003cparam name=\"transform\"\u003e要解析的窗口的Transform\u003c/param\u003e\n/// \u003cparam name=\"WindowName\"\u003e窗口名\u003c/param\u003e\npublic static void ParseWindowDataByTag(Transform transform, string WindowName)\n{\n    //当传入的对象下已无子对象，这里的for循环不执行\n    for (int i = 0; i \u003c transform.childCount; i++)\n    {\n        GameObject obj = transform.GetChild(i).gameObject;\n        string tagName = obj.tag;\n        //如果对象名包括\"[类型名]\"，说明该对象需要作为UI组件进行解析\n        if (GeneratorConfig.TAGArr.Contains(tagName))\n        {\n            string fieldName = obj.name;    //获取字段名字\n            string fieldType = tagName;     //获取字段类型\n\n            objDataList.Add(new EditorObjectData { fieldName = fieldName, fieldType = fieldType, instanceID = obj.GetInstanceID() });\n\n            //计算该节点的查找路径\n            string objPath = tagName;\n            bool isFindOver = false;\n            Transform parent = obj.transform;\n            for (int j = 0; j \u003c 20; j++)\n            {\n                for (int k = 0; k \u003c= j; k++)\n                {\n                    if (k == j)\n                    {\n                        parent = parent.parent;     //使临时变量parent指向它的父对象\n                        //对比两者名字，若相等，父节点是当前窗口，如果父节点是当前窗口，说明查找已经结束\n                        if (string.Equals(parent.name, WindowName))\n                        {\n                            isFindOver = true;\n                            break;\n                        }\n                        //若不相等，说明查找继续，在路径字符串前拼上父对象的名字\n                        else\n                        {\n                            objPath = objPath.Insert(0, parent.name + \"/\");\n                        }\n                    }\n                }\n                //若查找结束，说明这个控件的查找路径已经完整，应当跳出循环\n                if (isFindOver)\n                {\n                    break;\n                }\n            }\n            objFindPathDic.Add(obj.GetInstanceID(), objPath);\n        }\n        ParseWindowDataByTag(transform.GetChild(i), WindowName);\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125223056-rtxln7z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125223056-rtxln7z",
				"updated": "20240125223214"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "值得一提的是，解析方法执行完毕回到主函数后，主函数会执行将解析结果持久化的语句，目的是为了生成Window逻辑类脚本时也可以使用这些数据"
				}
			]
		},
		{
			"ID": "20240125160544-yoy0fbx",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125160544-yoy0fbx",
				"updated": "20240125213746"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.生成脚本字符串"
				}
			]
		},
		{
			"ID": "20240125160622-fhr779v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125160622-fhr779v",
				"updated": "20240125222648"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当窗口解析完成后，就需要根据解析结果，按照上面给出的组件查找脚本文本格式，生成脚本字符串，之后即可将字符串传入到预览窗口内供预览"
				}
			]
		},
		{
			"ID": "20240125222650-1pit94n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125222650-1pit94n",
				"updated": "20240125222826"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "声明字段与初始化方法里的调用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Find"
				},
				{
					"Type": "NodeText",
					"Data": "​语句和调用Window逻辑类添加监听函数的语句都会循环遍历之前解析出来的"
				}
			]
		},
		{
			"ID": "20240125160618-iu10snc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125160618-iu10snc",
				"style": "line-height: 22px;",
				"updated": "20240125213746"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/// \u003csummary\u003e\n/// 生成C#脚本字符串\n/// \u003c/summary\u003e\n/// \u003cparam name=\"name\"\u003e窗口名\u003c/param\u003e\n/// \u003creturns\u003e脚本字符串\u003c/returns\u003e\npublic static string CreateCS(string name)\n{\n    StringBuilder scriptText = new StringBuilder();\n    string nameSpaceName = \"ZMUIFrameWork\";\n    //添加引用\n    scriptText.AppendLine(\"/*-----------------------------------\");\n    scriptText.AppendLine(\" *Title: UI自动化组件查找代码工具\");\n    scriptText.AppendLine(\" *Author: 铸梦\");\n    scriptText.AppendLine(\" *Date:\" + System.DateTime.Now);\n    scriptText.AppendLine(\" *Description: 变量需要以[Text]括号加组件类型格式进行声明，然后右键窗口物体——一键生成UI组件查找脚本即可\");\n    scriptText.AppendLine(\" *注意，以下文件是自动生成的，任何手动修改都会被下次生成覆盖，若手动修改后，尽量避免自动生成\");\n    scriptText.AppendLine(\" *-----------------------------------*/\");\n    scriptText.AppendLine(\"using UnityEngine.UI;\");\n    scriptText.AppendLine(\"using UnityEngine;\");\n    scriptText.AppendLine();\n\n    //生成命名空间\n    if (!string.IsNullOrEmpty(nameSpaceName))\n    {\n        scriptText.AppendLine($\"namespace {nameSpaceName}\");\n        scriptText.AppendLine(\"{\");\n    }\n    scriptText.AppendLine($\"    public class {name + \"UIComponent\"}\");\n    scriptText.AppendLine(\"    {\");\n\n    //根据字段数据列表 声明字段\n    foreach (var item in objDataList)\n    {\n        scriptText.AppendLine(\"        public \" + item.fieldType + \" \" + item.fieldName + item.fieldType + \";\\r\\n\");    //写\\r\\n是因为万恶的CRLF\n    }\n\n    //声明初始化组件接口\n    scriptText.AppendLine(\"        public void InitComponent(WindowBase target)\");\n    scriptText.AppendLine(\"        {\");\n    scriptText.AppendLine(\"            //组件查找\");\n    //根据查找路径字典 和字段数据列表生成组件查找代码;\n    foreach (var item in objFindPathDic)\n    {\n        EditorObjectData itemData = GetEditorObjectData(item.Key);\n        string relFieldName = itemData.fieldName + itemData.fieldType;\n        if (string.Equals(\"GameObject\", itemData.fieldType))\n        {\n            scriptText.AppendLine($\"            {relFieldName} = target.transform.Find(\\\"{item.Value}\\\").gameObject;\");\n        }\n        else if (string.Equals(\"Transform\", itemData.fieldType))\n        {\n            scriptText.AppendLine($\"            {relFieldName} = target.transform.Find(\\\"{item.Value}\\\").transform;\");\n        }\n        else\n        {\n            scriptText.AppendLine($\"            {relFieldName} = target.transform.Find(\\\"{item.Value}\\\").GetComponent\u003c{itemData.fieldType}\u003e();\");\n        }\n    }\n    scriptText.AppendLine(\"    \");\n    scriptText.AppendLine(\"    \");\n    scriptText.AppendLine(\"            //组件事件绑定\");\n    //得到逻辑类 WindowBase 强转为目标派生类\n    scriptText.AppendLine($\"            {name} mWindow = ({name})target;\");\n\n    //生成UI事件绑定代码\n    foreach (var item in objDataList)\n    {\n        string type = item.fieldType;\n        string methodName = item.fieldName;\n        string suffix;\n        if (type.Contains(\"Button\"))\n        {\n            suffix = \"Click\";\n            scriptText.AppendLine($\"            target.AddButtonClickListener({methodName}{type}, mWindow.On{methodName}Button{suffix});\");\n        }\n        if (type.Contains(\"InputField\"))\n        {\n            scriptText.AppendLine($\"            target.AddInputFieldListener({methodName}{type}, mWindow.On{methodName}InputChange, mWindow.On{methodName}InputEnd);\");\n        }\n        if (type.Contains(\"Toggle\"))\n        {\n            suffix = \"Change\";\n            scriptText.AppendLine($\"            target.AddToggleClickListener({methodName}{type}, mWindow.On{methodName}Toggle{suffix});\");\n        }\n    }\n    scriptText.AppendLine(\"        }\");\n    scriptText.AppendLine(\"    }\");\n    if (!string.IsNullOrEmpty(nameSpaceName))\n    {\n        scriptText.AppendLine(\"}\");\n    }\n    return scriptText.ToString();\n}\n\n//根据UI控件的instanceID，获取该UI控件的解析数据\npublic static EditorObjectData GetEditorObjectData(int instanceID)\n{\n    foreach (var item in objDataList)\n    {\n        if (item.instanceID == instanceID)\n        {\n            return item;\n        }\n    }\n    return null;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125161131-rnngasu",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125161131-rnngasu",
				"updated": "20240125161244"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "GeneratorFindComponentTool代码"
				}
			]
		},
		{
			"ID": "20240125161203-yw5bdhz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125161203-yw5bdhz",
				"style": "line-height: 22px;",
				"updated": "20240125161244"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using Newtonsoft.Json;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing UnityEditor;\nusing UnityEngine;\n\npublic class GeneratorFindComponentTool : Editor\n{\n    public static Dictionary\u003cint, string\u003e objFindPathDic;   //Key是物体的instanceId，value是物体的查找路径（可通过Transform.Find来寻找对象）\n    public static List\u003cEditorObjectData\u003e objDataList;       //查找对象的数据\n\n    [MenuItem(\"GameObject/生成组件查找脚本(Shift+U) #U\", false, 0)]\n    private static void CreateFindComponentScripts()\n    {\n        //获取在编辑器里选中的内容\n        GameObject obj = Selection.objects.First() as GameObject;\n        if (obj == null)\n        {\n            Debug.LogError(\"需要选择GameObject\");\n            return;\n        }\n        objDataList = new List\u003cEditorObjectData\u003e();\n        objFindPathDic = new Dictionary\u003cint, string\u003e();\n\n        //设置脚本的生成路径\n        if (!Directory.Exists(GeneratorConfig.FindComponentGeneratorPath))\n        {\n            Directory.CreateDirectory(GeneratorConfig.FindComponentGeneratorPath);\n        }\n        //解析窗口所有UI组件数据\n        if (GeneratorConfig.ParseType == ParseType.Tag)\n            ParseWindowDataByTag(obj.transform, obj.name);\n        else\n            PresWindowNodeData(obj.transform, obj.name);\n        //储存字段名称\n        string dataListJson = JsonConvert.SerializeObject(objDataList);\n        PlayerPrefs.SetString(GeneratorConfig.OBJDATALIST_KEY, dataListJson);\n        //生成C#脚本文件\n        string csScriptText = CreateCS(obj.name);\n        string csPath = GeneratorConfig.FindComponentGeneratorPath + \"/\" + obj.name + \"UIComponent.cs\";\n        UIWindowEditor.ShowWindow(csScriptText, csPath);\n    }\n\n    /// \u003csummary\u003e\n    /// 解析窗口节点数据\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"transform\"\u003e要解析的窗口的Transform\u003c/param\u003e\n    /// \u003cparam name=\"WindowName\"\u003e窗口名\u003c/param\u003e\n    public static void PresWindowNodeData(Transform transform, string WindowName)\n    {\n        //当传入的对象下已无子对象，这里的for循环不执行\n        for (int i = 0; i \u003c transform.childCount; i++)\n        {\n            GameObject obj = transform.GetChild(i).gameObject;\n            string name = obj.name;\n            //如果对象名包括\"[类型名]\"，说明该对象需要作为UI组件进行解析\n            if (name.Contains(\"[\") \u0026\u0026 name.Contains(\"]\"))\n            {\n                int index = name.IndexOf(\"]\") + 1;                              //得到\"]\"后第一个字符的索引\n                string fieldName = name.Substring(index, name.Length - index);  //获取字段名字\n                string fieldType = name.Substring(1, index - 2);                //获取字段类型\n\n                objDataList.Add(new EditorObjectData { fieldName = fieldName, fieldType = fieldType, instanceID = obj.GetInstanceID() });\n\n                //计算该节点的查找路径\n                string objPath = name;\n                bool isFindOver = false;\n                Transform parent = obj.transform;\n                for (int j = 0; j \u003c 20; j++)\n                {\n                    for (int k = 0; k \u003c= j; k++)\n                    {\n                        if (k == j)\n                        {\n                            parent = parent.parent;     //使临时变量parent指向它的父对象\n                            //对比两者名字，若相等，父节点是当前窗口，如果父节点是当前窗口，说明查找已经结束\n                            if (string.Equals(parent.name, WindowName))\n                            {\n                                isFindOver = true;\n                                break;\n                            }\n                            //若不相等，说明查找继续，在路径字符串前拼上父对象的名字\n                            else\n                            {\n                                objPath = objPath.Insert(0, parent.name + \"/\");\n                            }\n                        }\n                    }\n                    //若查找结束，说明这个控件的查找路径已经完整，应当跳出循环\n                    if (isFindOver)\n                    {\n                        break;\n                    }\n                }\n                objFindPathDic.Add(obj.GetInstanceID(), objPath);\n            }\n            PresWindowNodeData(transform.GetChild(i), WindowName);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 通过Tag解析窗口节点数据\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"transform\"\u003e要解析的窗口的Transform\u003c/param\u003e\n    /// \u003cparam name=\"WindowName\"\u003e窗口名\u003c/param\u003e\n    public static void ParseWindowDataByTag(Transform transform, string WindowName)\n    {\n        //当传入的对象下已无子对象，这里的for循环不执行\n        for (int i = 0; i \u003c transform.childCount; i++)\n        {\n            GameObject obj = transform.GetChild(i).gameObject;\n            string tagName = obj.tag;\n            //如果对象名包括\"[类型名]\"，说明该对象需要作为UI组件进行解析\n            if (GeneratorConfig.TAGArr.Contains(tagName))\n            {\n                string fieldName = obj.name;    //获取字段名字\n                string fieldType = tagName;     //获取字段类型\n\n                objDataList.Add(new EditorObjectData { fieldName = fieldName, fieldType = fieldType, instanceID = obj.GetInstanceID() });\n\n                //计算该节点的查找路径\n                string objPath = tagName;\n                bool isFindOver = false;\n                Transform parent = obj.transform;\n                for (int j = 0; j \u003c 20; j++)\n                {\n                    for (int k = 0; k \u003c= j; k++)\n                    {\n                        if (k == j)\n                        {\n                            parent = parent.parent;     //使临时变量parent指向它的父对象\n                            //对比两者名字，若相等，父节点是当前窗口，如果父节点是当前窗口，说明查找已经结束\n                            if (string.Equals(parent.name, WindowName))\n                            {\n                                isFindOver = true;\n                                break;\n                            }\n                            //若不相等，说明查找继续，在路径字符串前拼上父对象的名字\n                            else\n                            {\n                                objPath = objPath.Insert(0, parent.name + \"/\");\n                            }\n                        }\n                    }\n                    //若查找结束，说明这个控件的查找路径已经完整，应当跳出循环\n                    if (isFindOver)\n                    {\n                        break;\n                    }\n                }\n                objFindPathDic.Add(obj.GetInstanceID(), objPath);\n            }\n            ParseWindowDataByTag(transform.GetChild(i), WindowName);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 生成C#脚本字符串\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"name\"\u003e窗口名\u003c/param\u003e\n    /// \u003creturns\u003e脚本字符串\u003c/returns\u003e\n    public static string CreateCS(string name)\n    {\n        StringBuilder scriptText = new StringBuilder();\n        string nameSpaceName = \"ZMUIFrameWork\";\n        //添加引用\n        scriptText.AppendLine(\"/*-----------------------------------\");\n        scriptText.AppendLine(\" *Title: UI自动化组件查找代码工具\");\n        scriptText.AppendLine(\" *Author: 铸梦\");\n        scriptText.AppendLine(\" *Date:\" + System.DateTime.Now);\n        scriptText.AppendLine(\" *Description: 变量需要以[Text]括号加组件类型格式进行声明，然后右键窗口物体——一键生成UI组件查找脚本即可\");\n        scriptText.AppendLine(\" *注意，以下文件是自动生成的，任何手动修改都会被下次生成覆盖，若手动修改后，尽量避免自动生成\");\n        scriptText.AppendLine(\" *-----------------------------------*/\");\n        scriptText.AppendLine(\"using UnityEngine.UI;\");\n        scriptText.AppendLine(\"using UnityEngine;\");\n        scriptText.AppendLine();\n\n        //生成命名空间\n        if (!string.IsNullOrEmpty(nameSpaceName))\n        {\n            scriptText.AppendLine($\"namespace {nameSpaceName}\");\n            scriptText.AppendLine(\"{\");\n        }\n        scriptText.AppendLine($\"    public class {name + \"UIComponent\"}\");\n        scriptText.AppendLine(\"    {\");\n\n        //根据字段数据列表 声明字段\n        foreach (var item in objDataList)\n        {\n            scriptText.AppendLine(\"        public \" + item.fieldType + \" \" + item.fieldName + item.fieldType + \";\\r\\n\");    //写\\r\\n是因为万恶的CRLF\n        }\n\n        //声明初始化组件接口\n        scriptText.AppendLine(\"        public void InitComponent(WindowBase target)\");\n        scriptText.AppendLine(\"        {\");\n        scriptText.AppendLine(\"            //组件查找\");\n        //根据查找路径字典 和字段数据列表生成组件查找代码;\n        foreach (var item in objFindPathDic)\n        {\n            EditorObjectData itemData = GetEditorObjectData(item.Key);\n            string relFieldName = itemData.fieldName + itemData.fieldType;\n            if (string.Equals(\"GameObject\", itemData.fieldType))\n            {\n                scriptText.AppendLine($\"            {relFieldName} = target.transform.Find(\\\"{item.Value}\\\").gameObject;\");\n            }\n            else if (string.Equals(\"Transform\", itemData.fieldType))\n            {\n                scriptText.AppendLine($\"            {relFieldName} = target.transform.Find(\\\"{item.Value}\\\").transform;\");\n            }\n            else\n            {\n                scriptText.AppendLine($\"            {relFieldName} = target.transform.Find(\\\"{item.Value}\\\").GetComponent\u003c{itemData.fieldType}\u003e();\");\n            }\n        }\n        scriptText.AppendLine(\"    \");\n        scriptText.AppendLine(\"    \");\n        scriptText.AppendLine(\"            //组件事件绑定\");\n        //得到逻辑类 WindowBase 强转为目标派生类\n        scriptText.AppendLine($\"            {name} mWindow = ({name})target;\");\n\n        //生成UI事件绑定代码\n        foreach (var item in objDataList)\n        {\n            string type = item.fieldType;\n            string methodName = item.fieldName;\n            string suffix;\n            if (type.Contains(\"Button\"))\n            {\n                suffix = \"Click\";\n                scriptText.AppendLine($\"            target.AddButtonClickListener({methodName}{type}, mWindow.On{methodName}Button{suffix});\");\n            }\n            if (type.Contains(\"InputField\"))\n            {\n                scriptText.AppendLine($\"            target.AddInputFieldListener({methodName}{type}, mWindow.On{methodName}InputChange, mWindow.On{methodName}InputEnd);\");\n            }\n            if (type.Contains(\"Toggle\"))\n            {\n                suffix = \"Change\";\n                scriptText.AppendLine($\"            target.AddToggleClickListener({methodName}{type}, mWindow.On{methodName}Toggle{suffix});\");\n            }\n        }\n        scriptText.AppendLine(\"        }\");\n        scriptText.AppendLine(\"    }\");\n        if (!string.IsNullOrEmpty(nameSpaceName))\n        {\n            scriptText.AppendLine(\"}\");\n        }\n        return scriptText.ToString();\n    }\n\n    public static EditorObjectData GetEditorObjectData(int instanceID)\n    {\n        foreach (var item in objDataList)\n        {\n            if (item.instanceID == instanceID)\n            {\n                return item;\n            }\n        }\n        return null;\n    }\n}\n\npublic class EditorObjectData\n{\n    public int instanceID;\n    public string fieldName;\n    public string fieldType;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125161219-3cx4wet",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240125161219-3cx4wet",
				"updated": "20240125161249"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "三、组件数据绑定脚本的生成"
				}
			]
		},
		{
			"ID": "20240125213440-dw0ze61",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125213440-dw0ze61",
				"updated": "20240125213447"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件数据脚本同样是负责"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "获取并管理UI控件，供Window逻辑类调用UI控件，初始化方法里将Window逻辑类里监听函数添加到控件中"
				}
			]
		},
		{
			"ID": "20240125213457-adpyw1l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125213457-adpyw1l",
				"updated": "20240125213501"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件数据脚本代码需要生成如下部分："
				}
			]
		},
		{
			"ID": "20240125213457-w61bnoh",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240125213457-w61bnoh",
				"updated": "20240125213457"
			},
			"Children": [
				{
					"ID": "20240125213457-oemh2vd",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125213457-oemh2vd",
						"updated": "20240125213457"
					},
					"Children": [
						{
							"ID": "20240125213457-nzq3cw5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125213457-nzq3cw5",
								"updated": "20240125213457"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "脚本为自动生成的提示，命名空间的引用"
								}
							]
						}
					]
				},
				{
					"ID": "20240125213457-aypfjpy",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125213457-aypfjpy",
						"updated": "20240125213457"
					},
					"Children": [
						{
							"ID": "20240125213457-2cag2zs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125213457-2cag2zs",
								"updated": "20240125213457"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "命名空间与数据查找类的声明"
								}
							]
						}
					]
				},
				{
					"ID": "20240125213457-13tb1my",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125213457-13tb1my",
						"updated": "20240125213457"
					},
					"Children": [
						{
							"ID": "20240125213457-jpw2g69",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125213457-jpw2g69",
								"updated": "20240125213457"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "数据查找类要包括所有的需要管理的UI控件的字段"
								}
							]
						}
					]
				},
				{
					"ID": "20240125213457-ufadnml",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125213457-ufadnml",
						"updated": "20240125213457"
					},
					"Children": [
						{
							"ID": "20240125213457-axfwl9y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125213457-axfwl9y",
								"updated": "20240125213457"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "数据查找类要包括初始化方法，其中包括将对应的Window逻辑类的监听函数添加到UI控件的语句"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240125213457-ljhk385",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125213457-ljhk385",
				"style": "line-height: 22px;",
				"updated": "20240125215051"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//自动化脚本生成示例\n\n/*-----------------------------------\n *Title: UI自动化组件生成代码生成工具\n *Author: 铸梦\n *Date:2024/1/25 14:53:08\n *Description: 变量需要以[Text]括号加组件类型格式进行声明，然后右键窗口物体——一键生成UI数据组件脚本即可\n *注意，以下文件是自动生成的，任何手动修改都会被下次生成覆盖，若手动修改后，尽量避免自动生成\n *-----------------------------------*/\nusing UnityEngine.UI;\nusing UnityEngine;\n\nnamespace ZMUIFrameWork\n{\n    public class TempWindow2DataComponent : MonoBehaviour\n    {\n        public Button CloseButton;\n\n        public void InitComponent(WindowBase target)\n        {\n            //组件事件绑定\n            TempWindow2 mWindow = (TempWindow2)target;\n            target.AddButtonClickListener(CloseButton, mWindow.OnCloseButtonClick);\n        }\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125213457-nefwec1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125213457-nefwec1",
				"updated": "20240125222439"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件数据脚本与组件查找脚本相比，只是少了使用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Find"
				},
				{
					"Type": "NodeText",
					"Data": "​方法获取UI控件的语句，而前者的获取组件逻辑将在编译完成就执行，而不是运行时执行"
				}
			]
		},
		{
			"ID": "20240125163730-44283i1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125163730-44283i1",
				"updated": "20240125221622"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件数据查找脚本的生成主要在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorBindComponentTool"
				},
				{
					"Type": "NodeText",
					"Data": "​内实现，它继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Editor"
				},
				{
					"Type": "NodeText",
					"Data": "​\n它需要为"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "右键菜单提供“生成组件数据脚本”选项（快捷键Shift+B）"
				},
				{
					"Type": "NodeText",
					"Data": "，因此需要为一个函数添加"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "[MenuItem]"
				},
				{
					"Type": "NodeText",
					"Data": "​特性作为入口函数（"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "#B"
				},
				{
					"Type": "NodeText",
					"Data": "​是指定快捷键）"
				}
			]
		},
		{
			"ID": "20240125234128-ic04ofy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125234128-ic04ofy",
				"updated": "20240125234128"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 286px;",
						"style": "width: 276px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240125234107-i24qsae.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 276px;\" parent-style=\"width: 286px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240125234127-23u8866",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125234127-23u8866",
				"updated": "20240125234127"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对窗口对象右键选择该选项后对选中的窗口对象进行解析，主函数执行步骤如下："
				}
			]
		},
		{
			"ID": "20240125163730-343fu8i",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125163730-343fu8i",
				"style": "line-height: 22px;",
				"updated": "20240125223019"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//生成组件数据脚本方法，选中游戏对象后在右键菜单点击“生成组件数据脚本”调用\n[MenuItem(\"GameObject/生成组件数据脚本(Shift+B) #B\", false, 0)]\nprivate static void CreateBindComponentScripts()\n{\n    1.获取在编辑器里选中的内容，判断是否为游戏对象，不是则报错并直接返回空\n\t2.设置脚本的生成路径\n\t3.调用PresWindowNodeData或PerseWindowNodeData，将获取到的窗口传入，解析数据\n\t4.将解析到的数据使用PlayerPrefs持久化，后续生成Window数据类脚本还会用到\n\t5.通过解析的内容生成对应脚本字符串\n\t6.将脚本字符串与生成脚本路径传入预览窗口显示\n\t7.生成完成后使用EditorPrefs来持久化一个标记，使AddComponentToWindow()函数可以执行\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125163730-q9nly8u",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125163730-q9nly8u",
				"style": "line-height: 22px;",
				"updated": "20240125161249"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class GeneratorBindComponentTool : Editor\n{\n    public static List\u003cEditorObjectData\u003e objDataList;       //查找对象的数据\n\n    [MenuItem(\"GameObject/生成组件数据脚本(Shift+B) #B\", false, 0)]\n    private static void CreateBindComponentScripts()\n    {\n        //获取在编辑器里选中的内容\n        GameObject obj = Selection.objects.First() as GameObject;\n        if (obj == null)\n        {\n            Debug.LogError(\"需要选择GameObject\");\n            return;\n        }\n        objDataList = new List\u003cEditorObjectData\u003e();\n\n        //设置脚本的生成路径\n        if (!Directory.Exists(GeneratorConfig.BindComponentGeneratorPath))\n        {\n            Directory.CreateDirectory(GeneratorConfig.BindComponentGeneratorPath);\n        }\n        //解析窗口所有UI组件数据\n        if (GeneratorConfig.ParseType == ParseType.Tag)\n            ParseWindowDataByTag(obj.transform, obj.name);\n        else\n            PresWindowNodeData(obj.transform, obj.name);\n        //储存字段名称\n        string dataListJson = JsonConvert.SerializeObject(objDataList);\n        PlayerPrefs.SetString(GeneratorConfig.OBJDATALIST_KEY, dataListJson); \n        //生成C#脚本文件\n        string csScriptText = CreateCS(obj.name);\n        string csPath = GeneratorConfig.BindComponentGeneratorPath + \"/\" + obj.name + \"DataComponent.cs\";\n        UIWindowEditor.ShowWindow(csScriptText, csPath);\n        //生成完成后使用EditorPrefs来持久化一个标记，使AddComponentToWindow()函数可以执行\n        EditorPrefs.SetString(\"GeneratorClassName\", obj.name + \"DataComponent\");\n    }\n\n    // 解析窗口节点数据\n    public static void PresWindowNodeData(Transform transform, string WindowName)...\n\n    public static void ParseWindowDataByTag(Transform transform, string WindowName)...\n\n    // 生成C#脚本字符串\n    public static string CreateCS(string name)...\n\n    public static EditorObjectData GetEditorObjectData(int instanceID)...\n\n    // 编译完成后Unity自动调用的方法\n    [UnityEditor.Callbacks.DidReloadScripts]    //编译完成后，Unity会自动执行该函数的特性\n    public static void AddComponentToWindow()...\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125162203-edbtqh1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125162203-edbtqh1",
				"updated": "20240125161249"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件数据绑定脚本由于只是在脚本关联控件的方式有所不同，因此生成逻辑与组件数据查找脚本的生成逻辑高度相似，主要的区别在于："
				}
			]
		},
		{
			"ID": "20240125161619-1yscycr",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240125161619-1yscycr",
				"updated": "20240125161249"
			},
			"Children": [
				{
					"ID": "20240125161620-3v6hisf",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125161620-3v6hisf",
						"updated": "20240125161620"
					},
					"Children": [
						{
							"ID": "20240125161620-xjr8xp7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125161620-xjr8xp7",
								"updated": "20240125161655"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "组件数据绑定脚本不需要解析UI控件对象的查找路径"
								}
							]
						}
					]
				},
				{
					"ID": "20240125161656-rr2obqr",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125161656-rr2obqr"
					},
					"Children": [
						{
							"ID": "20240125161656-b9cn2em",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125161656-b9cn2em",
								"updated": "20240125161808"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "组件数据绑定脚本在生成脚本字符串完毕后会持久化一个标记，让自动挂载与关联方法在编译后生效"
								}
							]
						}
					]
				},
				{
					"ID": "20240125161808-n4e9bi0",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125161808-n4e9bi0"
					},
					"Children": [
						{
							"ID": "20240125161808-6d5k30i",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125161808-6d5k30i",
								"updated": "20240125162044"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在生成脚本字符串并编译脚本完毕后，会获取场景上的窗口对象，将脚本挂载到上面，同时利用反射，将UI控件关联到脚本的各个字段上"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240125162045-6yb00rt",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125162045-6yb00rt",
				"updated": "20240125213752"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "脚本自动挂载与关联"
				}
			]
		},
		{
			"ID": "20240125163345-o8gsd4y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125163345-o8gsd4y",
				"updated": "20240125221801"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件数据脚本的逻辑大体与上面查找脚本一致，核心区别在于控制在编译完成后就自动完成挂载与关联"
				}
			]
		},
		{
			"ID": "20240125162107-gwjn3hf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125162107-gwjn3hf",
				"updated": "20240125213752"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当主函数将窗口解析完毕后，主函数会对在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "EditorPrefs"
				},
				{
					"Type": "NodeText",
					"Data": "​持久化一个标记，使"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AddComponentToWindow()"
				},
				{
					"Type": "NodeText",
					"Data": "​生效\n​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "AddComponentToWindow()"
				},
				{
					"Type": "NodeText",
					"Data": "​利用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "[UnityEditor.Callbacks.DidReloadScripts]"
				},
				{
					"Type": "NodeText",
					"Data": "​特性在每次编译后都会执行\n当发现存在标记时，就会执行将生成的脚本挂载到窗口对象和将窗口的各个UI控件自动关联到脚本上的逻辑"
				}
			]
		},
		{
			"ID": "20240125163900-e8ftk7c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125163900-e8ftk7c",
				"updated": "20240125164011"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里使用了反射来获取生成的组件数据类，同时也使用反射来获取类的各个字段，将UI控件对象关联到挂载在窗口对象上的组件数据类对象"
				}
			]
		},
		{
			"ID": "20240125223613-ls5soy3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125223613-ls5soy3",
				"updated": "20240125223627"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "代码的思路如下："
				}
			]
		},
		{
			"ID": "20240125223627-rvz3iez",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125223627-rvz3iez",
				"style": "line-height: 22px;",
				"updated": "20240125230112"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 编译完成后Unity自动调用的方法\n[UnityEditor.Callbacks.DidReloadScripts]    //编译完成后，Unity会自动执行该函数的特性\npublic static void AddComponentToWindow()\n{\n\tif 不存在由CreateBindComponentScripts()方法中持久化的标记\n\t\treturn\n\t读取标记，从标记中获取本次需要自动挂载脚本与管理组件的窗口名，进而获取组件数据类名（名字一般为“窗口名+DataComponent”）\n\t通过\"ZMUIFrameWork.组件数据类名\"，从\"Assembly-CSharp\"程序集内获取组件数据类类型\n\tif 组件数据类类型 == null\n\t\t报错\n\t\treturn\n\t通过之前得到的窗口名，查找得到场景上的UI窗口对象\n\tif UI窗口对象 == null\n\t\t报错\n\t\treturn\n\t根据之前得到的组件数据类类型，获取UI窗口对象上的组件数据脚本\n\t如果组件数据脚本为空，根据之前得到的组件数据类类型，向UI窗口对象添加该脚本\n\t读取之前由CreateBindComponentScripts()使用通过PlayerPrefs持久化的窗口解析数据\n\tfor 遍历通过反射组件数据类类型得到的所有字段\n\t\tfor 遍历解析得到的所有UI控件数据\n\t\t\tif 字段名 == UI控件名+类型名\n\t\t\t\t根据解析数据中UI控件的InstanceID获取场景上的这个UI控件对象\n\t\t\t\tif 类型名 == GameObject\n\t\t\t\t\t根据遍历到的字段，通过反射，将UI控件对象关联到组件数据类字段上\n\t\t\t\telse\n\t\t\t\t\t从UI控件对象获取控件脚本（例如Button脚本）\n\t\t\t\t\t根据遍历到的字段，通过反射，将控件脚本关联到组件数据类字段上\n\t处理完成后删除标记，防止重复执行这里的方法\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125163209-dqiiuut",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125163209-dqiiuut",
				"style": "line-height: 22px;",
				"updated": "20240125213752"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/// \u003csummary\u003e\n/// 编译完成后Unity自动调用的方法\n/// \u003c/summary\u003e\n[UnityEditor.Callbacks.DidReloadScripts]    //编译完成后，Unity会自动执行该函数的特性\npublic static void AddComponentToWindow()\n{\n    //如果当前生成的不是数据脚本的回调，就不处理\n    string className = EditorPrefs.GetString(\"GeneratorClassName\");\n    if (string.IsNullOrEmpty(className))\n    {\n        return;\n    }\n    //通过反射的方式，从程序集中找到这个脚本，把它挂载到当前的物体上\n    //获取所有的程序集，找到CSharp程序集，再获取类所在的程序集路径\n    var assembiles = AppDomain.CurrentDomain.GetAssemblies();\n    var cSharpAssembly = assembiles.First(assembly =\u003e assembly.GetName().Name == \"Assembly-CSharp\");\n    string relClassName = \"ZMUIFrameWork.\" + className;\n    Type type = cSharpAssembly.GetType(relClassName);\n    //若为空，就直接返回\n    if (type == null)\n    {\n        Debug.LogError($\"{relClassName}: 未能在{cSharpAssembly}内找到该类，请检查是否存在该类！\");\n        return;\n    }\n    //获取要挂载的那个物体\n    string windowObjName = className.Replace(\"DataComponent\", \"\");\n    GameObject windowObj = GameObject.Find(windowObjName);\n    if (windowObj == null)\n    {\n        windowObj = GameObject.Find(\"UIRoot/\" + windowObjName);\n        if (windowObj == null)\n        {\n            Debug.LogWarning($\"{className}: 未在场景上找到需要绑定UI控件的Window，绑定操作未完成\");\n            return;\n        }\n    }\n    //先获取现窗口上有没有挂载该数据组件，如果没有挂载再进行挂载\n    Component component = windowObj.GetComponent(type);\n    if (component == null)\n    {\n        component = windowObj.AddComponent(type);\n    }\n\n    //通过反射的方式，遍历数据列表，找到对应的字段并赋值\n    //获取对象数据列表\n    string dataListJson = PlayerPrefs.GetString(GeneratorConfig.OBJDATALIST_KEY);\n    List\u003cEditorObjectData\u003e objDataList = JsonConvert.DeserializeObject\u003cList\u003cEditorObjectData\u003e\u003e(dataListJson);\n    //获取脚本所有字段\n    FieldInfo[] fieldInfoList = type.GetFields();\n    foreach (var fieldInfo in fieldInfoList)\n    {\n        foreach (var objData in objDataList)\n        {\n            if (fieldInfo.Name == objData.fieldName + objData.fieldType)\n            {\n                //根据InstanceID找到对应的对象\n                GameObject uiObject = EditorUtility.InstanceIDToObject(objData.instanceID) as GameObject;\n                if (uiObject == null)\n                {\n                    Debug.LogError($\"[{objData.fieldType}]{objData.fieldName}: 未能通过生成组件数据脚本时保存的InstanceID找到此UI控件，可能需要重新执行生成组件数据脚本操作！\");\n                    continue;\n                }\n                //设置该字段所对应的对象\n                if (string.Equals(objData.fieldType, \"GameObject\"))\n                {\n                    fieldInfo.SetValue(component, uiObject);\n                }\n                else\n                {\n                    fieldInfo.SetValue(component, uiObject.GetComponent(objData.fieldType));\n                }\n                break;\n            }\n        }\n    }\n    //处理完成后删除标记，防止后续的非生成数据脚本的回调触发执行该函数\n    EditorPrefs.DeleteKey(\"GeneratorClassName\");\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125164033-nfbhee9",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125164033-nfbhee9",
				"updated": "20240125161249"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "GeneratorBindComponentTool代码"
				}
			]
		},
		{
			"ID": "20240125164033-xxa96tn",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125164033-xxa96tn",
				"style": "line-height: 22px;",
				"updated": "20240125161249"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using Newtonsoft.Json;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing UnityEditor;\nusing UnityEngine;\n\npublic class GeneratorBindComponentTool : Editor\n{\n    public static List\u003cEditorObjectData\u003e objDataList;       //查找对象的数据\n\n    [MenuItem(\"GameObject/生成组件数据脚本(Shift+B) #B\", false, 0)]\n    private static void CreateFindComponentScripts()\n    {\n        //获取在编辑器里选中的内容\n        GameObject obj = Selection.objects.First() as GameObject;\n        if (obj == null)\n        {\n            Debug.LogError(\"需要选择GameObject\");\n            return;\n        }\n        objDataList = new List\u003cEditorObjectData\u003e();\n\n        //设置脚本的生成路径\n        if (!Directory.Exists(GeneratorConfig.BindComponentGeneratorPath))\n        {\n            Directory.CreateDirectory(GeneratorConfig.BindComponentGeneratorPath);\n        }\n        //解析窗口所有UI组件数据\n        if (GeneratorConfig.ParseType == ParseType.Tag)\n            ParseWindowDataByTag(obj.transform, obj.name);\n        else\n            PresWindowNodeData(obj.transform, obj.name);\n        //储存字段名称\n        string dataListJson = JsonConvert.SerializeObject(objDataList);\n        PlayerPrefs.SetString(GeneratorConfig.OBJDATALIST_KEY, dataListJson); \n        //生成C#脚本文件\n        string csScriptText = CreateCS(obj.name);\n        string csPath = GeneratorConfig.BindComponentGeneratorPath + \"/\" + obj.name + \"DataComponent.cs\";\n        UIWindowEditor.ShowWindow(csScriptText, csPath);\n        //生成完成后使用EditorPrefs来持久化一个标记，使AddComponentToWindow()函数可以执行\n        EditorPrefs.SetString(\"GeneratorClassName\", obj.name + \"DataComponent\");\n    }\n\n    /// \u003csummary\u003e\n    /// 解析窗口节点数据\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"transform\"\u003e要解析的窗口的Transform\u003c/param\u003e\n    /// \u003cparam name=\"WindowName\"\u003e窗口名\u003c/param\u003e\n    public static void PresWindowNodeData(Transform transform, string WindowName)\n    {\n        //当传入的对象下已无子对象，这里的for循环不执行\n        for (int i = 0; i \u003c transform.childCount; i++)\n        {\n            GameObject obj = transform.GetChild(i).gameObject;\n            string name = obj.name;\n            //如果对象名包括\"[类型名]\"，说明该对象需要作为UI组件进行解析\n            if (name.Contains(\"[\") \u0026\u0026 name.Contains(\"]\"))\n            {\n                int index = name.IndexOf(\"]\") + 1;                              //得到\"]\"后第一个字符的索引\n                string fieldName = name.Substring(index, name.Length - index);  //获取字段名字\n                string fieldType = name.Substring(1, index - 2);                //获取字段类型\n\n                objDataList.Add(new EditorObjectData { fieldName = fieldName, fieldType = fieldType, instanceID = obj.GetInstanceID() });\n            }\n            PresWindowNodeData(transform.GetChild(i), WindowName);\n        }\n    }\n\n    public static void ParseWindowDataByTag(Transform transform, string WindowName)\n    {\n        //当传入的对象下已无子对象，这里的for循环不执行\n        for (int i = 0; i \u003c transform.childCount; i++)\n        {\n            GameObject obj = transform.GetChild(i).gameObject;\n            string tagName = obj.tag;\n            //如果对象名包括\"[类型名]\"，说明该对象需要作为UI组件进行解析\n            if (GeneratorConfig.TAGArr.Contains(tagName))\n            {\n                string fieldName = obj.name;    //获取字段名字\n                string fieldType = tagName;     //获取字段类型\n                objDataList.Add(new EditorObjectData { fieldName = fieldName, fieldType = fieldType, instanceID = obj.GetInstanceID() });\n            }\n            ParseWindowDataByTag(transform.GetChild(i), WindowName);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 生成C#脚本字符串\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"name\"\u003e窗口名\u003c/param\u003e\n    /// \u003creturns\u003e脚本字符串\u003c/returns\u003e\n    public static string CreateCS(string name)\n    {\n        StringBuilder scriptText = new StringBuilder();\n        string nameSpaceName = \"ZMUIFrameWork\";\n        //添加引用\n        scriptText.AppendLine(\"/*-----------------------------------\");\n        scriptText.AppendLine(\" *Title: UI自动化组件生成代码生成工具\");\n        scriptText.AppendLine(\" *Author: 铸梦\");\n        scriptText.AppendLine(\" *Date:\" + System.DateTime.Now);\n        scriptText.AppendLine(\" *Description: 变量需要以[Text]括号加组件类型格式进行声明，然后右键窗口物体——一键生成UI数据组件脚本即可\");\n        scriptText.AppendLine(\" *注意，以下文件是自动生成的，任何手动修改都会被下次生成覆盖，若手动修改后，尽量避免自动生成\");\n        scriptText.AppendLine(\" *-----------------------------------*/\");\n        scriptText.AppendLine(\"using UnityEngine.UI;\");\n        scriptText.AppendLine(\"using UnityEngine;\");\n        scriptText.AppendLine();\n\n        //生成命名空间\n        if (!string.IsNullOrEmpty(nameSpaceName))\n        {\n            scriptText.AppendLine($\"namespace {nameSpaceName}\");\n            scriptText.AppendLine(\"{\");\n        }\n        scriptText.AppendLine($\"    public class {name + \"DataComponent : MonoBehaviour\"}\");\n        scriptText.AppendLine(\"    {\");\n\n        //根据字段数据列表 声明字段\n        foreach (var item in objDataList)\n        {\n            scriptText.AppendLine(\"        public \" + item.fieldType + \" \" + item.fieldName + item.fieldType + \";\\r\\n\");    //写\\r\\n是因为万恶的CRLF\n        }\n\n        //声明初始化组件接口\n        scriptText.AppendLine(\"        public void InitComponent(WindowBase target)\");\n        scriptText.AppendLine(\"        {\");\n\n        scriptText.AppendLine(\"            //组件事件绑定\");\n        //得到逻辑类 WindowBase 强转为目标派生类\n        scriptText.AppendLine($\"            {name} mWindow = ({name})target;\");\n\n        //生成UI事件绑定代码\n        foreach (var item in objDataList)\n        {\n            string type = item.fieldType;\n            string methodName = item.fieldName;\n            string suffix;\n            if (type.Contains(\"Button\"))\n            {\n                suffix = \"Click\";\n                scriptText.AppendLine($\"            target.AddButtonClickListener({methodName}{type}, mWindow.On{methodName}Button{suffix});\");\n            }\n            if (type.Contains(\"InputField\"))\n            {\n                scriptText.AppendLine($\"            target.AddInputFieldListener({methodName}{type}, mWindow.On{methodName}InputChange, mWindow.On{methodName}InputEnd);\");\n            }\n            if (type.Contains(\"Toggle\"))\n            {\n                suffix = \"Change\";\n                scriptText.AppendLine($\"            target.AddToggleClickListener({methodName}{type}, mWindow.On{methodName}Toggle{suffix});\");\n            }\n        }\n        scriptText.AppendLine(\"        }\");\n        scriptText.AppendLine(\"    }\");\n        if (!string.IsNullOrEmpty(nameSpaceName))\n        {\n            scriptText.AppendLine(\"}\");\n        }\n        return scriptText.ToString();\n    }\n\n    public static EditorObjectData GetEditorObjectData(int instanceID)\n    {\n        foreach (var item in objDataList)\n        {\n            if (item.instanceID == instanceID)\n            {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    /// \u003csummary\u003e\n    /// 编译完成后Unity自动调用的方法\n    /// \u003c/summary\u003e\n    [UnityEditor.Callbacks.DidReloadScripts]    //编译完成后，Unity会自动执行该函数的特性\n    public static void AddComponentToWindow()\n    {\n        //如果当前生成的不是数据脚本的回调，就不处理\n        string className = EditorPrefs.GetString(\"GeneratorClassName\");\n        if (string.IsNullOrEmpty(className))\n        {\n            return;\n        }\n        //通过反射的方式，从程序集中找到这个脚本，把它挂载到当前的物体上\n        //获取所有的程序集，找到CSharp程序集，再获取类所在的程序集路径\n        var assembiles = AppDomain.CurrentDomain.GetAssemblies();\n        var cSharpAssembly = assembiles.First(assembly =\u003e assembly.GetName().Name == \"Assembly-CSharp\");\n        string relClassName = \"ZMUIFrameWork.\" + className;\n        Type type = cSharpAssembly.GetType(relClassName);\n        //若为空，就直接返回\n        if (type == null)\n        {\n            Debug.LogError($\"{relClassName}: 未能在{cSharpAssembly}内找到该类，请检查是否存在该类！\");\n            return;\n        }\n        //获取要挂载的那个物体\n        string windowObjName = className.Replace(\"DataComponent\", \"\");\n        GameObject windowObj = GameObject.Find(windowObjName);\n        if (windowObj == null)\n        {\n            windowObj = GameObject.Find(\"UIRoot/\" + windowObjName);\n            if (windowObj == null)\n            {\n                Debug.LogWarning($\"{className}: 未在场景上找到需要绑定UI控件的Window，绑定操作未完成\");\n                return;\n            }\n        }\n        //先获取现窗口上有没有挂载该数据组件，如果没有挂载再进行挂载\n        Component component = windowObj.GetComponent(type);\n        if (component == null)\n        {\n            component = windowObj.AddComponent(type);\n        }\n\n        //通过反射的方式，遍历数据列表，找到对应的字段并赋值\n        //获取对象数据列表\n        string dataListJson = PlayerPrefs.GetString(GeneratorConfig.OBJDATALIST_KEY);\n        List\u003cEditorObjectData\u003e objDataList = JsonConvert.DeserializeObject\u003cList\u003cEditorObjectData\u003e\u003e(dataListJson);\n        //获取脚本所有字段\n        FieldInfo[] fieldInfoList = type.GetFields();\n        foreach (var fieldInfo in fieldInfoList)\n        {\n            foreach (var objData in objDataList)\n            {\n                if (fieldInfo.Name == objData.fieldName + objData.fieldType)\n                {\n                    //根据InstanceID找到对应的对象\n                    GameObject uiObject = EditorUtility.InstanceIDToObject(objData.instanceID) as GameObject;\n                    if (uiObject == null)\n                    {\n                        Debug.LogError($\"[{objData.fieldType}]{objData.fieldName}: 未能通过生成组件数据脚本时保存的InstanceID找到此UI控件，可能需要重新执行生成组件数据脚本操作！\");\n                        continue;\n                    }\n                    //设置该字段所对应的对象\n                    if (string.Equals(objData.fieldType, \"GameObject\"))\n                    {\n                        fieldInfo.SetValue(component, uiObject);\n                    }\n                    else\n                    {\n                        fieldInfo.SetValue(component, uiObject.GetComponent(objData.fieldType));\n                    }\n                    break;\n                }\n            }\n        }\n        //处理完成后删除标记，防止后续的非生成数据脚本的回调触发执行该函数\n        EditorPrefs.DeleteKey(\"GeneratorClassName\");\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125164113-lwsrdvn",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240125164113-lwsrdvn",
				"updated": "20240125164133"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "四、Window逻辑类的生成"
				}
			]
		},
		{
			"ID": "20240125213908-dfuhy8l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125213908-dfuhy8l",
				"updated": "20240125220246"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Window逻辑类是"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "我们编写UI窗口交互逻辑的脚本，自动化系统会帮我们创建脚本并自动生成模板代码，我们在模板里编写逻辑即可"
				}
			]
		},
		{
			"ID": "20240125214247-cjux7xk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125214247-cjux7xk",
				"updated": "20240125214247"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件数据脚本代码需要生成如下部分："
				}
			]
		},
		{
			"ID": "20240125214247-qqrph85",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240125214247-qqrph85",
				"updated": "20240125214927"
			},
			"Children": [
				{
					"ID": "20240125214247-6ewwm5e",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125214247-6ewwm5e",
						"updated": "20240125214247"
					},
					"Children": [
						{
							"ID": "20240125214247-oj3l1kq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125214247-oj3l1kq",
								"updated": "20240125214247"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "脚本为自动生成的提示，命名空间的引用"
								}
							]
						}
					]
				},
				{
					"ID": "20240125214247-w2nht4o",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125214247-w2nht4o",
						"updated": "20240125214247"
					},
					"Children": [
						{
							"ID": "20240125214247-p84z8wf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125214247-p84z8wf",
								"updated": "20240125214321"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Window逻辑类的声明，继承"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBase"
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						}
					]
				},
				{
					"ID": "20240125214247-2pmwq0h",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125214247-2pmwq0h",
						"updated": "20240125214247"
					},
					"Children": [
						{
							"ID": "20240125214247-t92uiog",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125214247-t92uiog",
								"updated": "20240125214455"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "声明组件查找类/组件数据类的字段，以便调用UI控件，使用组件查找类还是组件数据类由配置文件决定"
								}
							]
						}
					]
				},
				{
					"ID": "20240125214247-cqvfn6v",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125214247-cqvfn6v",
						"updated": "20240125214247"
					},
					"Children": [
						{
							"ID": "20240125214247-utop870",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125214247-utop870",
								"updated": "20240125214638"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "重写"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBase"
								},
								{
									"Type": "NodeText",
									"Data": "​的生命周期函数，在"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "OnAwake"
								},
								{
									"Type": "NodeText",
									"Data": "​内执行部分初始化代码，例如获取组件查找类/组件数据类并执行其初始化方法"
								}
							]
						}
					]
				},
				{
					"ID": "20240125214639-84qrb4k",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125214639-84qrb4k"
					},
					"Children": [
						{
							"ID": "20240125214639-fx4p3gz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125214639-fx4p3gz",
								"updated": "20240125214731"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "预留"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "API Function"
								},
								{
									"Type": "NodeText",
									"Data": "​代码块，用于开发者在其中对外调用接口"
								}
							]
						}
					]
				},
				{
					"ID": "20240125214737-phf1yb0",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240125214737-phf1yb0",
						"updated": "20240125214927"
					},
					"Children": [
						{
							"ID": "20240125214737-lx1bvj1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240125214737-lx1bvj1",
								"updated": "20240125214927"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "获取解析窗口数据，声明所有解析到的UI控件的监听函数，组件查找类/组件数据类会在初始化方法将所有监听函数添加到UI控件里"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240125213948-dkl4j0f",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125213948-dkl4j0f",
				"style": "line-height: 22px;",
				"updated": "20240125215141"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//自动化脚本生成示例\n\n/*-----------------------------------\n *Title: UI自动化组件查找代码工具\n *Author: 铸梦\n *Date:2024/1/23 15:17:22\n *Description: UI 表现层，该层只负责界面的交互，表现相关的更新，不允许编写任何业务逻辑代码！\n *注意，以下文件是自动生成的，再次生成不会覆盖原有的代码，会在原有的代码上新增，可放心使用\n *-----------------------------------*/\nusing UnityEngine.UI;\nusing UnityEngine;\nusing ZMUIFrameWork;\n\npublic class HallWindow : WindowBase\n{\n    public HallWindowDataComponent dataComponent;\n  \n    #region 声明周期函数\n    //调用机制与Mono Awake一致\n    public override void OnAwake()\n    {\n        dataComponent = gameObject.GetComponent\u003cHallWindowDataComponent\u003e();\n        dataComponent.InitComponent(this);\n        base.OnAwake();\n    }\n    //物体显示时执行\n    public override void OnShow()\n    {\n        base.OnShow();\n    }\n    //物体隐藏时执行\n    public override void OnHide()\n    {\n        base.OnHide();\n    }\n    //物体销毁时时执行\n    public override void OnDestroy()\n    {\n        base.OnDestroy();\n    }\n    #endregion\n  \n    #region API Function\n  \n    #endregion\n  \n    #region UI组件事件\n    public void OnChatButtonClick()\n    {\n\n    }\n    public void OnSettingButtonClick()\n    {\n\n    }\n    public void OnUserInfoButtonClick()\n    {\n\n    }\n    public void OnFriendButtonClick()\n    {\n\n    }\n    #endregion\n  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125164134-kby2py6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125164134-kby2py6",
				"updated": "20240125221614"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组件数据查找脚本的生成主要在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorWindowTool"
				},
				{
					"Type": "NodeText",
					"Data": "​内实现，它继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Editor"
				},
				{
					"Type": "NodeText",
					"Data": "​\n它需要"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "为右键菜单提供“生成Window逻辑类”选项（快捷键Shift+V）"
				},
				{
					"Type": "NodeText",
					"Data": "，因此需要为一个函数添加"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "[MenuItem]"
				},
				{
					"Type": "NodeText",
					"Data": "​特性作为入口函数（"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "#V"
				},
				{
					"Type": "NodeText",
					"Data": "​是指定快捷键）"
				}
			]
		},
		{
			"ID": "20240125234107-40j9m19",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125234107-40j9m19",
				"updated": "20240125234107"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 251px;",
						"style": "width: 241px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240125234107-i24qsae.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 241px;\" parent-style=\"width: 251px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240125234014-n9mkxao",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125234014-n9mkxao",
				"updated": "20240125234014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对窗口对象右键选择该选项后对选中的窗口对象生成对应的类脚本，主函数执行步骤如下："
				}
			]
		},
		{
			"ID": "20240125215350-h0g9y6j",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125215350-h0g9y6j",
				"style": "line-height: 22px;",
				"updated": "20240125231212"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "[MenuItem(\"GameObject/生成Window逻辑脚本(Shift+V) #V\", false, 0)]\nprivate static void CreateFindComponentScripts()\n{\n    1.获取在编辑器里选中的内容，判断是否为游戏对象，不是则报错并直接返回空\n\t2.设置脚本的生成路径\n\t3.生成对应脚本字符串，期间会获取之前解析的数据，制作方法字符串字典\n\t4.将脚本字符串与生成脚本路径和方法字典传入预览窗口显示\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125215307-wcn8cq9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125215307-wcn8cq9",
				"style": "line-height: 22px;",
				"updated": "20240125215905"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using Newtonsoft.Json;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing UnityEditor;\nusing UnityEngine;\n\npublic class GeneratorWindowTool : Editor\n{\n    static Dictionary\u003cstring, string\u003e methodDic = new Dictionary\u003cstring, string\u003e();\n\n    [MenuItem(\"GameObject/生成Window逻辑脚本(Shift+V) #V\", false, 0)]\n    private static void CreateFindComponentScripts()\n    {\n        //获取在编辑器里选中的内容\n        GameObject obj = Selection.objects.First() as GameObject;\n        if (obj == null)\n        {\n            Debug.LogError(\"需要选择GameObject\");\n            return;\n        }\n\n        //设置脚本的生成路径\n        if (!Directory.Exists(GeneratorConfig.FindComponentGeneratorPath))\n        {\n            Directory.CreateDirectory(GeneratorConfig.FindComponentGeneratorPath);\n        }\n\n        //生成C#脚本文件\n        string csScriptText = CreateWindowCS(obj.name);\n        string csPath = GeneratorConfig.WindowGeneratorPath + \"/\" + obj.name + \".cs\";\n        UIWindowEditor.ShowWindow(csScriptText, csPath, methodDic);\n    }\n\n    // 生成Window脚本\n    public static string CreateWindowCS(string name)...\n\n    // 生成UI事件方法字典\n    public static void CreateMethod(StringBuilder scriptText, ref Dictionary\u003cstring, string\u003e methodDic, string methodName, string param = \"\")...\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125215927-r8g8pmm",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125215927-r8g8pmm",
				"updated": "20240125221648"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "生成脚本字符串"
				}
			]
		},
		{
			"ID": "20240125223349-b41t178",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125223349-b41t178",
				"updated": "20240125223409"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "按照上面给出的组件查找脚本文本格式，从PlayerPrefs读取持久化的解析结果，生成脚本字符串，之后即可将字符串传入到预览窗口内供预览"
				}
			]
		},
		{
			"ID": "20240125221649-pi6e8wo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125221649-pi6e8wo",
				"updated": "20240126002144"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "值得一提的是，与组件数据脚本/组件查找脚本的生成不同，这里"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "生成的脚本字符串有多个"
				},
				{
					"Type": "NodeText",
					"Data": "\n其中一个还是按照原本要求的格式生成的脚本字符串，包含所有的内容\n而根据解析结果生成的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "监听函数的声明语句还会生成在另外的多个字符串内，一个监听函数生成一个字符串"
				}
			]
		},
		{
			"ID": "20240125230810-69d3q4w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125230810-69d3q4w",
				"updated": "20240125231117"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "监听函数声明字符串会以方法名("
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "\u0026quot;On+控件名+后缀（如Click）\u0026quot;"
				},
				{
					"Type": "NodeText",
					"Data": "​)为键，存入到字典内，随固定内容字符串一起传入到预览窗口，等待后面的处理"
				}
			]
		},
		{
			"ID": "20240125231118-usrcxnp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125231118-usrcxnp",
				"updated": "20240126002155"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这样做是为了达到UI窗口添加组件而重新生成Window逻辑类脚本时，不覆盖原有开发者编写的语句和代码递增生成的效果\n原理在后面的预览窗口部分解释"
				}
			]
		},
		{
			"ID": "20240125231421-d57iamk",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125231421-d57iamk",
				"style": "line-height: 22px;",
				"updated": "20240125231449"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/// \u003csummary\u003e\n/// 生成Window脚本\n/// \u003c/summary\u003e\n/// \u003cparam name=\"name\"\u003e窗口名\u003c/param\u003e\n/// \u003creturns\u003e脚本字符串\u003c/returns\u003e\npublic static string CreateWindowCS(string name)\n{\n    //反序列化并读取字段名称\n    string dataListJson = PlayerPrefs.GetString(GeneratorConfig.OBJDATALIST_KEY);\n    List\u003cEditorObjectData\u003e objDataList = JsonConvert.DeserializeObject\u003cList\u003cEditorObjectData\u003e\u003e(dataListJson);\n    methodDic.Clear();\n    StringBuilder scriptText = new StringBuilder();\n\n    //添加引用\n    scriptText.AppendLine(\"/*-----------------------------------\");\n    scriptText.AppendLine(\" *Title: UI自动化组件查找代码工具\");\n    scriptText.AppendLine(\" *Author: 铸梦\");\n    scriptText.AppendLine(\" *Date:\" + System.DateTime.Now);\n    scriptText.AppendLine(\" *Description: UI 表现层，该层只负责界面的交互，表现相关的更新，不允许编写任何业务逻辑代码！\");\n    scriptText.AppendLine(\" *注意，以下文件是自动生成的，再次生成不会覆盖原有的代码，会在原有的代码上新增，可放心使用\");\n    scriptText.AppendLine(\" *-----------------------------------*/\");\n    scriptText.AppendLine(\"using UnityEngine.UI;\");\n    scriptText.AppendLine(\"using UnityEngine;\");\n    scriptText.AppendLine(\"using ZMUIFrameWork;\");\n    scriptText.AppendLine();\n\n    //生成类名\n    scriptText.AppendLine($\"public class {name} : WindowBase\");\n    scriptText.AppendLine(\"{\");\n\n    //根据生成组件类型的不同生成不同的字段\n    if (GeneratorConfig.GeneratorType == GeneratorType.Bind)\n    {\n        scriptText.AppendLine($\"    public {name}DataComponent dataComponent;\");\n    }\n    else\n    {\n        scriptText.AppendLine($\"    public {name}UIComponent uiComponent = new {name}UIComponent();\");\n    }\n\n    //生成声明周期函数\n    //Awake\n    scriptText.AppendLine(\"    \");\n    scriptText.AppendLine(\"    #region 声明周期函数\");\n    scriptText.AppendLine(\"    //调用机制与Mono Awake一致\");\n    scriptText.AppendLine(\"    public override void OnAwake()\");\n    scriptText.AppendLine(\"    {\");\n    if (GeneratorConfig.GeneratorType == GeneratorType.Bind)\n    {\n        scriptText.AppendLine($\"        dataComponent = gameObject.GetComponent\u003c{name}DataComponent\u003e();\");\n        scriptText.AppendLine(\"        dataComponent.InitComponent(this);\");\n    }\n    else\n        scriptText.AppendLine(\"        uiComponent.InitComponent(this);\");\n    scriptText.AppendLine(\"        base.OnAwake();\");\n    scriptText.AppendLine(\"    }\");\n    //OnShow\n    scriptText.AppendLine(\"    //物体显示时执行\");\n    scriptText.AppendLine(\"    public override void OnShow()\");\n    scriptText.AppendLine(\"    {\");\n    scriptText.AppendLine(\"        base.OnShow();\");\n    scriptText.AppendLine(\"    }\");\n    //OnHide\n    scriptText.AppendLine(\"    //物体隐藏时执行\");\n    scriptText.AppendLine(\"    public override void OnHide()\");\n    scriptText.AppendLine(\"    {\");\n    scriptText.AppendLine(\"        base.OnHide();\");\n    scriptText.AppendLine(\"    }\");\n    //OnDestroy\n    scriptText.AppendLine(\"    //物体销毁时时执行\");\n    scriptText.AppendLine(\"    public override void OnDestroy()\");\n    scriptText.AppendLine(\"    {\");\n    scriptText.AppendLine(\"        base.OnDestroy();\");\n    scriptText.AppendLine(\"    }\");\n    scriptText.AppendLine(\"    #endregion\");\n    scriptText.AppendLine(\"    \");\n\n    //API Function\n    scriptText.AppendLine(\"    #region API Function\");\n    scriptText.AppendLine(\"    \");\n    scriptText.AppendLine(\"    #endregion\");\n    scriptText.AppendLine(\"    \");\n\n    //UI组件事件生成\n    scriptText.AppendLine(\"    #region UI组件事件\");\n    foreach (var item in objDataList)\n    {\n        string type = item.fieldType;\n        string methodName = \"On\" + item.fieldName;\n        string suffix;\n        if (type.Contains(\"Button\"))\n        {\n            suffix = \"ButtonClick\";\n            CreateMethod(scriptText, ref methodDic, methodName + suffix);\n        }\n        else if (type.Contains(\"InputField\"))\n        {\n            suffix = \"InputChange\";\n            CreateMethod(scriptText, ref methodDic, methodName + suffix, \"string text\");\n            suffix = \"InputEnd\";\n            CreateMethod(scriptText, ref methodDic, methodName + suffix, \"string text\");\n        }\n        else if (type.Contains(\"Toggle\"))\n        {\n            suffix = \"ToggleChange\";\n            CreateMethod(scriptText, ref methodDic, methodName + suffix, \"bool state, Toggle toggle\");\n        }\n    }\n    scriptText.AppendLine(\"    #endregion\");\n    scriptText.AppendLine(\"    \");\n\n    scriptText.AppendLine(\"}\");\n    return scriptText.ToString();\n}\n\n/// \u003csummary\u003e\n/// 生成UI事件方法\n/// \u003c/summary\u003e\n/// \u003cparam name=\"scriptText\"\u003e\u003c/param\u003e\n/// \u003cparam name=\"methodDic\"\u003e\u003c/param\u003e\n/// \u003cparam name=\"methodName\"\u003e\u003c/param\u003e\n/// \u003cparam name=\"param\"\u003e\u003c/param\u003e\npublic static void CreateMethod(StringBuilder scriptText, ref Dictionary\u003cstring, string\u003e methodDic, string methodName, string par\n{\n    //声明UI组件事件\n    scriptText.AppendLine($\"    public void {methodName}({param})\");\n    scriptText.AppendLine(\"    {\");\n    //如果是关闭按钮，则自动添加一个HideWindow();语句\n    if (methodName == \"OnCloseButtonClick\")\n    {\n        scriptText.AppendLine(\"        HideWindow();\");\n    }\n    else\n    {\n        scriptText.AppendLine();\n    }\n    scriptText.AppendLine(\"    }\");\n    //存储UI组件事件 提供给后续新增代码使用\n    StringBuilder builder = new StringBuilder();\n    builder.AppendLine($\"    public void {methodName}({param})\");\n    builder.AppendLine(\"    {\");\n    builder.AppendLine(\"    \");\n    builder.AppendLine(\"    }\");\n    methodDic.Add(methodName, builder.ToString());\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125231626-zae5aeq",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240125231626-zae5aeq",
				"updated": "20240125231702"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "五、代码预览窗口"
				}
			]
		},
		{
			"ID": "20240125231705-x6pcj2p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125231705-x6pcj2p",
				"updated": "20240125231952"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在生成组件查找脚本/组件数据脚本或Window逻辑类脚本字符串后\n我们可以暂时先将文本字符串输出到一个预览窗口供我们检查，确认文本内容无误后将文本生成脚本文件存储到工程内"
				}
			]
		},
		{
			"ID": "20240125235749-kc6i72h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125235749-kc6i72h",
				"updated": "20240125235749"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 574px;",
						"style": "width: 564px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240125233127-m9bsufs.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 564px;\" parent-style=\"width: 574px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240125232428-5dqhlv6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125232428-5dqhlv6",
				"updated": "20240125231702"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "代码预览窗口主要在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIWindowEditor"
				},
				{
					"Type": "NodeText",
					"Data": "​内实现，它继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "EditorWindow"
				},
				{
					"Type": "NodeText",
					"Data": "​（因为需要创建编辑器窗口）\n每当"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorFindComponentTool"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorBindComponentTool"
				},
				{
					"Type": "NodeText",
					"Data": "​及"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorWindowTool"
				},
				{
					"Type": "NodeText",
					"Data": "​生成字符串后\n都会调用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIWindowEditor"
				},
				{
					"Type": "NodeText",
					"Data": "​的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ShowWindow"
				},
				{
					"Type": "NodeText",
					"Data": "​方法，显示代码预览窗口，点击确认后，才会将文本写入文件并存储"
				}
			]
		},
		{
			"ID": "20240125234215-cruwhm0",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240125234215-cruwhm0",
				"updated": "20240125231702"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240125234221-5umvs4z",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240125234221-5umvs4z",
						"updated": "20240125234224"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "EditorWindow 类是用于创建独立窗口的基类"
						}
					]
				}
			]
		},
		{
			"ID": "20240125232151-r00qwji",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125232151-r00qwji",
				"updated": "20240125231702"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "之前"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorWindowTool"
				},
				{
					"Type": "NodeText",
					"Data": "​生成的多个字符串也要在这里进行最终处理，不覆盖原有开发者编写的语句和代码递增生成的效果也要在这里实现"
				}
			]
		},
		{
			"ID": "20240125233702-ipdiuyq",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125233702-ipdiuyq",
				"updated": "20240125231702"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.Window逻辑类递增代码处理"
				}
			]
		},
		{
			"ID": "20240125233909-29zn4ar",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125233909-29zn4ar",
				"updated": "20240126001219"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorFindComponentTool"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorBindComponentTool"
				},
				{
					"Type": "NodeText",
					"Data": "​及"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorWindowTool"
				},
				{
					"Type": "NodeText",
					"Data": "​生成字符串后，\n需要调用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ShowWindow"
				},
				{
					"Type": "NodeText",
					"Data": "​方法传入字符串和文件路径，以便窗口输出文本与路径"
				}
			]
		},
		{
			"ID": "20240126001219-xy7f17q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240126001219-xy7f17q",
				"updated": "20240126001933"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorWindowTool"
				},
				{
					"Type": "NodeText",
					"Data": "​会传入第三个参数"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "insertDic"
				},
				{
					"Type": "NodeText",
					"Data": "​，传入的是之前生成Window逻辑类生成出来的监听函数字符串\n这意味着需要确认是否已存在文件，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "如果已经存在Window逻辑类脚本，那么只要将原来脚本中不存在的监听方法插入进去即可"
				},
				{
					"Type": "NodeText",
					"Data": "\n若不存在文件或者是"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorFindComponentTool"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GeneratorBindComponentTool"
				},
				{
					"Type": "NodeText",
					"Data": "​传入的字符串，就把参数"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "content"
				},
				{
					"Type": "NodeText",
					"Data": "​的字符串输出出去"
				}
			]
		},
		{
			"ID": "20240126000034-bm8usgf",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240126000034-bm8usgf",
				"style": "line-height: 22px;",
				"updated": "20240126001154"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public static void ShowWindow(string content, string filePath, Dictionary\u003cstring, string\u003e insertDic = null)\n{\n\t在指定位置创建窗口，窗口内容由OnGUI决定\n\t窗口显示的字符串 = content\n\t窗口显示的文件路径 = filePath\n\tif filePath存在这个脚本文件 \u0026\u0026 insertDic != null\t\t//意味着传入的是Window逻辑类字符串，需要做进一步处理\n\t\t通过filePath获取原始代码\n\t\tfor 遍历insertDic的方法名与监听函数字符串\n\t\t\tif 原始代码不存在遍历到的insertDic的方法名\n\t\t\t\t获取原始代码中\"UI组件事件\"与第一个\"public\"之间的索引\n\t\t\t\t在索引处插入新增的监听函数字符串\n\t显示窗口\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125234342-h73j7bt",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125234342-h73j7bt",
				"style": "line-height: 22px;",
				"updated": "20240126000704"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/// \u003csummary\u003e\n/// 显示代码预览界面\n/// \u003c/summary\u003e\n/// \u003cparam name=\"content\"\u003e将要生成的代码内容\u003c/param\u003e\n/// \u003cparam name=\"filePath\"\u003e脚本文件生成路径\u003c/param\u003e\n/// \u003cparam name=\"insertDic\"\u003e插入方法代码字典\u003c/param\u003e\npublic static void ShowWindow(string content, string filePath, Dictionary\u003cstring, string\u003e insertDic = null)\n{\n    //创建代码展示窗口\n    UIWindowEditor window = (UIWindowEditor)GetWindowWithRect(typeof(UIWindowEditor), new Rect(100, 50, 800, 700), true, \"Window生成预览界面\")\n    window.scriptContent = content;\n    window.filePath = filePath;\n    //处理代码新增代码\n    if (File.Exists(filePath) \u0026\u0026 insertDic != null)\n    {\n        //获取原始代码\n        string originScript = File.ReadAllText(filePath);\n        foreach (var item in insertDic)\n        {\n            //如果老代码中没有这个代码就进行插入操作\n            if (!originScript.Contains(item.Key))\n            {\n                int index = window.GetInsertIndex(originScript);\n                originScript = window.scriptContent = originScript.Insert(index, \"\\r\\n\" + item.Value + \"    \");\n            }\n        }\n    }\n    //显示窗口\n    window.Show();\n}\n\n/// \u003csummary\u003e\n/// 获取插入代码的下标\n/// \u003c/summary\u003e\n/// \u003cparam name=\"content\"\u003e代码字符串\u003c/param\u003e\n/// \u003creturns\u003e返回UI事件组件下面的第一个public所在的位置，若不存在返回-1\u003c/returns\u003e\npublic int GetInsertIndex(string content)\n{\n    //找到UI事件组件下面的第一个public所在的位置，进行代码插入\n    Regex regex = new Regex(\"UI组件事件\");      //正则表达式\n    Match match = regex.Match(content);         //匹配结果\n\n    Regex regex1 = new Regex(\"public\");\n    MatchCollection matchCollection = regex1.Matches(content);  //匹配所有public的字符串\n\n    for (int i = 0; i \u003c matchCollection.Count; i++)\n    {\n        //当public的下标正好大于UI组件事件的下标，即可插入代码\n        if (matchCollection[i].Index \u003e match.Index)\n        {\n            return matchCollection[i].Index;\n        }\n    }\n    return -1;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240126001237-gx5vb9t",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240126001237-gx5vb9t",
				"style": "background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);",
				"updated": "20240126001237"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240126001237-polqrai",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240126001237-polqrai",
						"updated": "20240126001237"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "需要注意的是，如果窗口的UI控件没有增加（不变或者删去某些UI控件），且生成过Window逻辑类并在里边编写了逻辑\n则"
						},
						{
							"Type": "NodeTextMark",
							"Properties": {
								"style": "background-color: var(--b3-card-error-background); color: var(--b3-card-error-color);"
							},
							"TextMarkType": "strong text",
							"TextMarkTextContent": "再次生成Window逻辑类将会覆盖原有代码"
						},
						{
							"Type": "NodeKramdownSpanIAL",
							"Data": "{: style=\"background-color: var(--b3-card-error-background); color: var(--b3-card-error-color);\"}"
						},
						{
							"Type": "NodeText",
							"Data": "，因此如果不修改框架代码，则UI控件不增加时不要随便生成Window逻辑类，以免代码火葬场~"
						}
					]
				},
				{
					"ID": "20240126001237-e6lc68v",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240126001237-e6lc68v",
						"updated": "20240126001237"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "可以这样修改防止上述情况导致的覆盖"
						}
					]
				},
				{
					"ID": "20240126001237-pwj90xl",
					"Type": "NodeCodeBlock",
					"IsFencedCodeBlock": true,
					"Properties": {
						"id": "20240126001237-pwj90xl",
						"style": "line-height: 22px;",
						"updated": "20240126001237"
					},
					"Children": [
						{
							"Type": "NodeCodeBlockFenceOpenMarker",
							"Data": "```"
						},
						{
							"Type": "NodeCodeBlockFenceInfoMarker",
							"CodeBlockInfo": "YyM="
						},
						{
							"Type": "NodeCodeBlockCode",
							"Data": "public static void ShowWindow(string content, string filePath, Dictionary\u003cstring, string\u003e insertDic = null)\n{\n    //创建代码展示窗口\n    UIWindowEditor window = (UIWindowEditor)GetWindowWithRect(typeof(UIWindowEditor), new Rect(100, 50, 800, 700), true, \"Window生成预览界面\");\n    window.scriptContent = content;\n    window.filePath = filePath;\n    //处理代码新增代码\n    if (File.Exists(filePath) \u0026\u0026 insertDic != null)\n    {\n        //获取原始代码\n        string originScript = File.ReadAllText(filePath);\n        foreach (var item in insertDic)\n        {\n            //如果老代码中没有这个代码就进行插入操作\n            if (!originScript.Contains(item.Key))\n            {\n                int index = window.GetInsertIndex(originScript);\n                originScript = window.scriptContent = originScript.Insert(index, \"\\r\\n\" + item.Value + \"    \");\n            }\n        }\n        window.scriptContent = originScript;\t\t\t//不管循环中是否执行插入操作，先让输出的字符串等于原始代码，防止覆盖\n    }\n    //显示窗口\n    window.Show();\n}\n"
						},
						{
							"Type": "NodeCodeBlockFenceCloseMarker",
							"Data": "```"
						}
					]
				}
			]
		},
		{
			"ID": "20240125232225-u8u2uck",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125232225-u8u2uck",
				"updated": "20240125231702"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.窗口绘制与确认生成按钮逻辑"
				}
			]
		},
		{
			"ID": "20240125232954-q99juq7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125232954-q99juq7",
				"updated": "20240125233204"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "预览窗口很简单，只有三个部分：代码预览框，文件路径框，确认按钮。窗口绘制语句主要是在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "OnGUI"
				},
				{
					"Type": "NodeText",
					"Data": "​内编写​​"
				}
			]
		},
		{
			"ID": "20240125233105-f8jicvb",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125233105-f8jicvb",
				"style": "line-height: 22px;",
				"updated": "20240125231702"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//绘制窗口代码\npublic void OnGUI()\n{\n    //绘制ScrollView\n    scroll = EditorGUILayout.BeginScrollView(scroll, GUILayout.Height(600), GUILayout.Width(800));\n    EditorGUILayout.TextArea(scriptContent);\n    EditorGUILayout.EndScrollView();\n    EditorGUILayout.Space();\n    //绘制脚本生成路径\n    EditorGUILayout.BeginHorizontal();\n    EditorGUILayout.TextArea(\"脚本生成路径：\" + filePath);\n    EditorGUILayout.EndHorizontal();\n    EditorGUILayout.Space();\n    //绘制按钮\n    EditorGUILayout.BeginHorizontal();\n\t//当按下按钮时执行生成文件逻辑\n    if (GUILayout.Button(\"生成脚本\", GUILayout.Height(30)))\n    {\n        //按钮事件\n        ButtonClick();\n    }\n    EditorGUILayout.EndHorizontal();\n}\n\npublic void ButtonClick()...\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125233219-armlj7g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125233219-armlj7g",
				"updated": "20240125231702"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "确认按钮按下后，需要将生成工具类传入的字符串通过文件流写入到指定路径下的文件内"
				}
			]
		},
		{
			"ID": "20240125233637-zu1a8mc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125233637-zu1a8mc",
				"style": "line-height: 22px;",
				"updated": "20240125231702"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public void ButtonClick()\n{\n    if (File.Exists(filePath))\n    {\n        File.Delete(filePath);\t\t\t\t\t\t\t//如果已存在文件，将原文件删除\n    }\n    StreamWriter writer = File.CreateText(filePath);\t//开启文件流\n    writer.Write(scriptContent);\t\t\t\t\t\t//通过文件流将文本写入到文件内\n    writer.Flush();\n    writer.Close();\t\t\t\t\t\t\t\t\t\t//关闭文件流\n    AssetDatabase.Refresh();\t\t\t\t\t\t\t//刷新工程窗口\n    if (EditorUtility.DisplayDialog(\"自动化生成工具\", \"生成脚本成功！\", \"确认\"))\n    {\n\t\t//当按下弹出的提示窗口的按钮时，关闭窗口\n        Close();\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240126001950-lhl8fxb",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240126001950-lhl8fxb",
				"updated": "20240126002014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "UIWindowEditor代码"
				}
			]
		},
		{
			"ID": "20240126002014-helgm26",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240126002014-helgm26",
				"style": "line-height: 22px;",
				"updated": "20240126002512"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using System.Collections.Generic;\nusing System.IO;\nusing System.Text.RegularExpressions;\nusing UnityEditor;\nusing UnityEngine;\n\npublic class UIWindowEditor : EditorWindow\n{\n    private string scriptContent;\n    private string filePath;\n    private Vector2 scroll = new Vector2();\n\n    /// \u003csummary\u003e\n    /// 显示代码预览界面\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"content\"\u003e将要生成的代码内容\u003c/param\u003e\n    /// \u003cparam name=\"filePath\"\u003e脚本文件生成路径\u003c/param\u003e\n    /// \u003cparam name=\"insertDic\"\u003e插入方法代码字典\u003c/param\u003e\n    public static void ShowWindow(string content, string filePath, Dictionary\u003cstring, string\u003e insertDic = null)\n    {\n        //创建代码展示窗口\n        UIWindowEditor window = (UIWindowEditor)GetWindowWithRect(typeof(UIWindowEditor), new Rect(100, 50, 800, 700), true, \"Window生成预览界面\");\n        window.scriptContent = content;\n        window.filePath = filePath;\n        //处理代码新增代码\n        if (File.Exists(filePath) \u0026\u0026 insertDic != null)\n        {\n            //获取原始代码\n            string originScript = File.ReadAllText(filePath);\n            foreach (var item in insertDic)\n            {\n                //如果老代码中没有这个代码就进行插入操作\n                if (!originScript.Contains(item.Key))\n                {\n                    int index = window.GetInsertIndex(originScript);\n                    originScript = window.scriptContent = originScript.Insert(index, \"\\r\\n\" + item.Value + \"    \");\n                }\n            }\n            window.scriptContent = originScript;\n        }\n        //显示窗口\n        window.Show();\n    }\n\n    /// \u003csummary\u003e\n    /// 获取插入代码的下标\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"content\"\u003e代码字符串\u003c/param\u003e\n    /// \u003creturns\u003e返回UI事件组件下面的第一个public所在的位置，若不存在返回-1\u003c/returns\u003e\n    public int GetInsertIndex(string content)\n    {\n        //找到UI事件组件下面的第一个public所在的位置，进行代码插入\n        Regex regex = new Regex(\"UI组件事件\");      //正则表达式\n        Match match = regex.Match(content);         //匹配结果\n\n        Regex regex1 = new Regex(\"public\");\n        MatchCollection matchCollection = regex1.Matches(content);  //匹配所有public的字符串\n\n        for (int i = 0; i \u003c matchCollection.Count; i++)\n        {\n            //当public的下标正好大于UI组件事件的下标，即可插入代码\n            if (matchCollection[i].Index \u003e match.Index)\n            {\n                return matchCollection[i].Index;\n            }\n        }\n        return -1;\n    }\n\n    //绘制窗口代码\n    public void OnGUI()\n    {\n        //绘制ScrollView\n        scroll = EditorGUILayout.BeginScrollView(scroll, GUILayout.Height(600), GUILayout.Width(800));\n        EditorGUILayout.TextArea(scriptContent);\n        EditorGUILayout.EndScrollView();\n        EditorGUILayout.Space();\n        //绘制脚本生成路径\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.TextArea(\"脚本生成路径：\" + filePath);\n        EditorGUILayout.EndHorizontal();\n        EditorGUILayout.Space();\n        //绘制按钮\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(\"生成脚本\", GUILayout.Height(30)))\n        {\n            //按钮事件\n            ButtonClick();\n        }\n        EditorGUILayout.EndHorizontal();\n    }\n\n    public void ButtonClick()\n    {\n        if (File.Exists(filePath))\n        {\n            File.Delete(filePath);\n        }\n        StreamWriter writer = File.CreateText(filePath);\n        writer.Write(scriptContent);\n        writer.Flush();\n        writer.Close();\n        AssetDatabase.Refresh();\n        if (EditorUtility.DisplayDialog(\"自动化生成工具\", \"生成脚本成功！\", \"确认\"))\n        {\n            Close();\n        }\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240124230142-7j7rzjg",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240124230142-7j7rzjg",
				"updated": "20240125231644"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "六、动态加载不同路径下的UI预设体"
				}
			]
		},
		{
			"ID": "20240124230142-euzzibe",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124230142-euzzibe",
				"updated": "20240125231644"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在实际开发中，我们往往会将多个UI预设体文件存储在不同的文件夹内，而我们的加载方法要求只通过窗口名就可以加载预设体\n因此"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "我们需要一个动态计算预设体文件路径的手段，事先将不同预设体的文件路径计算出来，写入配置文件"
				},
				{
					"Type": "NodeText",
					"Data": "\n这样，加载方法就可以根据窗口名，通过配置文件获取文件路径，以加载不同文件夹下的UI预设体"
				}
			]
		},
		{
			"ID": "20240124230142-xx85a7g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124230142-xx85a7g",
				"updated": "20240125231644"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里"
				},
				{
					"Type": "NodeText",
					"Data": "使用继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ScriptableObject"
				},
				{
					"Type": "NodeText",
					"Data": "​​的脚本配置文件，实现思路是"
				}
			]
		},
		{
			"ID": "20240124230142-d519jme",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240124230142-d519jme",
				"updated": "20240126002636"
			},
			"Children": [
				{
					"ID": "20240124230142-qf48zmr",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240124230142-qf48zmr",
						"updated": "20240124230142"
					},
					"Children": [
						{
							"ID": "20240124230142-ijrjy40",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124230142-ijrjy40",
								"updated": "20240126003515"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在脚本内声明"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "windowRootArr"
								},
								{
									"Type": "NodeText",
									"Data": "​，写好Resources文件夹下哪些是用来存放窗口预制体的文件夹的路径"
								}
							]
						}
					]
				},
				{
					"ID": "20240126003336-a15silf",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240126003336-a15silf"
					},
					"Children": [
						{
							"ID": "20240126003336-07lfhlx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240126003336-07lfhlx",
								"updated": "20240126003411"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "声明"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowData"
								},
								{
									"Type": "NodeText",
									"Data": "​类，包括窗口名和窗口预制体路径"
								}
							]
						}
					]
				},
				{
					"ID": "20240124230142-zo21pem",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20240124230142-zo21pem",
						"updated": "20240124230142"
					},
					"Children": [
						{
							"ID": "20240124230142-kbgex6l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124230142-kbgex6l",
								"updated": "20240126003628"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在脚本内声明"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowData"
								},
								{
									"Type": "NodeText",
									"Data": "​类的列表"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "windowDataList"
								},
								{
									"Type": "NodeText",
									"Data": "​，让窗口预制体路径可以通过窗口名获取"
								}
							]
						}
					]
				},
				{
					"ID": "20240126003628-m4u9mdz",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20240126003628-m4u9mdz"
					},
					"Children": [
						{
							"ID": "20240126003628-56l2khr",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240126003628-56l2khr",
								"updated": "20240126003913"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "声明"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "GetWindowPath"
								},
								{
									"Type": "NodeText",
									"Data": "​方法，让"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UIMoudle"
								},
								{
									"Type": "NodeText",
									"Data": "​的加载方法可以通过该方法获取窗口路径"
								}
							]
						}
					]
				},
				{
					"ID": "20240126002607-b6l6nje",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20240126002607-b6l6nje",
						"updated": "20240126002636"
					},
					"Children": [
						{
							"ID": "20240126002607-adjuylz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240126002607-adjuylz",
								"updated": "20240126003905"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "声明"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "GeneratorWindowConfig"
								},
								{
									"Type": "NodeText",
									"Data": "​方法，发现"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "windowRootArr"
								},
								{
									"Type": "NodeText",
									"Data": "​中的文件夹下的预制体数量发生改变时就查找所有UI预制体加载路径"
								}
							]
						}
					]
				},
				{
					"ID": "20240126003034-9hmczlf",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ni4=",
						"Num": 6
					},
					"Properties": {
						"id": "20240126003034-9hmczlf"
					},
					"Children": [
						{
							"ID": "20240126003034-fe292w2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240126003034-fe292w2",
								"updated": "20240126004110"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "查找所有UI预制体加载路径是通过将"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "windowRootArr"
								},
								{
									"Type": "NodeText",
									"Data": "​中的所有文件夹的.prefab文件的路径都记载下来存储到"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "windowDataList"
								},
								{
									"Type": "NodeText",
									"Data": "​内"
								}
							]
						}
					]
				},
				{
					"ID": "20240126002339-74ro4f1",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ny4=",
						"Num": 7
					},
					"Properties": {
						"id": "20240126002339-74ro4f1"
					},
					"Children": [
						{
							"ID": "20240126002339-0c16km3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240126002339-0c16km3",
								"updated": "20240126003801"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在编辑器环境下，让"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UIMoudle"
								},
								{
									"Type": "NodeText",
									"Data": "​每次执行初始化方法时就执行"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "GeneratorWindowConfig"
								},
								{
									"Type": "NodeText",
									"Data": "​方法，以确保配置文件的路径是正确的"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240126004202-cishha4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240126004202-cishha4",
				"updated": "20240126004339"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIModule"
				},
				{
					"Type": "NodeText",
					"Data": "​下调用配置文件的内容"
				}
			]
		},
		{
			"ID": "20240126004214-q4zmfyc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240126004214-q4zmfyc",
				"style": "line-height: 22px;",
				"updated": "20240126004317"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//UIModule\n\n//初始化方法 \npublic void Initialize()\n{\n    //获取场景上的UI摄像机和UI根节点\n    mUICamera = GameObject.Find(\"UICamera\").GetComponent\u003cCamera\u003e();\n    mUIRoot = GameObject.Find(\"UIRoot\").transform;\n    mWindowConfig = Resources.Load\u003cWindowConfig\u003e(\"WindowConfig\");\n    //打包出去后不会触发调用\n#if UNITY_EDITOR\n    mWindowConfig.GeneratorWindowConfig();\n#endif\n}\n\n\n//TODO... 临时资源加载，这里仅仅是因为教程方便而使用Resources加载，如有自己的资源加载框架，或后续学习使用加载框架，此处代码将会修改！\npublic GameObject TempLoadWindow(string windowName)\n{\n    GameObject window = GameObject.Instantiate\u003cGameObject\u003e(Resources.Load\u003cGameObject\u003e(mWindowConfig.GetWindowPath(windowName)), mUIRoot);\n    //window.transform.SetParent(mUIRoot);\n    window.transform.localScale = Vector3.one;\n    window.transform.localPosition = Vector3.zero;\n    window.transform.rotation = Quaternion.identity;\n    window.name = windowName;\n    return window;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240126004320-hwokpk3",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240126004320-hwokpk3",
				"updated": "20240126004346"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "WindowConfig代码"
				}
			]
		},
		{
			"ID": "20240126002228-55zo6dx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240126002228-55zo6dx",
				"style": "line-height: 22px;",
				"updated": "20240126004346"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEngine;\n\n[System.Serializable]\npublic class WindowData\n{\n    public string name;\n    public string path;\n}\n\n[CreateAssetMenu(fileName = \"WindowConfig\", menuName = \"WindowConfig\", order = 0)]\npublic class WindowConfig : ScriptableObject\n{\n\t//确认号\n    private string[] windowRootArr = new string[] { \"Game\", \"Hall\", \"Window\" } ;\n    public List\u003cWindowData\u003e windowDataList = new List\u003cWindowData\u003e();\n\n\t//生成窗口预制体路径配置文件方法\n    public void GeneratorWindowConfig()\n    {\n        //检测预制体有没有新增，如果没有就不需要生成配置\n        int count = 0;\n        foreach (var item in windowRootArr)\n        {\n            string[] filePathArr = Directory.GetFiles(Application.dataPath + \"/ZMUIFrameWork/Resources/\" + item, \"*.prefab\", SearchOption.AllDirectories);\n            foreach (string path in filePathArr)\n            {\n                //过滤.meta文件\n                if (path.EndsWith(\".meta\"))\n                {\n                    continue;\n                }\n                count += 1;\n            }\n        }\n        if (count == windowDataList.Count)\n        {\n            Debug.Log(\"预制体个数没有发生改变，不生成窗口配置\");\n            return;\n        }\n\n        windowDataList.Clear();\n        foreach (var item in windowRootArr)\n        {\n            //获取预制体文件夹读取路径\n            string folder = Application.dataPath + \"/ZMUIFrameWork/Resources/\" + item;\n            //获取文件夹下的所有Prefab文件\n            string[] filePathArr = Directory.GetFiles(folder, \"*.prefab\", SearchOption.AllDirectories);\n            foreach (string path in filePathArr)\n            {\n                //过滤.meta文件\n                if (path.EndsWith(\".meta\"))\n                {\n                    continue;\n                }\n                //获取预制体名字\n                string fileName = Path.GetFileNameWithoutExtension(path);\n                //计算文件读取路径\n                string filePath = item + \"/\" + fileName;\n                WindowData windowData = new WindowData { name = fileName, path = filePath };\n                windowDataList.Add(windowData);\n            }\n        }\n    }\n\n\t//获取窗口预制体路径\n    public string GetWindowPath(string windowName)\n    {\n        foreach (var windowData in windowDataList)\n        {\n            if (string.Equals(windowData.name, windowName))\n            {\n                return windowData.path;\n            }\n        }\n        Debug.LogError($\"{windowName}: 此Window预制体路径不存在于配置文件中，请检查预制体存放位置，或检查配置文件是否包括存放Window预制体的文件夹路径！\");\n        return \"\";\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}