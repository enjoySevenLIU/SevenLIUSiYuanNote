{
	"ID": "20240106220754-hourjnj",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20240106220754-hourjnj",
		"title": "ZMUIL1——UI管理系统",
		"type": "doc",
		"updated": "20240419223250"
	},
	"Children": [
		{
			"ID": "20240123170208-ug27nlr",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240123170208-ug27nlr",
				"updated": "20240123170219"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "UI管理系统要做的工作"
				}
			]
		},
		{
			"ID": "20240123170220-9wshu6c",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240123170220-9wshu6c",
				"updated": "20240419223250"
			},
			"Children": [
				{
					"ID": "20240123172324-ryt0qiw",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240123172324-ryt0qiw",
						"updated": "20240419223250"
					},
					"Children": [
						{
							"ID": "20240123172324-ifebpqe",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240123172324-ifebpqe",
								"updated": "20240419223250"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "UI管理系统不仅要实现诸如控制UI窗口加载显隐等常见功能，还要实现独立于"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "MonoBehaviour"
								},
								{
									"Type": "NodeText",
									"Data": "​之外的UI对象生命周期函数"
								}
							]
						}
					]
				},
				{
					"ID": "20240123170228-80fay54",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240123170228-80fay54",
						"updated": "20240123170228"
					},
					"Children": [
						{
							"ID": "20240123170228-1e5rgis",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240123170228-1e5rgis",
								"updated": "20240123173534"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBehaviour"
								},
								{
									"Type": "NodeText",
									"Data": "​​​基类"
								}
							]
						},
						{
							"ID": "20240123172944-uslm14r",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240123172944-uslm14r",
								"updated": "20240123172946"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBehaviour"
								},
								{
									"Type": "NodeText",
									"Data": "​​​声明窗口的基础"
								},
								{
									"Type": "NodeText",
									"Data": "属性"
								},
								{
									"Type": "NodeText",
									"Data": "，如"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "gameObject"
								},
								{
									"Type": "NodeText",
									"Data": "​​​、"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "IsVisable"
								},
								{
									"Type": "NodeText",
									"Data": "​​​等，并声明"
								},
								{
									"Type": "NodeText",
									"Data": "生命周期函数"
								},
								{
									"Type": "NodeText",
									"Data": "，如"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "OnAwake"
								},
								{
									"Type": "NodeText",
									"Data": "​​​等\n使本框架下的窗口对象在拥有类似于"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "MonoBehaviour"
								},
								{
									"Type": "NodeText",
									"Data": "​​​的基础"
								},
								{
									"Type": "NodeText",
									"Data": "属性"
								},
								{
									"Type": "NodeText",
									"Data": "和"
								},
								{
									"Type": "NodeText",
									"Data": "生命周期函数"
								},
								{
									"Type": "NodeText",
									"Data": "的同时，我们可以"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "自己控制UI窗口的生命周期函数的执行"
								}
							]
						}
					]
				},
				{
					"ID": "20240123170731-o13dazo",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20240123170731-o13dazo"
					},
					"Children": [
						{
							"ID": "20240123170731-r6qw3vg",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240123170731-r6qw3vg",
								"updated": "20240123173100"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBase"
								},
								{
									"Type": "NodeText",
									"Data": "​​​基类（继承"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBehaviour"
								},
								{
									"Type": "NodeText",
									"Data": "​​​）"
								}
							]
						},
						{
							"ID": "20240123172949-em58op3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240123172949-em58op3",
								"updated": "20240124214759"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将本框架下的UI窗口的部分共同功能抽象到该基类内，后续所有的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "Window脚本都继承于它"
								},
								{
									"Type": "NodeText",
									"Data": "\n​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBase"
								},
								{
									"Type": "NodeText",
									"Data": "​​​会管理常用的UI控件，窗口的"
								},
								{
									"Type": "NodeText",
									"Data": "遮罩"
								},
								{
									"Type": "NodeText",
									"Data": "对象和所有UI控件的父节点对象。\n提供窗口初始化方法、显隐窗口方法、显隐"
								},
								{
									"Type": "NodeText",
									"Data": "遮罩"
								},
								{
									"Type": "NodeText",
									"Data": "方法，以及常用UI控件的监听事件添加与移除方法等"
								}
							]
						}
					]
				},
				{
					"ID": "20240123171449-v65yev1",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20240123171449-v65yev1",
						"updated": "20240125000244"
					},
					"Children": [
						{
							"ID": "20240123171449-aug0jb8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240123171449-aug0jb8",
								"updated": "20240123173549"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UIMoudle"
								},
								{
									"Type": "NodeText",
									"Data": "​​​"
								}
							]
						},
						{
							"ID": "20240123173108-64bu34d",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240123173108-64bu34d",
								"updated": "20240125000244"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "整个UI模块的核心，管理场景上的UI摄像机，UI根节点，UI配置文件，以及所有加载出来的UI窗口"
								},
								{
									"Type": "NodeText",
									"Data": "\n对外，​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UIMoudle"
								},
								{
									"Type": "NodeText",
									"Data": "​提供窗口的加载，显隐，销毁等接口\n在以上功能中，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UIModule"
								},
								{
									"Type": "NodeText",
									"Data": "​会在合适的时机执行"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBehaviour"
								},
								{
									"Type": "NodeText",
									"Data": "​的不同的生命周期函数\n后续还要在"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UIModule"
								},
								{
									"Type": "NodeText",
									"Data": "​实现单遮调节遮罩逻辑，堆栈系统逻辑等"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240124230259-2e1rqgl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124230259-2e1rqgl",
				"updated": "20240124230300"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 389px;",
						"style": "width: 379px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240106221804-tqsd4j1.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 379px;\" parent-style=\"width: 389px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240124194705-qjoj02w",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240124194705-qjoj02w",
				"updated": "20240124212001"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一、WindowBehaviour"
				}
			]
		},
		{
			"ID": "20240124194943-3hwa3n4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124194943-3hwa3n4",
				"updated": "20240124212001"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBehaviour"
				},
				{
					"Type": "NodeText",
					"Data": "​是所有Window窗口类的顶层类，为所有Window逻辑类提供基础属性和行为\nUI窗口的基类"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​就会继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBehaviour"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240124194722-g50do5z",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240124194722-g50do5z",
				"style": "line-height: 22px;",
				"updated": "20240124212001"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using System;\nusing UnityEngine;\n\npublic abstract class WindowBehaviour\n{\n    //基础属性\n    public GameObject gameObject { get; set; }      //当前窗口对象\n    public Transform transform { get; set; }        //当前窗口对象的Transform\n    public Canvas Canvas { get; set; }              //当前窗口对象的Canvas\n    public string Name { get; set; }                //当前对象的名字\n    public bool Visible { get; set; }               //窗口是否可见\n    //堆栈系统属性\n\tpublic bool PopStack { get; set; }              //是否是通过堆栈系统弹出的弹窗，若是，则处于堆栈弹出的流程时，隐藏该窗口将弹出下一个窗口\n    public Action\u003cWindowBase\u003e PopStackListener { get; set; }    //从堆栈系统出栈时的监听函数\n\n    //生命周期函数\n    public virtual void OnAwake() { }               //只会在窗口对象加载出来的时候执行一次，与MonoBehaviour的OnAwake作用一致\n    public virtual void OnShow() { }                //在窗口显示的时候执行一次，与MonoBehaviour的OnEnable作用一致\n    public virtual void OnHide() { }                //在窗口隐藏的时候执行一次，与MonoBehaviour的OnEnable作用一致\n    public virtual void OnDestroy() { }             //在窗口对象被销毁时调用一次，与MonoBehaviour的OnDestroy作用一致\n\n    /// \u003csummary\u003e\n    /// 设置物体的可见性\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"visible\"\u003e是否可见\u003c/param\u003e\n    public virtual void SetVisible(bool visible) { }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240124194824-i2hjayy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124194824-i2hjayy",
				"updated": "20240124212001"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其中："
				}
			]
		},
		{
			"ID": "20240124200241-ixg8vzv",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240124200241-ixg8vzv",
				"updated": "20240125000350"
			},
			"Children": [
				{
					"ID": "20240124200242-nwk8gc4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124200242-nwk8gc4",
						"updated": "20240125000350"
					},
					"Children": [
						{
							"ID": "20240124200242-gxl7dqz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124200242-gxl7dqz",
								"updated": "20240125000350"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBehaviour"
								},
								{
									"Type": "NodeText",
									"Data": "​实现的生命周期函数由"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UIModule"
								},
								{
									"Type": "NodeText",
									"Data": "​在合适的时机调用"
								}
							]
						}
					]
				},
				{
					"ID": "20240124200742-nqob8q1",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124200742-nqob8q1"
					},
					"Children": [
						{
							"ID": "20240124200742-zowf5dd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124200742-zowf5dd"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "PopStack"
								},
								{
									"Type": "NodeText",
									"Data": "​​及"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "PopStackListener"
								},
								{
									"Type": "NodeText",
									"Data": "​​是"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "block-ref",
									"TextMarkBlockRefID": "20240123224808-br9y38i",
									"TextMarkBlockRefSubtype": "s",
									"TextMarkTextContent": "堆栈系统"
								},
								{
									"Type": "NodeText",
									"Data": "会调用的"
								},
								{
									"Type": "NodeText",
									"Data": "属性"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240124200253-e90e7ae",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240124200253-e90e7ae",
				"updated": "20240124211953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "二、WindowBase"
				}
			]
		},
		{
			"ID": "20240124200331-qqpp952",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124200331-qqpp952",
				"updated": "20240124211953"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​是所有Window逻辑类的基类，继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBehaviour"
				},
				{
					"Type": "NodeText",
					"Data": "​\n当使用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20240109184446-wad9kdb",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "自动化系统"
				},
				{
					"Type": "NodeText",
					"Data": "为UI窗口对象生成Window逻辑类时，Window逻辑类会自动继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​\n​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​将所有UI窗口的部分共同功能抽象到该基类内，包括："
				}
			]
		},
		{
			"ID": "20240124201100-m226pnw",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240124201100-m226pnw",
				"updated": "20240124233226"
			},
			"Children": [
				{
					"ID": "20240124201102-2vmtf41",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124201102-2vmtf41",
						"updated": "20240124201102"
					},
					"Children": [
						{
							"ID": "20240124201102-92lptqn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124201102-92lptqn",
								"updated": "20240125170133"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "管理常用的需要监听用户输入的UI控件，并对外提供监听事件管理接口"
								}
							]
						}
					]
				},
				{
					"ID": "20240124201411-338y9g8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124201411-338y9g8"
					},
					"Children": [
						{
							"ID": "20240124201411-s3u2bva",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124201411-s3u2bva",
								"updated": "20240124203138"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "重写"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WindowBehaviour"
								},
								{
									"Type": "NodeText",
									"Data": "​​​的"
								},
								{
									"Type": "NodeText",
									"Data": "生命周期函数"
								},
								{
									"Type": "NodeText",
									"Data": "，在其中执行UI窗口生成和"
								},
								{
									"Type": "NodeText",
									"Data": "销毁"
								},
								{
									"Type": "NodeText",
									"Data": "的必要逻辑，例如窗口初始化，执行显隐动画，清除监听事件等"
								}
							]
						}
					]
				},
				{
					"ID": "20240124201232-usjrngp",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124201232-usjrngp",
						"updated": "20240124232642"
					},
					"Children": [
						{
							"ID": "20240124201232-mnmpbcc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124201232-mnmpbcc",
								"updated": "20240124232642"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "管理"
								},
								{
									"Type": "NodeText",
									"Data": "遮罩"
								},
								{
									"Type": "NodeText",
									"Data": "的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "CanvasGroup"
								},
								{
									"Type": "NodeText",
									"Data": "​​​，对外提供显隐"
								},
								{
									"Type": "NodeText",
									"Data": "遮罩"
								},
								{
									"Type": "NodeText",
									"Data": "的方法，供"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UIModule"
								},
								{
									"Type": "NodeText",
									"Data": "​​​的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "block-ref",
									"TextMarkBlockRefID": "20240108182335-g9zaaa9",
									"TextMarkBlockRefSubtype": "s",
									"TextMarkTextContent": "遮罩系统"
								},
								{
									"Type": "NodeText",
									"Data": "调用"
								}
							]
						}
					]
				},
				{
					"ID": "20240124201754-lvc1u6b",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124201754-lvc1u6b"
					},
					"Children": [
						{
							"ID": "20240124201754-8ruxzl0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124201754-8ruxzl0",
								"updated": "20240124202957"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "管理UI窗口通用显隐动画方法"
								}
							]
						}
					]
				},
				{
					"ID": "20240124210544-8funi8g",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124210544-8funi8g"
					},
					"Children": [
						{
							"ID": "20240124210544-ufmh5mv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124210544-ufmh5mv",
								"updated": "20240124214322"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "提供隐藏窗口方法（主要是派生类调用）和设置窗口可见性方法（"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UIModule"
								},
								{
									"Type": "NodeText",
									"Data": "​​​内调用）"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240125170148-bbkjlww",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125170148-bbkjlww",
				"updated": "20240125213803"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.窗口基本成员"
				}
			]
		},
		{
			"ID": "20240125170244-fb6oygk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125170244-fb6oygk",
				"updated": "20240125213803"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​会自行管理常用的UI控件"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "button"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "toggle"
				},
				{
					"Type": "NodeText",
					"Data": "​ 和 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "inputField"
				},
				{
					"Type": "NodeText",
					"Data": "​，UI控件会在添加监听事件时添加到管理列表内"
				}
			]
		},
		{
			"ID": "20240125170911-o4x8jb2",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240125170911-o4x8jb2",
				"updated": "20240125213803"
			},
			"Children": [
				{
					"ID": "20240125170907-jdsoyyb",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240125170907-jdsoyyb",
						"updated": "20240125170911"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "注：调用添加监听事件的语句不需要由开发者编写，它们会在后续的"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "block-ref",
							"TextMarkBlockRefID": "20240109184446-wad9kdb",
							"TextMarkBlockRefSubtype": "s",
							"TextMarkTextContent": "自动化系统"
						},
						{
							"Type": "NodeText",
							"Data": "里由自动生成的脚本生成，也就是说，我们无需自己将UI控件加入到列表内"
						}
					]
				},
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				}
			]
		},
		{
			"ID": "20240125170855-de7jj46",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125170855-de7jj46",
				"updated": "20240125213803"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​还会管理所有窗口的遮罩对象，UI控件父节点对象，以及窗口上自带的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "CanvasGroup"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240125171038-oy8jxq4",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240125171038-oy8jxq4",
				"updated": "20240126012507"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240125171042-yytazqm",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240125171042-yytazqm",
						"updated": "20240125171150"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "注：在本框架下，UI窗口对象默认都采用下图的结构："
						}
					]
				},
				{
					"ID": "20240125171042-h75j50u",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240125171042-h75j50u",
						"updated": "20240125171042"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "​"
						},
						{
							"Type": "NodeImage",
							"Data": "span",
							"Children": [
								{
									"Type": "NodeBang"
								},
								{
									"Type": "NodeOpenBracket"
								},
								{
									"Type": "NodeLinkText",
									"Data": "image"
								},
								{
									"Type": "NodeCloseBracket"
								},
								{
									"Type": "NodeOpenParen"
								},
								{
									"Type": "NodeLinkDest",
									"Data": "assets/image-20240124232149-42k3gvu.png"
								},
								{
									"Type": "NodeCloseParen"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "​"
						}
					]
				},
				{
					"ID": "20240125171042-uxf0nqz",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240125171042-uxf0nqz",
						"updated": "20240125171219"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "UIMask是遮罩，UIContent是所有UI控件的父节点，采用这种结构的原因是为了方便后续"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "block-ref",
							"TextMarkBlockRefID": "20240108182335-g9zaaa9",
							"TextMarkBlockRefSubtype": "s",
							"TextMarkTextContent": "遮罩系统"
						},
						{
							"Type": "NodeText",
							"Data": "管理遮罩显隐"
						}
					]
				},
				{
					"ID": "20240125171221-qwo4l09",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240125171221-qwo4l09",
						"updated": "20240126012507"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "本框架还默认窗口对象上挂载"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "CanvasGroup"
						},
						{
							"Type": "NodeText",
							"Data": "​​，它用来替代"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "SetActive"
						},
						{
							"Type": "NodeText",
							"Data": "​​来控制窗口显隐，因此需要管理它，原因在"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "block-ref",
							"TextMarkBlockRefID": "20240124145042-grnb3ih",
							"TextMarkBlockRefSubtype": "s",
							"TextMarkTextContent": "高性能系统"
						},
						{
							"Type": "NodeText",
							"Data": "里解释"
						}
					]
				}
			]
		},
		{
			"ID": "20240125170227-rf0omv5",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125170227-rf0omv5",
				"style": "line-height: 22px;",
				"updated": "20240125213803"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//常用UI控件管理列表\nprivate List\u003cButton\u003e mAllButtonList = new List\u003cButton\u003e();       //所有Button的列表\nprivate List\u003cToggle\u003e mToggleList = new List\u003cToggle\u003e();          //所有Toggle的列表\nprivate List\u003cInputField\u003e mInputList = new List\u003cInputField\u003e();   //所有输入框的列表\n\nprivate CanvasGroup mUIMask;            //窗口的遮罩的CanvasGroup\nprivate CanvasGroup mCanvasGroup;       //窗口的CanvasGroup\nprotected Transform mUIContent;         //窗口的UI控件父节点\nprotected bool mDisableAnim = false;    //是否禁用动画\n\n//初始化基类组件\nprivate void InitializeBaseComponent()\n{\n    mCanvasGroup = transform.GetComponent\u003cCanvasGroup\u003e();\n    mUIMask = transform.Find(\"UIMask\").GetComponent\u003cCanvasGroup\u003e();\n    mUIContent = transform.Find(\"UIContent\").transform;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125221122-jw5ni30",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125221122-jw5ni30",
				"updated": "20240125221207"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里的初始化窗口方法会在基类的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "OnAwake()"
				},
				{
					"Type": "NodeText",
					"Data": "​里调用"
				}
			]
		},
		{
			"ID": "20240124203154-tct89z0",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240124203154-tct89z0",
				"updated": "20240125213806"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.监听事件管理相关"
				}
			]
		},
		{
			"ID": "20240124203614-t14vdg6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124203614-t14vdg6",
				"updated": "20240125213806"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​封装了"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Button"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Toggle"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "InputField"
				},
				{
					"Type": "NodeText",
					"Data": "​这三种常用控件的添加监听事件方法，该方法需要"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "传入控件本身与监听方法"
				},
				{
					"Type": "NodeText",
					"Data": "\n若控件列表内没有这个控件会将控件加入管理列表，然后清空控件原来的监听方法，重新添加传入的监听方法\n"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "该方法会在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref strong",
					"TextMarkBlockRefID": "20240109184446-wad9kdb",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "自动化系统"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "生成的组件数据脚本/组件数据脚本调用，用于初始化UI窗口的控件事件监听（也就是说，我们不需要自己初始化组件监听方法）"
				}
			]
		},
		{
			"ID": "20240124205057-q0szygm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124205057-q0szygm",
				"updated": "20240125213806"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​​还封装了"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Button"
				},
				{
					"Type": "NodeText",
					"Data": "​​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Toggle"
				},
				{
					"Type": "NodeText",
					"Data": "​​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "InputField"
				},
				{
					"Type": "NodeText",
					"Data": "​​这三种常用控件的清除事件监听方法，\n该方法可以一次清空所有管理的控件的监听方法，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "它会在窗口销毁时会调用"
				}
			]
		},
		{
			"ID": "20240124205054-st6oszs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124205054-st6oszs",
				"updated": "20240125213806"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "三种控件的添加监听方法与清除监听方法的逻辑大同小异"
				}
			]
		},
		{
			"ID": "20240124204255-lk353p3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240124204255-lk353p3",
				"style": "line-height: 22px;",
				"updated": "20240125213806"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//WindowBase内，以Button为例\nprivate List\u003cButton\u003e mAllButtonList = new List\u003cButton\u003e();       //所有Button的列表\nprivate List\u003cToggle\u003e mToggleList = new List\u003cToggle\u003e();          //所有Toggle的列表\nprivate List\u003cInputField\u003e mInputList = new List\u003cInputField\u003e();   //所有输入框的列表\n\npublic void AddButtonClickListener(Button button, UnityAction action)\n{\n    if (button != null)\n    {\n        if (!mAllButtonList.Contains(button))\n        {\n            mAllButtonList.Add(button);\n        }\n        button.onClick.RemoveAllListeners();\n        button.onClick.AddListener(action);\n    }\n}\n\npublic void RemoveAllButtonListener()\n{\n    foreach (var button in mAllButtonList)\n    {\n        button.onClick.RemoveAllListeners();\n    }\n}\n\n//其他两种控件逻辑大同小异\npublic void AddToggleClickListener(Toggle toggle, UnityAction\u003cbool, Toggle\u003e action)\npublic void AddInputFieldListener(InputField input, UnityAction\u003cstring\u003e onChangeAction, UnityAction\u003cstring\u003e endAction)\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240124210550-x9hog03",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240124210550-x9hog03",
				"updated": "20240125213813"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.通用显隐动画相关"
				}
			]
		},
		{
			"ID": "20240124210605-57hcxav",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124210605-57hcxav",
				"updated": "20240125213813"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​​通过调用DOTween的拓展方法，实现窗口通用的的显示隐藏动画方法，并提供"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "mDisableAnim"
				},
				{
					"Type": "NodeText",
					"Data": "​​"
				},
				{
					"Type": "NodeText",
					"Data": "变量"
				},
				{
					"Type": "NodeText",
					"Data": "来决定是否调用这些动画\n"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "开发者可以在这两个方法内覆写其他代码来实现不同的效果"
				},
				{
					"Type": "NodeText",
					"Data": "，也可以在派生类里的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "OnAwake()"
				},
				{
					"Type": "NodeText",
					"Data": "​​里将"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "mDisableAnim"
				},
				{
					"Type": "NodeText",
					"Data": "​​赋值为"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "true"
				},
				{
					"Type": "NodeText",
					"Data": "​​以禁用动画"
				}
			]
		},
		{
			"ID": "20240124210701-n7urpok",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240124210701-n7urpok",
				"style": "line-height: 22px;",
				"updated": "20240125213813"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//WindowBase内\nprotected bool mDisableAnim = false;    //是否禁用动画\n\n//窗口显示时会播放的动画\npublic void ShowAnimation()\n{\n    if (Canvas.sortingOrder \u003e 90 \u0026\u0026 mDisableAnim == false)\n    {\n        //Mask动画\n        mUIMask.alpha = 0f;\n        mUIMask.DOFade(1, 0.2f);\n        //缩放动画\n        mUIContent.localScale = Vector3.one * 0.8f;\n        //表示Scale从0.8缩放到1，消耗0.3s时间，使用OutBack曲线\n        mUIContent.DOScale(Vector3.one, 0.3f).SetEase(Ease.OutBack);\n    }\n}\n\n//窗口隐藏时会播放的动画\npublic void HideAnimation()\n{\n    if (Canvas.sortingOrder \u003e 90 \u0026\u0026 mDisableAnim == false)\n    {\n        mUIContent.DOScale(Vector3.one * 1.1f, 0.2f).SetEase(Ease.OutBack).OnComplete(() =\u003e\n        {\n            UIModule.Instance.HideWindow(Name);\n        });\n    }\n    else\n    {\n        UIModule.Instance.HideWindow(Name);\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125171828-wkjtcor",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125171828-wkjtcor",
				"updated": "20240125213813"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "禁用动画，将"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "mDisableAnim"
				},
				{
					"Type": "NodeText",
					"Data": "​设为"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "true"
				},
				{
					"Type": "NodeText",
					"Data": "​即可"
				}
			]
		},
		{
			"ID": "20240124214436-sfe7uv0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240124214436-sfe7uv0",
				"style": "line-height: 22px;",
				"updated": "20240125213813"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//UserInfoWindow，继承WindowBase\npublic override void OnAwake()\n{\n    dataComponent = gameObject.GetComponent\u003cUserInfoWindowDataComponent\u003e();\n    dataComponent.InitComponent(this);\n    mDisableAnim = true;\t\t//这样窗口显隐将不播放动画\n    base.OnAwake();\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125221232-5s3bau2",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125221232-5s3bau2",
				"updated": "20240125221456"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.生命周期函数的重写"
				}
			]
		},
		{
			"ID": "20240125221355-2gqg3do",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125221355-2gqg3do",
				"updated": "20240125221456"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "主要是在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "OnAwake()"
				},
				{
					"Type": "NodeText",
					"Data": "​里执行初始化方法，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "OnDestroy()"
				},
				{
					"Type": "NodeText",
					"Data": "​清除事件监听并释放内存"
				}
			]
		},
		{
			"ID": "20240125221243-aeq65io",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125221243-aeq65io",
				"style": "line-height: 22px;",
				"updated": "20240125221456"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#region 生命周期函数的声明\npublic override void OnAwake()\n{\n    base.OnAwake();\n    InitializeBaseComponent();\n}\n\npublic override void OnShow()\n{\n    base.OnShow();\n    ShowAnimation();\n}\n\npublic override void OnHide()\n{\n\tbase.OnHide();\n}\n\npublic override void OnDestroy()\n{\n    base.OnDestroy();\n    RemoveAllButtonListener();\n    RemoveAllToggleListener();\n    RemoveAllInputListener();\n    mAllButtonList.Clear();\n    mToggleList.Clear();\n    mInputList.Clear();\n}\n#endregion\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240124202419-hwb45yi",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240124202419-hwb45yi",
				"updated": "20240125170213"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "WindowBase代码"
				}
			]
		},
		{
			"ID": "20240124200457-rjma2qb",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240124200457-rjma2qb",
				"style": "line-height: 22px;",
				"updated": "20240125170213"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using DG.Tweening;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.UI;\n\npublic class WindowBase : WindowBehaviour\n{\n    //常用UI控件管理列表\n    private List\u003cButton\u003e mAllButtonList = new List\u003cButton\u003e();       //所有Button的列表\n    private List\u003cToggle\u003e mToggleList = new List\u003cToggle\u003e();          //所有Toggle的列表\n    private List\u003cInputField\u003e mInputList = new List\u003cInputField\u003e();   //所有输入框的列表\n\n    private CanvasGroup mUIMask;            //窗口的遮罩的CanvasGroup\n    private CanvasGroup mCanvasGroup;       //窗口的CanvasGroup\n    protected Transform mUIContent;         //窗口的UI控件父节点\n    protected bool mDisableAnim = false;    //是否禁用动画\n\n    //初始化基类组件\n    private void InitializeBaseComponent()\n    {\n        mCanvasGroup = transform.GetComponent\u003cCanvasGroup\u003e();\n        mUIMask = transform.Find(\"UIMask\").GetComponent\u003cCanvasGroup\u003e();\n        mUIContent = transform.Find(\"UIContent\").transform;\n    }\n\n    #region 生命周期函数的声明\n    public override void OnAwake()\n    {\n        base.OnAwake();\n        InitializeBaseComponent();\n    }\n\n    public override void OnShow()\n    {\n        base.OnShow();\n        ShowAnimation();\n    }\n\n    public override void OnHide()\n    {\n        base.OnHide();\n    }\n\n    public override void OnDestroy()\n    {\n        base.OnDestroy();\n        RemoveAllButtonListener();\n        RemoveAllToggleListener();\n        RemoveAllInputListener();\n        mAllButtonList.Clear();\n        mToggleList.Clear();\n        mInputList.Clear();\n    }\n    #endregion\n\n    #region 动画管理相关\n    public void ShowAnimation()\n    {\n        if (Canvas.sortingOrder \u003e 90 \u0026\u0026 mDisableAnim == false)\n        {\n            //Mask动画\n            mUIMask.alpha = 0f;\n            mUIMask.DOFade(1, 0.2f);\n            //缩放动画\n            mUIContent.localScale = Vector3.one * 0.8f;\n            //表示Scale从0.8缩放到1，消耗0.3s时间，使用OutBack曲线\n            mUIContent.DOScale(Vector3.one, 0.3f).SetEase(Ease.OutBack);\n        }\n    }\n\n    public void HideAnimation()\n    {\n        if (Canvas.sortingOrder \u003e 90 \u0026\u0026 mDisableAnim == false)\n        {\n            mUIContent.DOScale(Vector3.one * 1.1f, 0.2f).SetEase(Ease.OutBack).OnComplete(() =\u003e\n            {\n                UIModule.Instance.HideWindow(Name);\n            });\n        }\n        else\n        {\n            UIModule.Instance.HideWindow(Name);\n        }\n    }\n    #endregion\n\n    public void HideWindow()\n    {\n        HideAnimation();\n        //UIModule.Instance.HideWindow(Name);\n    }\n\n    public override void SetVisible(bool isVisible)\n    {\n        //gameObject.SetActive(isVisible);          //直接使用SetActive会造成UI控件重绘，浪费性能\n        mCanvasGroup.alpha = isVisible ? 1f : 0f;   //使用CanvasGroup来控制UI窗口的显隐，不会造成UI控件重绘，性能更好\n        mCanvasGroup.blocksRaycasts = isVisible;    //根据是否显示，决定是否接收用户输入，防止隐藏的窗口挡住显示的窗口输入\n        Visible = isVisible;\n    }\n\n    /// \u003csummary\u003e\n    /// 控制遮罩是否生效，仅在单遮模式开启时有效\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"isVisible\"\u003e是否可见\u003c/param\u003e\n    public void SetMaskVisible(bool isVisible)\n    {\n        //如果未开启单遮模式，则直接返回\n        if (!UISetting.Instance.SINGMASK_SYSTEM) return;\n        mUIMask.alpha = isVisible ? 1f : 0f;\n    }\n\n    #region 事件管理方法\n    /// \u003csummary\u003e\n    /// 添加按钮的点击事件监听，添加后会清除原有监听函数\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"button\"\u003e要添加点击事件监听的按钮\u003c/param\u003e\n    /// \u003cparam name=\"action\"\u003e监听到按钮点击后执行什么事件\u003c/param\u003e\n    public void AddButtonClickListener(Button button, UnityAction action)\n    {\n        if (button != null)\n        {\n            if (!mAllButtonList.Contains(button))\n            {\n                mAllButtonList.Add(button);\n            }\n            button.onClick.RemoveAllListeners();\n            button.onClick.AddListener(action);\n        }\n    }\n\n    public void AddToggleClickListener(Toggle toggle, UnityAction\u003cbool, Toggle\u003e action)\n    {\n        if (toggle != null)\n        {\n            if (!mToggleList.Contains(toggle))\n            {\n                mToggleList.Add(toggle);\n            }\n            toggle.onValueChanged.RemoveAllListeners();\n            toggle.onValueChanged.AddListener((isOn) =\u003e\n            {\n                action?.Invoke(isOn, toggle);\n            });\n        }\n    }\n\n    public void AddInputFieldListener(InputField input, UnityAction\u003cstring\u003e onChangeAction, UnityAction\u003cstring\u003e endAction)\n    {\n        if (input != null)\n        {\n            if (!mInputList.Contains(input))\n            {\n                mInputList.Add(input);\n            }\n            input.onValueChanged.RemoveAllListeners();\n            input.onEndEdit.RemoveAllListeners();\n            input.onValueChanged.AddListener(onChangeAction);\n            input.onEndEdit.AddListener(endAction);\n        }\n    }\n\n    public void RemoveAllButtonListener()\n    {\n        foreach (var button in mAllButtonList)\n        {\n            button.onClick.RemoveAllListeners();\n        }\n    }\n\n    public void RemoveAllToggleListener()\n    {\n        foreach (var toggle in mToggleList)\n        {\n            toggle.onValueChanged.RemoveAllListeners();\n        }\n    }\n\n    public void RemoveAllInputListener()\n    {\n        foreach (var input in mInputList)\n        {\n            input.onValueChanged.RemoveAllListeners();\n            input.onEndEdit.RemoveAllListeners();\n        }\n    }\n    #endregion\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240124212011-u7hj6j1",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240124212011-u7hj6j1",
				"updated": "20240124212027"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "三、UIModule"
				}
			]
		},
		{
			"ID": "20240124212029-s2gh18c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124212029-s2gh18c",
				"updated": "20240124214303"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIModule"
				},
				{
					"Type": "NodeText",
					"Data": "​是框架的核心，是所有UI窗口的单例管理器，它管理场景上唯一的UI摄像机，所有窗口。框架的多个系统都会在这里实现\n​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIModule"
				},
				{
					"Type": "NodeText",
					"Data": "​要提供的功能包括："
				}
			]
		},
		{
			"ID": "20240124212554-xpujahg",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240124212554-xpujahg",
				"updated": "20240124214115"
			},
			"Children": [
				{
					"ID": "20240124212556-r6a1xny",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124212556-r6a1xny",
						"updated": "20240124212556"
					},
					"Children": [
						{
							"ID": "20240124212556-2sq1qkj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124212556-2sq1qkj",
								"updated": "20240124213016"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "窗口管理：管理场景上所有的Window逻辑类，以窗口类型和窗口名为参数，提供窗口的预加载，弹出，初始化，隐藏，"
								},
								{
									"Type": "NodeText",
									"Data": "销毁"
								},
								{
									"Type": "NodeText",
									"Data": "功能"
								}
							]
						}
					]
				},
				{
					"ID": "20240124213022-cwrt7q1",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124213022-cwrt7q1"
					},
					"Children": [
						{
							"ID": "20240124213022-uon69xz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124213022-uon69xz",
								"updated": "20240124213133"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "窗口生命函数的执行：当窗口加载、显隐、"
								},
								{
									"Type": "NodeText",
									"Data": "销毁"
								},
								{
									"Type": "NodeText",
									"Data": "时，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UIModule"
								},
								{
									"Type": "NodeText",
									"Data": "​​需要调用执行该窗口对应的"
								},
								{
									"Type": "NodeText",
									"Data": "生命周期函数"
								}
							]
						}
					]
				},
				{
					"ID": "20240124213130-h3r14xe",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124213130-h3r14xe"
					},
					"Children": [
						{
							"ID": "20240124213130-knuzvdx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124213130-knuzvdx",
								"updated": "20240124213355"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "控制窗口"
								},
								{
									"Type": "NodeText",
									"Data": "遮罩"
								},
								{
									"Type": "NodeText",
									"Data": "的显隐："
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "block-ref",
									"TextMarkBlockRefID": "20240108182335-g9zaaa9",
									"TextMarkBlockRefSubtype": "s",
									"TextMarkTextContent": "遮罩系统"
								},
								{
									"Type": "NodeText",
									"Data": "在"
								},
								{
									"Type": "NodeText",
									"Data": "这里"
								},
								{
									"Type": "NodeText",
									"Data": "实现，当开启单遮模式时，每次执行窗口显隐逻辑时，都会重新计算哪个窗口的"
								},
								{
									"Type": "NodeText",
									"Data": "遮罩"
								},
								{
									"Type": "NodeText",
									"Data": "需要开启，以实现单遮效果"
								}
							]
						}
					]
				},
				{
					"ID": "20240124213356-wh18br7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240124213356-wh18br7",
						"updated": "20240124214115"
					},
					"Children": [
						{
							"ID": "20240124213356-do2hqqn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240124213356-do2hqqn",
								"updated": "20240124214115"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "窗口按顺序依次显示："
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "block-ref",
									"TextMarkBlockRefID": "20240123224808-br9y38i",
									"TextMarkBlockRefSubtype": "s",
									"TextMarkTextContent": "堆栈系统"
								},
								{
									"Type": "NodeText",
									"Data": "在"
								},
								{
									"Type": "NodeText",
									"Data": "这里"
								},
								{
									"Type": "NodeText",
									"Data": "实现，可以设置窗口弹出队列，让窗口依次弹出，期间可以追加窗口或清除队列，打开队列外窗口也不影响显示队列"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240125172446-uulouyg",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125172446-uulouyg",
				"updated": "20240125213817"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.UIModule的基础成员"
				}
			]
		},
		{
			"ID": "20240125172528-bww4mg4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125172528-bww4mg4",
				"updated": "20240125213817"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIModule"
				},
				{
					"Type": "NodeText",
					"Data": "​是管理器，因此采用单例模式\n​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIModule"
				},
				{
					"Type": "NodeText",
					"Data": "​管理场景上的UI摄像机，窗口父对象UIRoot，\n​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIModule"
				},
				{
					"Type": "NodeText",
					"Data": "​还会管理所有加载出来的窗口，以及显示中的窗口"
				}
			]
		},
		{
			"ID": "20240125172659-c5chln1",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240125172659-c5chln1",
				"updated": "20240125213817"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240125172734-v95h8ig",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240125172734-v95h8ig",
						"updated": "20240125172852"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "​"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "WindowConfig"
						},
						{
							"Type": "NodeText",
							"Data": "​与"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "block-ref",
							"TextMarkBlockRefID": "20240109184446-wad9kdb",
							"TextMarkBlockRefSubtype": "s",
							"TextMarkTextContent": "自动化系统"
						},
						{
							"Type": "NodeText",
							"Data": "的自动获取UI预设体加载路径有关\n​"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "mWindowStack"
						},
						{
							"Type": "NodeText",
							"Data": "​和"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "mStartPopStackWindowStatus"
						},
						{
							"Type": "NodeText",
							"Data": "​则与"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "block-ref",
							"TextMarkBlockRefID": "20240123224808-br9y38i",
							"TextMarkBlockRefSubtype": "s",
							"TextMarkTextContent": "堆栈系统"
						},
						{
							"Type": "NodeText",
							"Data": "有关"
						}
					]
				}
			]
		},
		{
			"ID": "20240125172458-xzh0xp7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125172458-xzh0xp7",
				"style": "line-height: 22px;",
				"updated": "20240125213817"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "private static UIModule _instance;\npublic static UIModule Instance\n    {\n        get\n        {\n            if (_instance == null)\n            {\n                _instance = new UIModule();\n            }\n            return _instance;\n        }\n    }\n\nprivate Camera mUICamera;               //场景上的UI摄像机\nprivate Transform mUIRoot;              //场景上的UI根节点\nprivate WindowConfig mWindowConfig;     //窗口读取路径配置文件\n\nprivate Dictionary\u003cstring, WindowBase\u003e mAllWindowDic = new Dictionary\u003cstring, WindowBase\u003e();    //所有窗口的字典\nprivate List\u003cWindowBase\u003e mAllWindowList = new List\u003cWindowBase\u003e();                               //所有窗口的列表\nprivate List\u003cWindowBase\u003e mVisibleWindowList = new List\u003cWindowBase\u003e();                           //所有可见窗口的列表\n\nprivate Queue\u003cWindowBase\u003e mWindowStack = new Queue\u003cWindowBase\u003e();   //堆栈系统的队列，用来管理弹窗的循环弹出\nprivate bool mStartPopStackWindowStatus = false;                    //开始弹出堆栈的标志，用于处理多种情况，例如：正在出栈中有其他界面弹出，可以直接放到栈内进行弹出等\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125171949-x5r1pl7",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240125171949-x5r1pl7",
				"updated": "20240125213819"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.UIModule的初始化"
				}
			]
		},
		{
			"ID": "20240125172003-3611le2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125172003-3611le2",
				"updated": "20240125213819"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIModule"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "第一次调用时不会初始化，需要自己进行初始化"
				},
				{
					"Type": "NodeText",
					"Data": "\n初始化方法是通过"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Find"
				},
				{
					"Type": "NodeText",
					"Data": "​方法获取场景上的摄像机，UIRoot对象，加载并获取所有预设体组件加载路径"
				}
			]
		},
		{
			"ID": "20240125172313-jivjid3",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240125172313-jivjid3",
				"updated": "20240125213819"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240125172315-t9vg0xa",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240125172315-t9vg0xa",
						"updated": "20240125172758"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "​"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "mWindowConfig"
						},
						{
							"Type": "NodeText",
							"Data": "​与"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "mWindowConfig.GeneratorWindowConfig()"
						},
						{
							"Type": "NodeText",
							"Data": "​与"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "block-ref",
							"TextMarkBlockRefID": "20240109184446-wad9kdb",
							"TextMarkBlockRefSubtype": "s",
							"TextMarkTextContent": "自动化系统"
						},
						{
							"Type": "NodeText",
							"Data": "的自动获取UI预设体加载路径有关"
						}
					]
				}
			]
		},
		{
			"ID": "20240125172125-rtqp7nc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125172125-rtqp7nc",
				"style": "line-height: 22px;",
				"updated": "20240125213819"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//初始化方法 \npublic void Initialize()\n{\n    //获取场景上的UI摄像机和UI根节点\n    mUICamera = GameObject.Find(\"UICamera\").GetComponent\u003cCamera\u003e();\n    mUIRoot = GameObject.Find(\"UIRoot\").transform;\n    mWindowConfig = Resources.Load\u003cWindowConfig\u003e(\"WindowConfig\");\n    //打包出去后不会触发调用\n#if UNITY_EDITOR\n    mWindowConfig.GeneratorWindowConfig();\n#endif\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240124214334-sv5f0hq",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240124214334-sv5f0hq",
				"updated": "20240125213824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.UIModule的UI管理"
				}
			]
		},
		{
			"ID": "20240124214942-mskgx6a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124214942-mskgx6a",
				"updated": "20240125213824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIModule"
				},
				{
					"Type": "NodeText",
					"Data": "​是使用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​来进行窗口管理的，而不使用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBehaviour"
				},
				{
					"Type": "NodeText",
					"Data": "​来管理，\n因为"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBehaviour"
				},
				{
					"Type": "NodeText",
					"Data": "​作为最顶层的类，缺乏"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​的派生实现，\n​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​内会实现更多通用的功能，例如弹出与消失动画， 遮罩处理等，\n使用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​管理能够更方便的调用"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "WindowBase"
				},
				{
					"Type": "NodeText",
					"Data": "​接口"
				}
			]
		},
		{
			"ID": "20240124222038-relx729",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240124222038-relx729",
				"style": "line-height: 22px;",
				"updated": "20240125213824"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "private Camera mUICamera;               //场景上的UI摄像机\nprivate Transform mUIRoot;              //场景上的UI根节点\nprivate WindowConfig mWindowConfig;     //窗口读取路径配置文件\n\nprivate Dictionary\u003cstring, WindowBase\u003e mAllWindowDic = new Dictionary\u003cstring, WindowBase\u003e();    //所有窗口的字典\nprivate List\u003cWindowBase\u003e mAllWindowList = new List\u003cWindowBase\u003e();                               //所有窗口的列表\nprivate List\u003cWindowBase\u003e mVisibleWindowList = new List\u003cWindowBase\u003e();                           //所有可见窗口的列表\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240124214334-w6h6ng8",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20240124214334-w6h6ng8",
				"updated": "20240125213828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "a) 窗口弹出"
				}
			]
		},
		{
			"ID": "20240125173438-81pffy0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125173438-81pffy0",
				"updated": "20240125213828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "弹出窗口会触发窗口的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "OnShow()"
				},
				{
					"Type": "NodeText",
					"Data": "​方法，如果是第一次弹出，还会触发"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "OnAwake"
				},
				{
					"Type": "NodeText",
					"Data": "​方法\n弹出窗口让"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20240108182335-g9zaaa9",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "遮罩系统"
				},
				{
					"Type": "NodeText",
					"Data": "重新计算单遮"
				}
			]
		},
		{
			"ID": "20240124214851-kxq5gah",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124214851-kxq5gah",
				"updated": "20240125213828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "UIModule"
				},
				{
					"Type": "NodeText",
					"Data": "​的窗口弹出实现较繁琐，因此在这里记录，这里使用伪代码阐述思路："
				}
			]
		},
		{
			"ID": "20240124215350-npf631y",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240124215350-npf631y",
				"style": "line-height: 22px;",
				"updated": "20240125213828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//弹出窗口伪代码，演示弹出窗口运行思路，实际代码会分成多个函数\n\n//弹出窗口方法的调用，需要传入要显示的窗口类，窗口类必须继承WindowBase\n要显示的窗口类 窗口对象 = UIMoudle.Instance.PopUpWindow\u003c要显示的窗口类\u003e();\n\n//弹出窗口方法的实现，T是继承WindowBase的窗口类\npublic T PopUpWindow\u003cT\u003e() : where T : WindowBase, new()\n{\n\t窗口名 = 通过传入的T获取类名\n\tif 通过窗口名发现字典内存在窗口\t\t\t\t//窗口存在于内存内，执行显示窗口逻辑\n\t\tT t = 通过窗口名从字典获取窗口\n\t\tif t.gameObject不为空 \u0026\u0026 t不可见\n\t\t\t将t加入到可见窗口列表\n\t\t\t将t.transform移到同层级（兄弟窗口）的最后一个位置\n\t\t\t设置t可见，执行t的OnShow方法\n\t\t\t计算开启哪个窗口的遮罩\n\t\t\treturn t\n\t\telse \n\t\t\t报错\n\telse\t\t\t\t\t\t\t\t\t//窗口不存在于内存内，需要实例化并重新初始化\n\t\tT t = new T()\n\t\t//生成对应的窗口预制体\n\t\tGameObject UI对象 = 通过窗口名从硬盘内加载预制体\t\t\t//使用Resources，AB包，或使用自己的加载框架皆可\n\t\tif UI对象 != null\n\t\t\t初始化t的各个基础属性，将UI对象及其Canvas和UI摄像机关联到t上，执行t的OnAwake方法\n\t\t\t将窗口对象移到同层级（兄弟窗口）的最后一个位置\n\t\t\t设置t可见，执行t的OnShow方法\n\t\t\t初始化t的RectTransform\n\t\t\t将t加入到字典与列表内\n\t\t\t计算开启哪个窗口的遮罩\n\t\t\treturn t\n\t\telse\n\t\t\t报错\n\treturn null\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240124222217-794vbzh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124222217-794vbzh",
				"updated": "20240125213828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "代码具体实现"
				}
			]
		},
		{
			"ID": "20240124221933-68qotu1",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240124221933-68qotu1",
				"style": "line-height: 22px;",
				"updated": "20240125213828"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#region 弹出窗口相关\n// 弹出一个窗口\npublic T PopUpWindow\u003cT\u003e() where T : WindowBase, new()\n{\n    //获取类名\n    System.Type type = typeof(T);\n    string windowName = type.Name;\n    //尝试通过类名从内存中获取已加载过的WindowBase\n    WindowBase window = GetWindow(windowName);\n    //如果该类已经加载到内存（存在于字典内），直接调用显示方法并返回\n    if (window != null)\n    {\n        return ShowWindow(windowName) as T;\n    }\n    //如果该类未加载（不存在于字典内），也就是第一次弹出，则先创建并初始化再返回\n    T t = new T();\n    return InitializeWindow(t, windowName) as T;\n}\n\nprivate WindowBase InitializeWindow(WindowBase windowBase, string windowName)\n{\n    //生成对应的窗口预制体\n    GameObject newWindowObj = TempLoadWindow(windowName);\n    //初始化对应的管理类\n    if (newWindowObj != null)\n    {\n        //初始化WindowBase各属性成员\n        windowBase.gameObject = newWindowObj;\n        windowBase.transform = newWindowObj.transform;\n        windowBase.Canvas = newWindowObj.GetComponent\u003cCanvas\u003e();\n        windowBase.Canvas.worldCamera = mUICamera;\n        windowBase.Name = newWindowObj.name;\n        //调整该窗口在当前层级的位置\n        windowBase.transform.SetAsLastSibling();\n        //调用OnAwake()生命周期函数，设置其可见，再调用OnShow()\n        windowBase.OnAwake();\n        windowBase.SetVisible(true);\n        windowBase.OnShow();\n        //初始化该窗口的RectTransform，防止位置出现偏差\n        RectTransform rectTrans = newWindowObj.GetComponent\u003cRectTransform\u003e();\n        rectTrans.anchorMax = Vector2.one;\n        rectTrans.offsetMax = Vector2.zero;\n        rectTrans.offsetMin = Vector2.zero;\n        //添加到对应的列表\n        mAllWindowDic.Add(windowName, windowBase);\n        mAllWindowList.Add(windowBase);\n        mVisibleWindowList.Add(windowBase);\n        SetWindowMaskVisible();\n        return windowBase;\n    }\n    Debug.LogError(\"未加载到对应的窗口，窗口名：\" + windowName);\n    return null;\n}\n\n//通过名字显示对应Window方法\nprivate WindowBase ShowWindow(string windowName)\n{\n    WindowBase window = null;\n    //先判断字典是否存在该窗口\n    if (mAllWindowDic.ContainsKey(windowName))\n    {\n        window = mAllWindowDic[windowName];\n        //若窗口存在且不可见，先将窗口加入到可见窗口的列表，将其调整到同层级的最后一个，再调用窗口显示方法\n        if (window.gameObject != null \u0026\u0026 window.Visible == false)\n        {\n            mVisibleWindowList.Add(window);\n            window.transform.SetAsLastSibling();\n            window.SetVisible(true);\n            SetWindowMaskVisible();\n            window.OnShow();\n        }\n        return window;\n    }\n    //若不存在，打印错误信息并返回null\n    else\n        Debug.LogError(windowName + \"：窗口不存在！请调用PopUpWindow进行弹出\");\n    return null;\n}\n\n//从mAllWindowDic内通过名字获取已加载过的WindowBase\nprivate WindowBase GetWindow(string windowName)\n{\n    if (mAllWindowDic.ContainsKey(windowName))\n    {\n        return mAllWindowDic[windowName];\n    }\n    return null;\n}\n#endregion\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240124224156-8x267ds",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20240124224156-8x267ds",
				"updated": "20240125213834"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "b) 资源加载相关"
				}
			]
		},
		{
			"ID": "20240124224512-14rjrhj",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240124224512-14rjrhj",
				"style": "background-color: var(--b3-card-success-background); color: var(--b3-card-success-color);",
				"updated": "20240125213834"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240124224512-7e1rzkt",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240124224512-7e1rzkt",
						"updated": "20240124224549"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "值得一提的是，在初始化方法内，为了教学方便，临时使用"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "Resources"
						},
						{
							"Type": "NodeText",
							"Data": "​的方法来加载预设体\n实际使用时，可以使用自己的加载框架加载，或者使用更好的加载方案，因此，这里将加载预设体的代码封装为一个临时方法，方便未来替换"
						}
					]
				}
			]
		},
		{
			"ID": "20240124225914-sdrvbn6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240124225914-sdrvbn6",
				"updated": "20240125213834"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里"
				},
				{
					"Type": "NodeText",
					"Data": "的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "mWindowConfig.GetWindowPath(windowName)"
				},
				{
					"Type": "NodeText",
					"Data": "​​是通过继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ScriptableObject"
				},
				{
					"Type": "NodeText",
					"Data": "​​的配置文件获取该窗口UI预设体的加载路径\n这部分在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20240109184446-wad9kdb",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "自动化系统"
				},
				{
					"Type": "NodeText",
					"Data": "内讲解"
				}
			]
		},
		{
			"ID": "20240124224207-o7ok790",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240124224207-o7ok790",
				"style": "line-height: 22px;",
				"updated": "20240125213834"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//TODO... 临时资源加载，这里仅仅是因为教程方便而使用Resources加载，如有自己的资源加载框架，或后续学习使用加载框架，此处代码将会修改！\npublic GameObject TempLoadWindow(string windowName)\n{\n    GameObject window = GameObject.Instantiate\u003cGameObject\u003e(Resources.Load\u003cGameObject\u003e(mWindowConfig.GetWindowPath(windowName)), mUIRoot);\n    //window.transform.SetParent(mUIRoot);\n    window.transform.localScale = Vector3.one;\n    window.transform.localPosition = Vector3.zero;\n    window.transform.rotation = Quaternion.identity;\n    window.name = windowName;\n    return window;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125172913-h6c49vb",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20240125172913-h6c49vb",
				"updated": "20240125213843"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "c) 获取窗口"
				}
			]
		},
		{
			"ID": "20240125172924-zgjglwm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125172924-zgjglwm",
				"updated": "20240125213843"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GetWindow"
				},
				{
					"Type": "NodeText",
					"Data": "​有两种重载，一种是内部私有方法，参数为窗口名，一个提供给外部，参数为泛型\n对外接口只能获取显示中的窗口"
				}
			]
		},
		{
			"ID": "20240125173042-51v226l",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125173042-51v226l",
				"style": "line-height: 22px;",
				"updated": "20240125213843"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//从mAllWindowDic内通过名字获取已加载过的WindowBase\nprivate WindowBase GetWindow(string windowName)\n{\n    if (mAllWindowDic.ContainsKey(windowName))\n    {\n        return mAllWindowDic[windowName];\n    }\n    return null;\n}\n\n/// \u003csummary\u003e\n/// 获取已经弹出的窗口\n/// \u003c/summary\u003e\n/// \u003ctypeparam name=\"T\"\u003e要获取的窗口类\u003c/typeparam\u003e\n/// \u003creturns\u003e获取到的窗口类\u003c/returns\u003e\npublic T GetWindow\u003cT\u003e() where T: WindowBase\n{\n    System.Type type = typeof(T);\n    foreach (var window in mVisibleWindowList)\n    {\n        if (window.Name == type.Name)\n        {\n            return (T)window;\n        }\n    }\n    Debug.LogError(\"该窗口未获取到：\" + type.Name);\n    return null;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125173235-9meoqgi",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20240125173235-9meoqgi",
				"updated": "20240125213846"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "d) 隐藏窗口"
				}
			]
		},
		{
			"ID": "20240125173243-z893cnb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125173243-z893cnb",
				"updated": "20240125213846"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "HideWindow"
				},
				{
					"Type": "NodeText",
					"Data": "​有三种重载，内部私有方法的参数为窗口对象，核心逻辑也在这里实现，另外两个提供给外部，参数为泛型或窗口名\n隐藏窗口会触发窗口的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "OnHide()"
				},
				{
					"Type": "NodeText",
					"Data": "​方法\n隐藏窗口让"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20240108182335-g9zaaa9",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "遮罩系统"
				},
				{
					"Type": "NodeText",
					"Data": "重新计算单遮，如果还是通过"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20240123224808-br9y38i",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "堆栈系统"
				},
				{
					"Type": "NodeText",
					"Data": "弹出的窗口，堆栈系统将会弹出队列中的下一个窗口 "
				}
			]
		},
		{
			"ID": "20240125173417-jw4e2nj",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125173417-jw4e2nj",
				"style": "line-height: 22px;",
				"updated": "20240125213846"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#region 隐藏窗口相关\n/// \u003csummary\u003e\n/// 隐藏窗口\n/// \u003c/summary\u003e\n/// \u003ctypeparam name=\"T\"\u003e要隐藏的窗口类\u003c/typeparam\u003e\n// 这个重载函数作为对外调用接口使用\npublic void HideWindow\u003cT\u003e() where T : WindowBase\n{\n    HideWindow(typeof(T).Name);\n}\n\n//这个重载函数的作用是将通过传入的窗口名从字典中获取窗口\npublic void HideWindow(string windowName)\n{\n    WindowBase window = GetWindow(windowName);\n    HideWindow(window);\n}\n\n//这个重载函数的作用是判断窗口是否符合条件再执行隐藏逻辑\nprivate void HideWindow(WindowBase window)\n{\n    //若Window不为空且可见，就执行隐藏逻辑\n    if (window != null \u0026\u0026 window.Visible)\n    {\n        mVisibleWindowList.Remove(window);\n        window.SetVisible(false);           //隐藏弹窗对象\n        SetWindowMaskVisible();\n        window.OnHide();                    //执行生命周期函数\n    }\n    PopNextStackWindow(window);             //如果处于出栈的情况下，上一个界面隐藏时，自动打开栈中的下一个界面\n}\n#endregion\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240125212757-op4xeta",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20240125212757-op4xeta",
				"updated": "20240125213850"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "e) 销毁窗口"
				}
			]
		},
		{
			"ID": "20240125212811-gybwscr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125212811-gybwscr",
				"updated": "20240125213850"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "DesttoyWindow"
				},
				{
					"Type": "NodeText",
					"Data": "​有三种重载，内部私有方法的参数为窗口对象，核心逻辑也在这里实现，另外一个提供给外部，参数为泛型\n销毁窗口会触发窗口的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "OnHide()"
				},
				{
					"Type": "NodeText",
					"Data": "​和"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "OnDestory()"
				},
				{
					"Type": "NodeText",
					"Data": "​方法\n销毁窗口让"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20240108182335-g9zaaa9",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "遮罩系统"
				},
				{
					"Type": "NodeText",
					"Data": "重新计算单遮，如果还是通过"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20240123224808-br9y38i",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "堆栈系统"
				},
				{
					"Type": "NodeText",
					"Data": "弹出的窗口，堆栈系统将会弹出队列中的下一个窗口"
				}
			]
		},
		{
			"ID": "20240125212948-ftcjxgs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240125212948-ftcjxgs",
				"updated": "20240125213850"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "销毁窗口还有一个销毁全部弹窗的方法，用于过场景时是否内存"
				}
			]
		},
		{
			"ID": "20240125212932-x6sj3kz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240125212932-x6sj3kz",
				"style": "line-height: 22px;",
				"updated": "20240125213850"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#region 销毁窗口相关\n/// \u003csummary\u003e\n/// 销毁窗口\n/// \u003c/summary\u003e\n/// \u003ctypeparam name=\"T\"\u003e要销毁的窗口的方法\u003c/typeparam\u003e\n// 这个重载函数作为对外调用接口使用\npublic void DestroyWindow\u003cT\u003e() where T : WindowBase\n{\n    DestroyWindow(typeof(T).Name);\n}\n\n//这个重载函数的作用是将通过传入的窗口名从字典中获取窗口\nprivate void DestroyWindow(string windowName)\n{\n    WindowBase window = GetWindow(windowName);\n    DestroyWindow(window);\n}\n\n//这个重载函数的作用是执行销毁逻辑\nprivate void DestroyWindow(WindowBase window)\n{\n    if (window != null)\n    {\n        if (mAllWindowDic.ContainsKey(window.Name))\n        {\n            mAllWindowDic.Remove(window.Name);\n            mAllWindowList.Remove(window);\n            mVisibleWindowList.Remove(window);\n        }\n        window.SetVisible(false);\n        SetWindowMaskVisible();\n        window.OnHide();\n        window.OnDestroy();\n        GameObject.Destroy(window.gameObject);\n        PopNextStackWindow(window);             //如果处于出栈的情况下，上一个界面隐藏时，自动打开栈中的下一个界\n    }\n}\n\n/// \u003csummary\u003e\n/// 销毁所有弹窗，并释放内存\n/// \u003c/summary\u003e\n/// \u003cparam name=\"filterlist\"\u003e过滤列表\u003c/param\u003e\npublic void DestroyAllWindow(List\u003cstring\u003e filterlist = null)\n{\n    //使用反向for循环来销毁弹窗，从最后一个开始销毁，防止越界\n    for (int i = mAllWindowList.Count - 1; i \u003e= 0; i--)\n    {\n        WindowBase window = mAllWindowList[i];\n        if (window == null || (filterlist != null \u0026\u0026 filterlist.Contains(window.Name)))\n        {\n            continue;\n        }\n        DestroyWindow(window.Name);\n    }\n    Resources.UnloadUnusedAssets();\n}\n#endregion\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240124213658-1gl71n4",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240124213658-1gl71n4",
				"updated": "20240124224135"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "UIModule代码"
				}
			]
		},
		{
			"ID": "20240124212254-81oh48e",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240124212254-81oh48e",
				"style": "line-height: 22px;",
				"updated": "20240124224135"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class UIModule\n{\n    private static UIModule _instance;\n    public static UIModule Instance\n    {\n        get\n        {\n            if (_instance == null)\n            {\n                _instance = new UIModule();\n            }\n            return _instance;\n        }\n    }\n\n    private Camera mUICamera;               //场景上的UI摄像机\n    private Transform mUIRoot;              //场景上的UI根节点\n    private WindowConfig mWindowConfig;     //窗口读取路径配置文件\n\n    private Dictionary\u003cstring, WindowBase\u003e mAllWindowDic = new Dictionary\u003cstring, WindowBase\u003e();    //所有窗口的字典\n    private List\u003cWindowBase\u003e mAllWindowList = new List\u003cWindowBase\u003e();                               //所有窗口的列表\n    private List\u003cWindowBase\u003e mVisibleWindowList = new List\u003cWindowBase\u003e();                           //所有可见窗口的列表\n\n    private Queue\u003cWindowBase\u003e mWindowStack = new Queue\u003cWindowBase\u003e();   //堆栈系统的队列，用来管理弹窗的循环弹出\n    private bool mStartPopStackWindowStatus = false;                    //开始弹出堆栈的标志，用于处理多种情况，例如：正在出栈中有其他界面弹出，可以直接放到栈内进行弹出等\n\n\n    //初始化方法 \n    public void Initialize()\n    {\n        //获取场景上的UI摄像机和UI根节点\n        mUICamera = GameObject.Find(\"UICamera\").GetComponent\u003cCamera\u003e();\n        mUIRoot = GameObject.Find(\"UIRoot\").transform;\n        mWindowConfig = Resources.Load\u003cWindowConfig\u003e(\"WindowConfig\");\n        //打包出去后不会触发调用\n#if UNITY_EDITOR\n        mWindowConfig.GeneratorWindowConfig();\n#endif\n    }\n\n    #region 窗口管理相关\n\n    #region 预加载相关\n    /// \u003csummary\u003e\n    /// 预加载窗口，只加载物体，而不调用生命周期，也不显示它\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e\n    public void PreLoadWindow\u003cT\u003e() where T : WindowBase, new()\n    {\n        //获取类名\n        System.Type type = typeof(T);\n        string windowName = type.Name;\n        T windowBase = new T();\n        //加载对应的窗口预制体\n        GameObject newWindowObj = TempLoadWindow(windowName);\n        //初始化对应的管理类，直接加入到队列及字典内，而不进行排序以及生命周期的调用等\n        if (newWindowObj != null)\n        {\n            //初始化WindowBase各属性成员\n            windowBase.gameObject = newWindowObj;\n            windowBase.transform = newWindowObj.transform;\n            windowBase.Canvas = newWindowObj.GetComponent\u003cCanvas\u003e();\n            windowBase.Canvas.worldCamera = mUICamera;\n            windowBase.Name = newWindowObj.name;\n            windowBase.OnAwake();\n            windowBase.SetVisible(false);\n            //初始化该窗口的RectTransform，防止位置出现偏差\n            RectTransform rectTrans = newWindowObj.GetComponent\u003cRectTransform\u003e();\n            rectTrans.anchorMax = Vector2.one;\n            rectTrans.offsetMax = Vector2.zero;\n            rectTrans.offsetMin = Vector2.zero;\n            //添加到对应的列表\n            mAllWindowDic.Add(windowName, windowBase);\n            mAllWindowList.Add(windowBase);\n        }\n        Debug.Log($\"预加载窗口：{windowName}\");\n    }\n    #endregion\n\n    #region 弹出窗口相关\n    /// \u003csummary\u003e\n    /// 弹出一个窗口\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e弹出窗口的对应的WindowBase类\u003c/typeparam\u003e\n    /// \u003creturns\u003e弹出窗口对应的WindowBase类\u003c/returns\u003e\n    public T PopUpWindow\u003cT\u003e() where T : WindowBase, new()\n    {\n        //获取类名\n        System.Type type = typeof(T);\n        string windowName = type.Name;\n        //尝试通过类名从内存中获取已加载过的WindowBase\n        WindowBase window = GetWindow(windowName);\n        //如果该类已经加载到内存（存在于字典内），直接调用显示方法并返回\n        if (window != null)\n        {\n            return ShowWindow(windowName) as T;\n        }\n        //如果该类未加载（不存在于字典内），也就是第一次弹出，则先创建并初始化再返回\n        T t = new T();\n        return InitializeWindow(t, windowName) as T;\n    }\n\n    //堆栈系统专用弹出窗口方法，传入从堆栈系统弹出的WindowBase\n    private WindowBase PopUpWindow(WindowBase QueuePopWindow)\n    {\n        System.Type type = QueuePopWindow.GetType();\n        string windowName = type.Name;\n        //先确认是否加载过Window，若加载过，直接返回加载过的Window\n        WindowBase LoadedWindow = GetWindow(windowName);\n        if (LoadedWindow != null)\n        {\n            return ShowWindow(windowName);\n        }\n        //若未加载，则将弹出的WindowBase用于初始化\n        return InitializeWindow(QueuePopWindow, windowName);\n    }\n\n    private WindowBase InitializeWindow(WindowBase windowBase, string windowName)\n    {\n        //生成对应的窗口预制体\n        GameObject newWindowObj = TempLoadWindow(windowName);\n        //初始化对应的管理类\n        if (newWindowObj != null)\n        {\n            //初始化WindowBase各属性成员\n            windowBase.gameObject = newWindowObj;\n            windowBase.transform = newWindowObj.transform;\n            windowBase.Canvas = newWindowObj.GetComponent\u003cCanvas\u003e();\n            windowBase.Canvas.worldCamera = mUICamera;\n            windowBase.Name = newWindowObj.name;\n            //调整该窗口在当前层级的位置\n            windowBase.transform.SetAsLastSibling();\n            //调用OnAwake()生命周期函数，设置其可见，再调用OnShow()\n            windowBase.OnAwake();\n            windowBase.SetVisible(true);\n            windowBase.OnShow();\n            //初始化该窗口的RectTransform，防止位置出现偏差\n            RectTransform rectTrans = newWindowObj.GetComponent\u003cRectTransform\u003e();\n            rectTrans.anchorMax = Vector2.one;\n            rectTrans.offsetMax = Vector2.zero;\n            rectTrans.offsetMin = Vector2.zero;\n            //添加到对应的列表\n            mAllWindowDic.Add(windowName, windowBase);\n            mAllWindowList.Add(windowBase);\n            mVisibleWindowList.Add(windowBase);\n            SetWindowMaskVisible();\n            return windowBase;\n        }\n        Debug.LogError(\"未加载到对应的窗口，窗口名：\" + windowName);\n        return null;\n    }\n\n    //通过名字显示对应Window方法\n    private WindowBase ShowWindow(string windowName)\n    {\n        WindowBase window = null;\n        //先判断字典是否存在该窗口\n        if (mAllWindowDic.ContainsKey(windowName))\n        {\n            window = mAllWindowDic[windowName];\n            //若窗口存在且不可见，先将窗口加入到可见窗口的列表，将其调整到同层级的最后一个，再调用窗口显示方法，执行OnShow()\n            if (window.gameObject != null \u0026\u0026 window.Visible == false)\n            {\n                mVisibleWindowList.Add(window);\n                window.transform.SetAsLastSibling();\n                window.SetVisible(true);\n                SetWindowMaskVisible();\n                window.OnShow();\n            }\n            return window;\n        }\n        //若不存在，打印错误信息并返回null\n        else\n            Debug.LogError(windowName + \"：窗口不存在！请调用PopUpWindow进行弹出\");\n        return null;\n    }\n\n    //从mAllWindowDic内通过名字获取已加载过的WindowBase\n    private WindowBase GetWindow(string windowName)\n    {\n        if (mAllWindowDic.ContainsKey(windowName))\n        {\n            return mAllWindowDic[windowName];\n        }\n        return null;\n    }\n    #endregion\n\n    #region 获取窗口相关\n\n    /// \u003csummary\u003e\n    /// 获取已经弹出的窗口\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e要获取的窗口类\u003c/typeparam\u003e\n    /// \u003creturns\u003e获取到的窗口类\u003c/returns\u003e\n    public T GetWindow\u003cT\u003e() where T: WindowBase\n    {\n        System.Type type = typeof(T);\n        foreach (var window in mVisibleWindowList)\n        {\n            if (window.Name == type.Name)\n            {\n                return (T)window;\n            }\n        }\n        Debug.LogError(\"该窗口未获取到：\" + type.Name);\n        return null;\n    }\n    #endregion\n\n    #region 隐藏窗口相关\n    /// \u003csummary\u003e\n    /// 隐藏窗口\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e要隐藏的窗口类\u003c/typeparam\u003e\n    // 这个重载函数作为对外调用接口使用\n    public void HideWindow\u003cT\u003e() where T : WindowBase\n    {\n        HideWindow(typeof(T).Name);\n    }\n\n    //这个重载函数的作用是将通过传入的窗口名从字典中获取窗口\n    public void HideWindow(string windowName)\n    {\n        WindowBase window = GetWindow(windowName);\n        HideWindow(window);\n    }\n\n    //这个重载函数的作用是判断窗口是否符合条件再执行隐藏逻辑\n    private void HideWindow(WindowBase window)\n    {\n        //若Window不为空且可见，就执行隐藏逻辑\n        if (window != null \u0026\u0026 window.Visible)\n        {\n            mVisibleWindowList.Remove(window);\n            window.SetVisible(false);           //隐藏弹窗对象\n            SetWindowMaskVisible();\n            window.OnHide();                    //执行生命周期函数\n        }\n        PopNextStackWindow(window);             //如果处于出栈的情况下，上一个界面隐藏时，自动打开栈中的下一个界面\n    }\n    #endregion\n\n    #region 销毁窗口相关\n    /// \u003csummary\u003e\n    /// 销毁窗口\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e要销毁的窗口的方法\u003c/typeparam\u003e\n    // 这个重载函数作为对外调用接口使用\n    public void DestroyWindow\u003cT\u003e() where T : WindowBase\n    {\n        DestroyWindow(typeof(T).Name);\n    }\n\n    //这个重载函数的作用是将通过传入的窗口名从字典中获取窗口\n    private void DestroyWindow(string windowName)\n    {\n        WindowBase window = GetWindow(windowName);\n        DestroyWindow(window);\n    }\n\n    //这个重载函数的作用是执行销毁逻辑\n    private void DestroyWindow(WindowBase window)\n    {\n        if (window != null)\n        {\n            if (mAllWindowDic.ContainsKey(window.Name))\n            {\n                mAllWindowDic.Remove(window.Name);\n                mAllWindowList.Remove(window);\n                mVisibleWindowList.Remove(window);\n            }\n            window.SetVisible(false);\n            SetWindowMaskVisible();\n            window.OnHide();\n            window.OnDestroy();\n            GameObject.Destroy(window.gameObject);\n            PopNextStackWindow(window);             //如果处于出栈的情况下，上一个界面隐藏时，自动打开栈中的下一个界面\n        }\n    }\n  \n    /// \u003csummary\u003e\n    /// 销毁所有弹窗，并释放内存\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"filterlist\"\u003e过滤列表\u003c/param\u003e\n    public void DestroyAllWindow(List\u003cstring\u003e filterlist = null)\n    {\n        //使用反向for循环来销毁弹窗，从最后一个开始销毁，防止越界\n        for (int i = mAllWindowList.Count - 1; i \u003e= 0; i--)\n        {\n            WindowBase window = mAllWindowList[i];\n            if (window == null || (filterlist != null \u0026\u0026 filterlist.Contains(window.Name)))\n            {\n                continue;\n            }\n            DestroyWindow(window.Name);\n        }\n        Resources.UnloadUnusedAssets();\n    }\n    #endregion\n\n    #endregion\n\n    #region 控制遮罩相关\n    //单遮模式下，设置窗口遮罩\n    private void SetWindowMaskVisible()\n    {\n        //如果未开启单遮模式，则直接返回\n        if (!UISetting.Instance.SINGMASK_SYSTEM) return;\n        WindowBase maxOrderWindowBase = null;   //渲染层级最大的窗口\n        int maxOrder = 0;                       //渲染层级最大窗口的渲染层级\n        int maxIndex = 0;                       //最大排序下标，在相同父节点下的位置下标\n        //1. 关闭所有窗口的Mask，设置为不可见\n        //2. 从所有可见窗口中，找到一个层级最大的窗口，设置Mask为可见\n        for (int i = 0; i \u003c mVisibleWindowList.Count; i++)\n        {\n            WindowBase window = mVisibleWindowList[i];\n            //当窗口管理类不为空且游戏对象不为空时\n            if (window != null \u0026\u0026 window.gameObject != null)\n            {\n                //先关闭遮罩\n                window.SetMaskVisible(false);\n                if (maxOrderWindowBase == null)\n                {\n                    maxOrderWindowBase = window;\n                    maxOrder = window.Canvas.sortingOrder;\n                    maxIndex = window.transform.GetSiblingIndex();\n                }\n                else\n                {\n                    //找到最大渲染层级的窗口，获取它\n                    if (maxOrder \u003c window.Canvas.sortingOrder)\n                    {\n                        maxOrderWindowBase = window;\n                        maxOrder = window.Canvas.sortingOrder;\n                    }\n                    //如果两个窗口的渲染层级相同，就找到同节点下最靠下的物体，优先渲染这个最靠下的Mask\n                    else if (maxOrder == window.Canvas.sortingOrder \u0026\u0026 maxIndex \u003c window.transform.GetSiblingIndex())\n                    {\n                        maxOrderWindowBase = window;\n                        maxIndex = window.transform.GetSiblingIndex();\n                    }\n                }\n            }\n        }\n        //遍历完所有窗口后，得到层级最大且同节点最靠下的窗口，只开启这一个最大的窗口即可\n        maxOrderWindowBase?.SetMaskVisible(true);\n    }\n    #endregion\n\n    //TODO... 临时资源加载，这里仅仅是因为教程方便而使用Resources加载，如有自己的资源加载框架，或后续学习使用加载框架，此处代码将会修改！\n    public GameObject TempLoadWindow(string windowName)\n    {\n        GameObject window = GameObject.Instantiate\u003cGameObject\u003e(Resources.Load\u003cGameObject\u003e(mWindowConfig.GetWindowPath(windowName)), mUIRoot);\n        //window.transform.SetParent(mUIRoot);\n        window.transform.localScale = Vector3.one;\n        window.transform.localPosition = Vector3.zero;\n        window.transform.rotation = Quaternion.identity;\n        window.name = windowName;\n        return window;\n    }\n\n    #region 堆栈系统相关\n    /// \u003csummary\u003e\n    /// 向堆栈压入一个界面\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e要压入的窗口\u003c/typeparam\u003e\n    /// \u003cparam name=\"popCallBack\"\u003e出栈时要执行的监听函数\u003c/param\u003e\n    public void PushWindowToStack\u003cT\u003e(Action\u003cWindowBase\u003e popCallBack = null) where T : WindowBase, new()\n    {\n        //这里的new出来的T暂时用于在队列内记录监听函数，\n        //后续出栈显示窗口时，若T已经加载过，则这里的监听函数将赋值给已经加载过的T，若未加载过再使用该T用于初始化\n        T windowBase = new T();\n        windowBase.PopStackListener = popCallBack;\n        mWindowStack.Enqueue(windowBase);\n    }\n\n    /// \u003csummary\u003e\n    /// 弹出堆栈中第一个弹窗\n    /// \u003c/summary\u003e\n    public void StartPopFirstStackWindow()\n    {\n        if (mStartPopStackWindowStatus) return;\n        mStartPopStackWindowStatus = true;      //表示已经开始进行堆栈弹出的流程\n        PopStackWindow();\n    }\n\n    /// \u003csummary\u003e\n    /// 压入并直接开始弹出堆栈弹窗\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e要压入的窗口\u003c/typeparam\u003e\n    /// \u003cparam name=\"popCallBack\"\u003e出栈时要执行的监听函数\u003c/param\u003e\n    public void PushAndPopStackWindow\u003cT\u003e(Action\u003cWindowBase\u003e popCallBack = null) where T : WindowBase, new()\n    {\n        PushWindowToStack\u003cT\u003e(popCallBack);\n        StartPopFirstStackWindow();\n    }\n\n    /// \u003csummary\u003e\n    /// 弹出下一个窗口\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"windowBase\"\u003e\u003c/param\u003e\n    private void PopNextStackWindow(WindowBase windowBase)\n    {\n        if (windowBase != null \u0026\u0026 mStartPopStackWindowStatus \u0026\u0026 windowBase.PopStack)\n        {\n            windowBase.PopStack = false;\n            PopStackWindow();\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 弹出堆栈弹窗\n    /// \u003c/summary\u003e\n    /// \u003creturns\u003e是否从堆栈里弹出窗口\u003c/returns\u003e\n    public bool PopStackWindow()\n    {\n        if (mWindowStack.Count \u003e 0)\n        {\n            WindowBase recordWindow = mWindowStack.Dequeue();\n            WindowBase popWindow = PopUpWindow(recordWindow);\n            popWindow.PopStackListener = recordWindow.PopStackListener;\n            popWindow.PopStack = true;              //表示是从堆栈系统里打开的窗口，关闭该窗口将重新执行这里的方法\n            popWindow.PopStackListener?.Invoke(popWindow);\n            popWindow.PopStackListener = null;\n            return true;\n        }\n        else\n        {\n            mStartPopStackWindowStatus = false;     //表示堆栈弹出的流程结束\n            return false;\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 清空窗口堆栈，可用于中途取消堆栈弹出流程\n    /// \u003c/summary\u003e\n    public void ClearStackWindows()\n    {\n        mWindowStack.Clear();\n    }\n    #endregion\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}