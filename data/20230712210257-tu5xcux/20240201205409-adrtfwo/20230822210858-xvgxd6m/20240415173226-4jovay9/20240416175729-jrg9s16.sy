{
	"ID": "20240416175729-jrg9s16",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20240416175729-jrg9s16",
		"title": "UFL3-1——Hierarchy窗口布局优化",
		"type": "doc",
		"updated": "20240416221517"
	},
	"Children": [
		{
			"ID": "20240416175754-avg591d",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240416175754-avg591d",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "窗口布局优化指的是什么"
				}
			]
		},
		{
			"ID": "20240416175754-2vgz4yo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240416175754-2vgz4yo",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在直接失活对象，当之后项目做大了，抽屉多了，对象多了\n游戏中成百上千个对象，在开发测试时不方便从Hierarchy窗口中查看对象获取信息"
				}
			]
		},
		{
			"ID": "20240416175754-rlofb9o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240416175754-rlofb9o",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240415222028-hby2vgn.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240416175754-14xxnd8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240416175754-14xxnd8",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可见，目前创建出来的对象都是直接排布在场景上而没有做优化，因此我们希望能优化一下Hierarchy窗口中的布局，将对象和抽屉的关系可视化"
				}
			]
		},
		{
			"ID": "20240416175754-z5hbotc",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240416175754-z5hbotc",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "制作思路和具体实现"
				}
			]
		},
		{
			"ID": "20240416175754-m1vou79",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240416175754-m1vou79",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"ID": "20240416175754-90e7m5s",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240416175754-90e7m5s",
						"updated": "20240416175754"
					},
					"Children": [
						{
							"ID": "20240416175754-2o16so8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240416175754-2o16so8",
								"updated": "20240416175754"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "制作思路："
								}
							]
						},
						{
							"ID": "20240416175754-umftqe3",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20240416175754-umftqe3",
								"updated": "20240416175754"
							},
							"Children": [
								{
									"ID": "20240416175754-5wl7u2y",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20240416175754-5wl7u2y",
										"updated": "20240416175754"
									},
									"Children": [
										{
											"ID": "20240416175754-7tgly5z",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-7tgly5z",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "柜子管理自己的柜子根物体 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Pool"
												},
												{
													"Type": "NodeText",
													"Data": "​"
												}
											]
										}
									]
								},
								{
									"ID": "20240416175754-6noy7pl",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20240416175754-6noy7pl",
										"updated": "20240416175754"
									},
									"Children": [
										{
											"ID": "20240416175754-jquw861",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-jquw861",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "抽屉管理自己的抽屉根物体"
												}
											]
										}
									]
								},
								{
									"ID": "20240416175754-6tt47fi",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "My4=",
										"Num": 3
									},
									"Properties": {
										"id": "20240416175754-6tt47fi",
										"updated": "20240416175754"
									},
									"Children": [
										{
											"ID": "20240416175754-m61x8zy",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-m61x8zy",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "失活时建立父子关系，激活活时断开父子关系"
												}
											]
										}
									]
								}
							]
						},
						{
							"ID": "20240416175754-qsmmtvs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240416175754-qsmmtvs",
								"updated": "20240416175754"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "要实现的效果如下"
								}
							]
						},
						{
							"ID": "20240416175754-10jizaz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240416175754-10jizaz",
								"updated": "20240416175754"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeImage",
									"Data": "span",
									"Properties": {
										"parent-style": "width: 267px;",
										"style": "width: 257px;"
									},
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText",
											"Data": "image"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "assets/image-20240415222600-pug72h1.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeKramdownSpanIAL",
									"Data": "{: style=\"width: 257px;\" parent-style=\"width: 267px;\"}"
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						}
					]
				},
				{
					"ID": "20240416175754-9bc7yh2",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240416175754-9bc7yh2",
						"updated": "20240416175754"
					},
					"Children": [
						{
							"ID": "20240416175754-9wm427h",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240416175754-9wm427h",
								"updated": "20240416175754"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "具体实现："
								}
							]
						},
						{
							"ID": "20240416175754-sisbeag",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20240416175754-sisbeag",
								"updated": "20240416175754"
							},
							"Children": [
								{
									"ID": "20240416175754-sjeec7w",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20240416175754-sjeec7w",
										"updated": "20240416175754"
									},
									"Children": [
										{
											"ID": "20240416175754-kdg70op",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-kdg70op",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "先实现将所有对象放入柜子根物体中"
												}
											]
										},
										{
											"ID": "20240416175754-j9y0s4d",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-j9y0s4d",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "先声明在缓存池类中声明柜子根物体对象的变量 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "poolObj"
												},
												{
													"Type": "NodeText",
													"Data": "​，与场景上的"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Pool"
												},
												{
													"Type": "NodeText",
													"Data": "​对象关联起来\n当调用 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "PushObj"
												},
												{
													"Type": "NodeText",
													"Data": "​ 而柜子根物体"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Pool"
												},
												{
													"Type": "NodeText",
													"Data": "​对象不存在于场景的时候，创建这个"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Pool"
												},
												{
													"Type": "NodeText",
													"Data": "​对象\n然后，所有要压入池子内的对象都作为"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Pool"
												},
												{
													"Type": "NodeText",
													"Data": "​对象的子物体"
												}
											]
										},
										{
											"ID": "20240416175754-vvjx2gf",
											"Type": "NodeCodeBlock",
											"IsFencedCodeBlock": true,
											"Properties": {
												"id": "20240416175754-vvjx2gf",
												"style": "line-height: 22px;",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeCodeBlockFenceOpenMarker",
													"Data": "```"
												},
												{
													"Type": "NodeCodeBlockFenceInfoMarker",
													"CodeBlockInfo": "YyM="
												},
												{
													"Type": "NodeCodeBlockCode",
													"Data": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n/// \u003csummary\u003e\n/// 缓存池模块 管理器\n/// \u003c/summary\u003e\npublic class PoolManager : BaseManager\u003cPoolManager\u003e\n{\n    //柜子容器当中有抽屉的体现\n    private Dictionary\u003cstring, Stack\u003cGameObject\u003e\u003e poolDic = new Dictionary\u003cstring, Stack\u003cGameObject\u003e\u003e();\n\n    //池子根对象\n    private GameObject poolObj;\n\n    private PoolManager() { }\n\n    /// \u003csummary\u003e\n    /// 拿东西的方法\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"name\"\u003e抽屉容器的名字\u003c/param\u003e\n    /// \u003creturns\u003e从缓存池中取出的对象\u003c/returns\u003e\n    public GameObject GetObj(string name)\n    {\n        GameObject obj;\n        //有抽屉，且抽屉内有对象\n        if (poolDic.ContainsKey(name) \u0026\u0026 poolDic[name].Count \u003e 0)\n        {\n            obj = poolDic[name].Pop();\n            obj.SetActive(true);\n            //取出时，断开父子关系\n            obj.transform.SetParent(null);\n        }\n        //否则，就应该去创建对象\n        else\n        {\n            obj = GameObject.Instantiate(Resources.Load\u003cGameObject\u003e(name));\n            //为了避免实例化出来的对象默认名字带一个\"(clone)\"，我们需要重命名这个对象\n            obj.name = name;\n        }\n        return obj;\n    }\n\n    /// \u003csummary\u003e\n    /// 往缓存池中放入对象\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"name\"\u003e抽屉（对象池）的名字\u003c/param\u003e\n    /// \u003cparam name=\"obj\"\u003e要放入的对象\u003c/param\u003e\n    public void PushObj(GameObject obj)\n    {\n        //如果根物体为空，就创建\n        if (poolObj == null)\n            poolObj = new GameObject(\"Pool\");\n\n        //并不是直接移除对象，而是将对象失活一会再用，用的时候再激活它\n        //除了失活对象，还可以通过把对象放到很远的地方等方式来隐藏对象（失活的性能可能偏低一些）\n        obj.SetActive(false);\n        //把失活的对象（要放入抽屉中的对象），如对象\n        obj.transform.SetParent(poolObj.transform);\n        //如果不存在对应的抽屉容器，先创建抽屉，再往抽屉内放\n        if (!poolDic.ContainsKey(obj.name))\n            poolDic.Add(obj.name, new Stack\u003cGameObject\u003e());\n        poolDic[obj.name].Push(obj);\n    }\n\n    /// \u003csummary\u003e\n    /// 清除整个柜子当中的数据\n    /// \u003c/summary\u003e\n    public void ClearPool()\n    {\n        poolDic.Clear();\n        poolObj = null;\n    }\n}\n"
												},
												{
													"Type": "NodeCodeBlockFenceCloseMarker",
													"Data": "```"
												}
											]
										},
										{
											"ID": "20240416175754-bbi9gvc",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-bbi9gvc",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "按照之前的测试方法再次测试，得到的Hierarchy窗口布局如下"
												}
											]
										},
										{
											"ID": "20240416175754-4s09544",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-4s09544",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeImage",
													"Data": "span",
													"Children": [
														{
															"Type": "NodeBang"
														},
														{
															"Type": "NodeOpenBracket"
														},
														{
															"Type": "NodeLinkText",
															"Data": "image"
														},
														{
															"Type": "NodeCloseBracket"
														},
														{
															"Type": "NodeOpenParen"
														},
														{
															"Type": "NodeLinkDest",
															"Data": "assets/image-20240415223929-fvnhxfs.png"
														},
														{
															"Type": "NodeCloseParen"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "​"
												}
											]
										}
									]
								},
								{
									"ID": "20240416175754-ufljjo8",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20240416175754-ufljjo8",
										"updated": "20240416175754"
									},
									"Children": [
										{
											"ID": "20240416175754-urnba8n",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-urnba8n",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "再实现将对象放入对应的抽屉根物体中，用面向对象的思想将抽屉相关数据行为封装起来"
												}
											]
										},
										{
											"ID": "20240416175754-9qelep5",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-9qelep5",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "新声明一个"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "PoolData"
												},
												{
													"Type": "NodeText",
													"Data": "​类，代表具体存储某一种对象的抽屉，该类包括具体的抽屉父对象，存储对象的池子（栈），以及获取池子内对象数量的属性\n实例化该类的时候需要传入池子根对象，存储的对象的名字，以方便"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "strong",
													"TextMarkTextContent": "设置抽屉对象的名字，并将池子根对象对象作为抽屉对象的父对象"
												}
											]
										},
										{
											"ID": "20240416175754-c0cc5a4",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-c0cc5a4",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "该类为存储对象的池子（栈）的对象，封装存入"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Push"
												},
												{
													"Type": "NodeText",
													"Data": "​和取出"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Pop"
												},
												{
													"Type": "NodeText",
													"Data": "​的方法，存入或取出时要执行一些必备的处理，例如激活，或者父子对象设置等等"
												}
											]
										},
										{
											"ID": "20240416175754-tyas043",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-tyas043",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "其中，要存入到池子内的对象，"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "strong",
													"TextMarkTextContent": "存入前就可以将"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code strong",
													"TextMarkTextContent": "PoolData"
												},
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "strong",
													"TextMarkTextContent": "类对应的抽屉父对象作为自己的父对象"
												}
											]
										},
										{
											"ID": "20240416175754-662dud4",
											"Type": "NodeCodeBlock",
											"IsFencedCodeBlock": true,
											"Properties": {
												"id": "20240416175754-662dud4",
												"style": "line-height: 22px;",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeCodeBlockFenceOpenMarker",
													"Data": "```"
												},
												{
													"Type": "NodeCodeBlockFenceInfoMarker",
													"CodeBlockInfo": "YyM="
												},
												{
													"Type": "NodeCodeBlockCode",
													"Data": "public class PoolData\n{\n    //抽屉根对象，用来就行布局管理的对象\n    private GameObject poolObj;\n    //用来存储抽屉中的对象\n    private Stack\u003cGameObject\u003e dataStack = new Stack\u003cGameObject\u003e();\n    //获取容器中是否有对象\n    public int Count =\u003e dataStack.Count;\n\n    public PoolData(GameObject poolRootObj, string poolName) \n    {\n        //创建抽屉父对象，和柜子父对象建立父子关系\n        poolObj = new GameObject(poolName);\n        poolObj.transform.SetParent(poolRootObj.transform);\n    }\n\n    /// \u003csummary\u003e\n    /// 从抽屉中弹出数据对象\n    /// \u003c/summary\u003e\n    /// \u003creturns\u003e弹出的数据对象\u003c/returns\u003e\n    public GameObject Pop()\n    {\n        //从抽屉内取出并激活对象，再断开父子关系\n        GameObject obj = dataStack.Pop();\n        obj.SetActive(true);\n        obj.transform.SetParent(null);\n        return obj;\n    }\n\n    /// \u003csummary\u003e\n    /// 将数据压入到抽屉内\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"obj\"\u003e压入到抽屉内\u003c/param\u003e\n    public void Push(GameObject obj)\n    {\n        //失活后放入将抽屉根对象作为父对象，然后压入到抽屉内\n        obj.SetActive(false);\n        obj.transform.SetParent(poolObj.transform);\n        dataStack.Push(obj);\n    }\n}\n"
												},
												{
													"Type": "NodeCodeBlockFenceCloseMarker",
													"Data": "```"
												}
											]
										},
										{
											"ID": "20240416175754-e7wxcaq",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-e7wxcaq",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "由于"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "PoolData"
												},
												{
													"Type": "NodeText",
													"Data": "​类内封装的存入"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Push"
												},
												{
													"Type": "NodeText",
													"Data": "​和取出"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Pop"
												},
												{
													"Type": "NodeText",
													"Data": "​的方法已经做好了例如激活，或者父子对象设置等等处理\n因此除了"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "PoolManager"
												},
												{
													"Type": "NodeText",
													"Data": "​对象池字典内的值改为"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "PoolData"
												},
												{
													"Type": "NodeText",
													"Data": "​类，诸如存入"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Push"
												},
												{
													"Type": "NodeText",
													"Data": "​和取出"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Pop"
												},
												{
													"Type": "NodeText",
													"Data": "​的方法不再需要实现激活，或者父子对象设置等等逻辑"
												}
											]
										},
										{
											"ID": "20240416175754-h0a5xo4",
											"Type": "NodeCodeBlock",
											"IsFencedCodeBlock": true,
											"Properties": {
												"id": "20240416175754-h0a5xo4",
												"style": "line-height: 22px;",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeCodeBlockFenceOpenMarker",
													"Data": "```"
												},
												{
													"Type": "NodeCodeBlockFenceInfoMarker",
													"CodeBlockInfo": "YyM="
												},
												{
													"Type": "NodeCodeBlockCode",
													"Data": "/// \u003csummary\u003e\n/// 缓存池模块 管理器\n/// \u003c/summary\u003e\npublic class PoolManager : BaseManager\u003cPoolManager\u003e\n{\n    //柜子容器当中有抽屉的体现\n    private Dictionary\u003cstring, PoolData\u003e poolDic = new Dictionary\u003cstring, PoolData\u003e();\n\n    //池子根对象\n    private GameObject poolObj;\n\n    private PoolManager() { }\n\n    /// \u003csummary\u003e\n    /// 拿东西的方法\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"name\"\u003e抽屉容器的名字\u003c/param\u003e\n    /// \u003creturns\u003e从缓存池中取出的对象\u003c/returns\u003e\n    public GameObject GetObj(string name)\n    {\n        GameObject obj;\n        //有抽屉，且抽屉内有对象\n        if (poolDic.ContainsKey(name) \u0026\u0026 poolDic[name].Count \u003e 0)\n        {\n            //弹出栈中的对象，直接返回给外部使用\n            obj = poolDic[name].Pop();\n        }\n        //否则，就应该去创建对象\n        else\n        {\n            obj = GameObject.Instantiate(Resources.Load\u003cGameObject\u003e(name));\n            //为了避免实例化出来的对象默认名字带一个\"(clone)\"，我们需要重命名这个对象\n            obj.name = name;\n        }\n        return obj;\n    }\n\n    /// \u003csummary\u003e\n    /// 往缓存池中放入对象\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"name\"\u003e抽屉（对象池）的名字\u003c/param\u003e\n    /// \u003cparam name=\"obj\"\u003e要放入的对象\u003c/param\u003e\n    public void PushObj(GameObject obj)\n    {\n        //如果根物体为空，就创建\n        if (poolObj == null)\n            poolObj = new GameObject(\"Pool\");\n\n        //如果不存在对应的抽屉容器，先创建抽屉，再往抽屉内放\n        if (!poolDic.ContainsKey(obj.name))\n            poolDic.Add(obj.name, new PoolData(poolObj, obj.name));\n        poolDic[obj.name].Push(obj);\n    }\n\n    /// \u003csummary\u003e\n    /// 清除整个柜子当中的数据\n    /// \u003c/summary\u003e\n    public void ClearPool()\n    {\n        poolDic.Clear();\n        poolObj = null;\n    }\n}\n"
												},
												{
													"Type": "NodeCodeBlockFenceCloseMarker",
													"Data": "```"
												}
											]
										},
										{
											"ID": "20240416175754-mc91o5o",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-mc91o5o",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "按照之前的测试方法再次测试，得到的Hierarchy窗口布局如下："
												}
											]
										},
										{
											"ID": "20240416175754-6ov08zv",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240416175754-6ov08zv",
												"updated": "20240416175754"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeImage",
													"Data": "span",
													"Children": [
														{
															"Type": "NodeBang"
														},
														{
															"Type": "NodeOpenBracket"
														},
														{
															"Type": "NodeLinkText",
															"Data": "image"
														},
														{
															"Type": "NodeCloseBracket"
														},
														{
															"Type": "NodeOpenParen"
														},
														{
															"Type": "NodeLinkDest",
															"Data": "assets/image-20240416142016-w5z1jrp.png"
														},
														{
															"Type": "NodeCloseParen"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "​"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240416175754-q5cw9ho",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20240416175754-q5cw9ho",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "将窗口布局优化变为可控制开启功能"
				}
			]
		},
		{
			"ID": "20240416175754-w7maljg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240416175754-w7maljg",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong u",
					"TextMarkTextContent": "频繁变化父子对象带来的性能开销是不可忽视的"
				},
				{
					"Type": "NodeText",
					"Data": "，而窗口布局优化往往只是为了方便我们在Hierarchy窗口上观察和调试对象\n因此，这个窗口布局优化应当是可关闭的，当我们发布游戏或者拥有更佳方案时，该功能就应该关闭掉，让对象池只控制对象的是否激活，提高性能"
				}
			]
		},
		{
			"ID": "20240416175754-ssv6uql",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240416175754-ssv6uql",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "PoolManager"
				},
				{
					"Type": "NodeText",
					"Data": "​内声明一个公开的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "isOpenLayout"
				},
				{
					"Type": "NodeText",
					"Data": "​，代表是否开启Hierarchy窗口自动布局功能"
				}
			]
		},
		{
			"ID": "20240416175754-in9sh52",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240416175754-in9sh52",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果不开启，则"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "PoolData"
				},
				{
					"Type": "NodeText",
					"Data": "​内的构造函数，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Pop"
				},
				{
					"Type": "NodeText",
					"Data": "​和"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Push"
				},
				{
					"Type": "NodeText",
					"Data": "​，以及"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "PoolManager"
				},
				{
					"Type": "NodeText",
					"Data": "​的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Push"
				},
				{
					"Type": "NodeText",
					"Data": "​与自动布局相关的逻辑都需要跳过不执行"
				}
			]
		},
		{
			"ID": "20240416175754-4q3gvgj",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240416175754-4q3gvgj",
				"style": "line-height: 22px;",
				"updated": "20240416175754"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PoolData\n{\n    //抽屉根对象，用来就行布局管理的对象\n    private GameObject poolObj;\n    //用来存储抽屉中的对象\n    private Stack\u003cGameObject\u003e dataStack = new Stack\u003cGameObject\u003e();\n    //获取容器中是否有对象\n    public int Count =\u003e dataStack.Count;\n\n    public PoolData(GameObject poolRootObj, string poolName) \n    {\n        //开启功能时，才会动态创建父子关系\n        if (PoolManager.isOpenLayout)\n        {\n            //创建抽屉父对象，和柜子父对象建立父子关系\n            poolObj = new GameObject(poolName);\n            poolObj.transform.SetParent(poolRootObj.transform);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 从抽屉中弹出数据对象\n    /// \u003c/summary\u003e\n    /// \u003creturns\u003e弹出的数据对象\u003c/returns\u003e\n    public GameObject Pop()\n    {\n        //从抽屉内取出并激活对象\n        GameObject obj = dataStack.Pop();\n        obj.SetActive(true);\n        //开启布局功能时，才需要断开父子关系\n        if (PoolManager.isOpenLayout)\n            obj.transform.SetParent(null);\n        return obj;\n    }\n\n    /// \u003csummary\u003e\n    /// 将数据压入到抽屉内\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"obj\"\u003e压入到抽屉内\u003c/param\u003e\n    public void Push(GameObject obj)\n    {\n        //失活后压入到抽屉内\n        obj.SetActive(false);\n        //开启了布局功能，才需要将要压入的对象设置父子关系\n        if (PoolManager.isOpenLayout)\n            obj.transform.SetParent(poolObj.transform);\n        dataStack.Push(obj);\n    }\n}\n\n/// \u003csummary\u003e\n/// 缓存池模块 管理器\n/// \u003c/summary\u003e\npublic class PoolManager : BaseManager\u003cPoolManager\u003e\n{\n    //柜子容器当中有抽屉的体现\n    private Dictionary\u003cstring, PoolData\u003e poolDic = new Dictionary\u003cstring, PoolData\u003e();\n\n    //池子根对象\n    private GameObject poolObj;\n\n    //是否开启Hierarchy窗口自动布局功能\n    public static bool isOpenLayout = false;\n\n    private PoolManager() { }\n\n    /// \u003csummary\u003e\n    /// 拿东西的方法\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"name\"\u003e抽屉容器的名字\u003c/param\u003e\n    /// \u003creturns\u003e从缓存池中取出的对象\u003c/returns\u003e\n    public GameObject GetObj(string name)\n    {\n        GameObject obj;\n        //有抽屉，且抽屉内有对象\n        if (poolDic.ContainsKey(name) \u0026\u0026 poolDic[name].Count \u003e 0)\n        {\n            //弹出栈中的对象，直接返回给外部使用\n            obj = poolDic[name].Pop();\n        }\n        //否则，就应该去创建对象\n        else\n        {\n            obj = GameObject.Instantiate(Resources.Load\u003cGameObject\u003e(name));\n            //为了避免实例化出来的对象默认名字带一个\"(clone)\"，我们需要重命名这个对象\n            obj.name = name;\n        }\n        return obj;\n    }\n\n    /// \u003csummary\u003e\n    /// 往缓存池中放入对象\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"name\"\u003e抽屉（对象池）的名字\u003c/param\u003e\n    /// \u003cparam name=\"obj\"\u003e要放入的对象\u003c/param\u003e\n    public void PushObj(GameObject obj)\n    {\n        //如果根物体为空且自动排布开启，就创建\n        if (poolObj == null \u0026\u0026 isOpenLayout)\n            poolObj = new GameObject(\"Pool\");\n\n        //如果不存在对应的抽屉容器，先创建抽屉，再往抽屉内放\n        if (!poolDic.ContainsKey(obj.name))\n            poolDic.Add(obj.name, new PoolData(poolObj, obj.name));\n        poolDic[obj.name].Push(obj);\n    }\n\n    /// \u003csummary\u003e\n    /// 清除整个柜子当中的数据\n    /// \u003c/summary\u003e\n    public void ClearPool()\n    {\n        poolDic.Clear();\n        poolObj = null;\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}