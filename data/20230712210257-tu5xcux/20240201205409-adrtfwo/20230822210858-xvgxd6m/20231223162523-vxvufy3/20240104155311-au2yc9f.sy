{"ID":"20240104155311-au2yc9f","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240104155311-au2yc9f","title":"UFL1-3——安全性问题解决","type":"doc","updated":"20250208153505"},"Children":[{"ID":"20240104155334-mu8u177","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240104155334-mu8u177","updated":"20240104155339"},"Children":[{"Type":"NodeText","Data":"前置知识点"}]},{"ID":"20240104155332-gmf1lqo","Type":"NodeParagraph","Properties":{"id":"20240104155332-gmf1lqo","updated":"20240104155332"},"Children":[{"Type":"NodeText","Data":"细节知识点"}]},{"ID":"20240104155311-4rpzcsj","Type":"NodeList","ListData":{},"Properties":{"id":"20240104155311-4rpzcsj","updated":"20240104202753"},"Children":[{"ID":"20240104155332-94e7t4s","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240104155332-94e7t4s","updated":"20240104155332"},"Children":[{"ID":"20240104155332-n6nhcm1","Type":"NodeParagraph","Properties":{"id":"20240104155332-n6nhcm1","updated":"20240104155332"},"Children":[{"Type":"NodeText","Data":"C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":"中抽象类的知识点（C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":"四部曲之C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":"核心）\n"}]}]},{"ID":"20240104155333-61gttju","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240104155333-61gttju"},"Children":[{"ID":"20240104155333-u8ug7jc","Type":"NodeParagraph","Properties":{"id":"20240104155333-u8ug7jc"},"Children":[{"Type":"NodeText","Data":"C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":"中反射相关知识点（C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":"四部曲之C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":"进阶）\n"}]}]},{"ID":"20240104202730-n3nos8i","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240104202730-n3nos8i","updated":"20240104202740"},"Children":[{"ID":"20240104202730-19e2t8f","Type":"NodeParagraph","Properties":{"id":"20240104202730-19e2t8f","updated":"20240104202740"},"Children":[{"Type":"NodeText","Data":"Unity中"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20230708205424-jq0z48e","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"Destroy函数"},{"Type":"NodeText","Data":"（Unity四部曲Unity入门）\n"}]}]},{"ID":"20240104202731-qyozo8o","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240104202731-qyozo8o","updated":"20240104202753"},"Children":[{"ID":"20240104202731-ki4fl7o","Type":"NodeParagraph","Properties":{"id":"20240104202731-ki4fl7o","updated":"20240104202753"},"Children":[{"Type":"NodeText","Data":"Unity中"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20230708154549-8gihcef","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"特性相关知识"},{"Type":"NodeText","Data":"（Unity四部曲Unity入门）"}]}]}]},{"ID":"20240104155402-f3hi0mk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240104155402-f3hi0mk","updated":"20240104155506"},"Children":[{"Type":"NodeText","Data":"唯一性问题——构造函数问题的解决"}]},{"ID":"20240104161607-tl9r5sm","Type":"NodeParagraph","Properties":{"id":"20240104161607-tl9r5sm","updated":"20240409140002"},"Children":[{"Type":"NodeText","Data":"虽然公共构造函数可能给我们带来破坏唯一性的安全隐患\n但是在实际开发中，单例模式是非常基础的知识点，可以说是程序员的必备基础知识\n在使用时几乎不会有人马虎到自己去"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"new"},{"Type":"NodeText","Data":"​单例模式对象"}]},{"ID":"20240104161607-xwm2a5l","Type":"NodeParagraph","Properties":{"id":"20240104161607-xwm2a5l","updated":"20240104161619"},"Children":[{"Type":"NodeText","Data":"因此即使我们不做这些安全性的处理，其实也不会有太大问题，根据实际情况和需求进行设计即可"}]},{"ID":"20240104155825-s6yf1qu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240104155825-s6yf1qu","updated":"20240415152836"},"Children":[{"Type":"NodeText","Data":"构造函数带来的唯一性问题"}]},{"ID":"20240104155518-kqbxkme","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240104155518-kqbxkme","updated":"20240415152836"},"Children":[{"ID":"20240104155522-buq7fyg","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240104155522-buq7fyg","updated":"20240409140346"},"Children":[{"ID":"20240104155522-kw2adgt","Type":"NodeParagraph","Properties":{"id":"20240104155522-kw2adgt","updated":"20240409140346"},"Children":[{"Type":"NodeText","Data":"对于不继承"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​的单例模式基类："},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"我们要避免在外部"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"code strong","TextMarkTextContent":"new"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"单例模式类对象"}]}]},{"ID":"20240104155522-5krp0ap","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240104155522-5krp0ap","updated":"20240409140340"},"Children":[{"ID":"20240104155522-n5hx9ty","Type":"NodeParagraph","Properties":{"id":"20240104155522-n5hx9ty","updated":"20240409140340"},"Children":[{"Type":"NodeText","Data":"对于继承"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​的单例模式基类：由于继承"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​的脚本不能通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"new"},{"Type":"NodeText","Data":"​创建，因此不用过多考虑"}]}]}]},{"ID":"20240104155635-eopmwnl","Type":"NodeParagraph","Properties":{"id":"20240104155635-eopmwnl","updated":"20240415153000"},"Children":[{"Type":"NodeText","Data":"类似于下面的代码就会出现安全性问题，我们在外部"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"new"},{"Type":"NodeText","Data":"​了一个单例模式的类对象，这破坏了单例模式唯一性："}]},{"ID":"20240104155649-cevi1fr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240104155649-cevi1fr","style":"line-height: 22px;","updated":"20240415152836"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"TestMgr t = new TestMgr();\nBaseManager\u003cTestMgr\u003e t2 = new BaseManager\u003cTestMgr\u003e();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240104155416-krpt1jq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240104155416-krpt1jq","updated":"20240104155839"},"Children":[{"Type":"NodeText","Data":"解决构造函数带来的问题"}]},{"ID":"20240104155907-vhyof80","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240104155907-vhyof80","updated":"20240104160714"},"Children":[{"ID":"20240104155912-eua58v2","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240104155912-eua58v2","updated":"20240104155912"},"Children":[{"ID":"20240104155912-8e01yhl","Type":"NodeParagraph","Properties":{"id":"20240104155912-8e01yhl","updated":"20240104155912"},"Children":[{"Type":"NodeText","Data":"父类变为抽象类"}]}]},{"ID":"20240104155912-0jub20f","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240104155912-0jub20f","updated":"20240104155912"},"Children":[{"ID":"20240104155912-e2ji7j5","Type":"NodeParagraph","Properties":{"id":"20240104155912-e2ji7j5","updated":"20240104155912"},"Children":[{"Type":"NodeText","Data":"规定继承单例模式基类的类必须显示实现私有无参构造函数"}]}]},{"ID":"20240104155912-hee4qhs","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240104155912-hee4qhs","updated":"20240104160714"},"Children":[{"ID":"20240104155912-5tplvo7","Type":"NodeParagraph","Properties":{"id":"20240104155912-5tplvo7","updated":"20240104155912"},"Children":[{"Type":"NodeText","Data":"在基类中通过反射来调用私有构造函数实例化对象"}]},{"ID":"20240104160618-gz1boss","Type":"NodeParagraph","Properties":{"id":"20240104160618-gz1boss","updated":"20240104160658"},"Children":[{"Type":"NodeText","Data":"主要知识点：\n利用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Type"},{"Type":"NodeText","Data":"​中的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GetConstructor(约束条件, 绑定对象, 参数类型, 参数修饰符)"},{"Type":"NodeText","Data":"​方法\n来获取私有无参构造函数"}]},{"ID":"20240104160701-3de2oz8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240104160701-3de2oz8","style":"line-height: 22px;","updated":"20240104160714"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"ConstructorInfo constructor = typeof(T).GetConstructor(\n\tBindingFlags.Instance | BindingFlags.NonPublic, \t//表示成员私有方法\n\tnull,                                         \t\t//表示没有绑定对象\n  \tType.EmptyTypes,                              \t\t//表示没有参数\n  \tnull);                                        \t\t//表示没有参数修饰符\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]},{"ID":"20240104161624-9jtzzs8","Type":"NodeParagraph","Properties":{"id":"20240104161624-9jtzzs8","updated":"20240104194614"},"Children":[{"Type":"NodeText","Data":"修改后的单例模式基类如下："}]},{"ID":"20240104194614-dar83ga","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240104194614-dar83ga","style":"line-height: 22px;","updated":"20240104194656"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"/// \u003csummary\u003e\n/// 不继承MonoBehaviour的单例模式基类，实现静态变量和静态属性的声明，单例模式类可以直接继承该类，继承后无需自行实现单例声明相关内容\n/// \u003c/summary\u003e\n/// \u003ctypeparam name=\"T\"\u003e继承该类的类\u003c/typeparam\u003e\npublic abstract class BaseManager\u003cT\u003e where T : class\n{\n    private static T instance;\n\n    public static T Instance\n    {\n        get\n        {\n            if (instance == null)\n            {\n                Type type = typeof(T);\n                //使用反射来获取私有无参构造函数，并用于对象的实例化\n                ConstructorInfo info = type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, \n                                                           null,\n                                                           Type.EmptyTypes,\n                                                           null);\n                if (info != null)\n                    instance = info.Invoke(null, null) as T;\n                else\n                    Debug.LogError(\"没有得到对应的无参构造函数！！！\");\n            }\n            return instance;\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240104194736-njqce12","Type":"NodeParagraph","Properties":{"id":"20240104194736-njqce12","updated":"20240104194815"},"Children":[{"Type":"NodeText","Data":"当然，也可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Activator.CreateInstance"},{"Type":"NodeText","Data":"​方法来实例化："}]},{"ID":"20240104194815-uuruy0s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240104194815-uuruy0s","style":"line-height: 22px;","updated":"20240104194853"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"public static T Instance\n{\n    get\n    {\n        if (instance == null)\n        {\n            Type type = typeof(T);\n            instance = Activator.CreateInstance(type, true) as T;\n            if (instance == null)\n                Debug.LogError(\"无法实例化对象！\");\n        }\n        return instance;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240104194832-sv5gbn7","Type":"NodeParagraph","Properties":{"id":"20240104194832-sv5gbn7","updated":"20240104195050"},"Children":[{"Type":"NodeText","Data":"最后，如果想要避免他人使用反射来实例化对象，需要一个变量去标识是否实例化，然后在构造函数里检测该标识"}]},{"ID":"20240415154606-e6dwdcv","Type":"NodeParagraph","Properties":{"id":"20240415154606-e6dwdcv","updated":"20240415154622"},"Children":[{"Type":"NodeText","Data":"一个简单的方式是，在单例模式基类里声明一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"protected"},{"Type":"NodeText","Data":"​的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bool"},{"Type":"NodeText","Data":"​类型属性"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"isInitialized"},{"Type":"NodeText","Data":"​，\n这个属性通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"instance"},{"Type":"NodeText","Data":"​是否为空来决定是否为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"​，如果"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"instance"},{"Type":"NodeText","Data":"​为空就是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"​，\n然后在其派生类的构造函数里检测这个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"isInitialized"},{"Type":"NodeText","Data":"​是否为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"​，如果为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"​，则抛出错误，代码如下："}]},{"ID":"20240415154606-aosepb4","Type":"NodeParagraph","Properties":{"id":"20240415154606-aosepb4","updated":"20240415154636"},"Children":[{"Type":"NodeText","Data":"基类的代码（实测"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ConstructorInfo"},{"Type":"NodeText","Data":"​或者"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Activator.CreateInstance"},{"Type":"NodeText","Data":"​方法都可正常使用）："}]},{"ID":"20240415154606-1150wpi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240415154606-1150wpi","updated":"20240415154606"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3M="},{"Type":"NodeCodeBlockCode","Data":"public abstract class BaseManager\u003cT\u003e where T : class\n{\n    private static T instance;\n\n    protected static bool isInitialized =\u003e instance != null;\n\n    public static T Instance\n    {\n        get\n        {\n            if (instance == null)\n            {\n                Type type = typeof(T);\n                //使用反射来获取私有无参构造函数，并用于对象的实例化\n                instance = Activator.CreateInstance(type, true) as T;\n                if (instance == null)\n                    Debug.LogError(\"无法实例化对象！\");\n            }\n            return instance;\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240415154646-ztvbvbz","Type":"NodeParagraph","Properties":{"id":"20240415154646-ztvbvbz","updated":"20240415154646"},"Children":[{"Type":"NodeText","Data":"派生类的代码："}]},{"ID":"20240415154646-ws471uc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240415154646-ws471uc","updated":"20240415154646"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3M="},{"Type":"NodeCodeBlockCode","Data":"using UnityEngine;\n\npublic class TestMgr : BaseManager\u003cTestMgr\u003e\n{\n    public void Speak()\n    {\n        Debug.Log(\"我是TestMgr\");\n    }\n\n    private TestMgr() \n    {\n        if (isInitialized)\n            throw new System.Exception(\"请勿重复实例化单例模式类对象！\");\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240415154648-xad5qdr","Type":"NodeParagraph","Properties":{"id":"20240415154648-xad5qdr","updated":"20240415154748"},"Children":[{"Type":"NodeText","Data":"美中不足的一点是，无法防止单例模式的类在第一次调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Instance"},{"Type":"NodeText","Data":"​前，外部调用反射构造方法实例化对象的情况，因此需要更进一步："}]},{"ID":"20240415154707-o9q42qr","Type":"NodeParagraph","Properties":{"id":"20240415154707-o9q42qr","updated":"20240415154807"},"Children":[{"Type":"NodeText","Data":"在基类声明一个私有的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bool"},{"Type":"NodeText","Data":"​类型标识，默认为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"​，这个标识只有在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Instance"},{"Type":"NodeText","Data":"​内实例化对象时赋值"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"​，\n实例化结束后赋值为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"​，根据该标识是否为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"​决定构造函数内是否抛出错误："}]},{"ID":"20240415154707-28rqqzf","Type":"NodeParagraph","Properties":{"id":"20240415154707-28rqqzf","updated":"20240415154707"},"Children":[{"Type":"NodeText","Data":"基类的代码是："}]},{"ID":"20240104195047-a78rwvx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240104195047-a78rwvx","style":"line-height: 22px;","updated":"20240415154924"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"/// \u003csummary\u003e\n/// 不继承MonoBehaviour的单例模式基类，实现静态变量和静态属性的声明，单例模式类可以直接继承该类，继承后无需自行实现单例声明相关内容\n/// \u003c/summary\u003e\n/// \u003ctypeparam name=\"T\"\u003e继承该类的类\u003c/typeparam\u003e\npublic abstract class BaseManager\u003cT\u003e where T : class\n{\n    private static T instance;\n\n    private static bool internalInitializeToken = false;    //类内部实例化标识，只有Intance内才可以修改它，用于确保只有内部可以实例化对象\n  \n    //当instance不为null时且内部标识是false时，则表示不能实例化\n    protected static bool CanInitialize =\u003e instance == null \u0026\u0026 internalInitializeToken;\n\n    public static T Instance\n    {\n        get\n        {\n            if (instance == null)\n            {\n                Type type = typeof(T);\n                //使用反射来获取私有无参构造函数，并用于对象的实例化\n                //在这里实例化前先让该标识为true\n                internalInitializeToken = true;\n                instance = Activator.CreateInstance(type, true) as T;\n                if (instance == null)\n                    Debug.LogError(\"无法实例化对象！\");\n                //实例化后恢复为false\n                internalInitializeToken = false;\n            }\n            return instance;\n        }\n    }\n}\n\n//派生类的代码\npublic class TestMgr : BaseManager\u003cTestMgr\u003e\n{\n    public void Speak()\n    {\n        Debug.Log(\"我是TestMgr\");\n    }\n\n    private TestMgr() \n    {\n        if (!CanInitialize)   \n            throw new System.Exception(\"请勿在外部实例化或多次实例化单例模式类对象！\");\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240415154834-moplbzq","Type":"NodeParagraph","Properties":{"id":"20240415154834-moplbzq","updated":"20240415154839"},"Children":[{"Type":"NodeText","Data":"测试代码为："}]},{"ID":"20240415154845-e4w42ki","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240415154845-e4w42ki","updated":"20240415154845"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"using System;\nusing UnityEngine;\n\npublic class Main : MonoBehaviour\n{\n    void Start()\n    {\n        Type type = typeof(TestMgr);\n        Activator.CreateInstance(type, true);   //如果运行正确，这里应当报错\n        TestMgr.Instance.Speak();               //如果运行正确，这里会正常输出内容\n        Activator.CreateInstance(type, true);   //如果运行正确，这里应当报错\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240104200848-m8mzvn2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240104200848-m8mzvn2","updated":"20240104200913"},"Children":[{"Type":"NodeText","Data":"唯一性问题——重复挂载"}]},{"ID":"20240104202435-9filplw","Type":"NodeParagraph","Properties":{"id":"20240104202435-9filplw","updated":"20240104202435"},"Children":[{"Type":"NodeText","Data":"为了避免重复挂载我们一般采用以下几种方案："}]},{"ID":"20240104202435-kbkbyuf","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240104202435-kbkbyuf","updated":"20240415155018"},"Children":[{"ID":"20240104202440-r2ju6ni","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240104202440-r2ju6ni","updated":"20240415155018"},"Children":[{"ID":"20240104202440-8tsuitp","Type":"NodeParagraph","Properties":{"id":"20240104202440-8tsuitp","updated":"20240415155018"},"Children":[{"Type":"NodeText","Data":"对于挂载式的单例模式基类，相同对象上重复挂载问题，通过添加"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[DisallowMultipleComponent]"},{"Type":"NodeText","Data":"​特性解决"}]}]},{"ID":"20240104202440-6am68q4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240104202440-6am68q4","updated":"20240104202440"},"Children":[{"ID":"20240104202440-4v0zgs4","Type":"NodeParagraph","Properties":{"id":"20240104202440-4v0zgs4","updated":"20240104202440"},"Children":[{"Type":"NodeText","Data":"对于挂载式的单例模式基类，不同对象上的重复挂载，通过逻辑判断，代码移除多余的脚本"}]}]},{"ID":"20240104202440-3bxwkus","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240104202440-3bxwkus","updated":"20240104202440"},"Children":[{"ID":"20240104202440-l66nm1u","Type":"NodeParagraph","Properties":{"id":"20240104202440-l66nm1u","updated":"20240104202440"},"Children":[{"Type":"NodeText","Data":"最好的避免重复挂载的方式，就是使用自动挂载式的单例模式基类，并且制定使用规则（不允许手动挂载和代码添加）"}]}]}]},{"ID":"20240104201007-w008tzq","Type":"NodeParagraph","Properties":{"id":"20240104201007-w008tzq","updated":"20240104201045"},"Children":[{"Type":"NodeText","Data":"对于继承"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​的挂载式的单例模式基类"}]},{"ID":"20240104200913-cl1uciy","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240104200913-cl1uciy","updated":"20240104201201"},"Children":[{"ID":"20240104201007-sjiug2m","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240104201007-sjiug2m","updated":"20240104201007"},"Children":[{"ID":"20240104201007-rmeodyb","Type":"NodeParagraph","Properties":{"id":"20240104201007-rmeodyb","updated":"20240104201007"},"Children":[{"Type":"NodeText","Data":"手动挂载多个相同单例模式脚本"}]}]},{"ID":"20240104201007-tdwl8c2","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240104201007-tdwl8c2","updated":"20240104201201"},"Children":[{"ID":"20240104201007-t086o5s","Type":"NodeParagraph","Properties":{"id":"20240104201007-t086o5s","updated":"20240104201007"},"Children":[{"Type":"NodeText","Data":"代码动态添加多个相同单例模式脚本"}]},{"ID":"20240104201133-u8h1pkw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240104201133-u8h1pkw","style":"line-height: 22px;","updated":"20240104201201"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"this.gameObject.AddComponent\u003c\u003e()\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]},{"ID":"20240104201046-ir5he4s","Type":"NodeParagraph","Properties":{"id":"20240104201046-ir5he4s","updated":"20240104201111"},"Children":[{"Type":"NodeText","Data":"这些行为都会破坏单例模式的唯一性"}]},{"ID":"20240104201302-v4401fs","Type":"NodeList","ListData":{},"Properties":{"id":"20240104201302-v4401fs","updated":"20240415155336"},"Children":[{"ID":"20240415155321-fgaisdp","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240415155321-fgaisdp","updated":"20240415155321"},"Children":[{"ID":"20240415155321-pgnh17o","Type":"NodeParagraph","Properties":{"id":"20240415155321-pgnh17o","updated":"20240415155321"},"Children":[{"Type":"NodeText","Data":"对于挂载式的单例模式脚本"}]},{"ID":"20240104201257-mmvff8s","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240104201257-mmvff8s","updated":"20240104202341"},"Children":[{"ID":"20240104201302-cyv84cx","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240104201302-cyv84cx","name":"[DisallowMultipleComponent]","updated":"20240104201617"},"Children":[{"ID":"20240104201302-5sp43ci","Type":"NodeParagraph","Properties":{"id":"20240104201302-5sp43ci","updated":"20240104201306"},"Children":[{"Type":"NodeText","Data":"同个对象的重复挂载\n"}]},{"ID":"20240104201315-v81o3jh","Type":"NodeParagraph","Properties":{"id":"20240104201315-v81o3jh","updated":"20240104201718"},"Children":[{"Type":"NodeText","Data":"为脚本添加特性"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[DisallowMultipleComponent]"},{"Type":"NodeText","Data":"​\n该特性只能使脚本不能在一个对象上重复挂载，但是不能解决在不同对象上挂多个脚本的问题"}]}]},{"ID":"20240104201302-40esdch","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240104201302-40esdch","updated":"20240104202341"},"Children":[{"ID":"20240104201302-t2o0mcr","Type":"NodeParagraph","Properties":{"id":"20240104201302-t2o0mcr","updated":"20240104201302"},"Children":[{"Type":"NodeText","Data":"修改代码逻辑\n"}]},{"ID":"20240104201316-c23z9hy","Type":"NodeParagraph","Properties":{"id":"20240104201316-c23z9hy"},"Children":[{"Type":"NodeText","Data":"判断如果存在对象，移除脚本"}]},{"ID":"20240104202339-n6m7j6g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240104202339-n6m7j6g","style":"line-height: 22px;","updated":"20240104202341"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"public class SingletonMono\u003cT\u003e : MonoBehaviour where T : MonoBehaviour\n{\n    private static T instance;\n\n    public static T Instance\n    {\n        get { return instance; }\n    }\n\n    /// \u003csummary\u003e\n    /// 在重写该Awake函数时切记保留base.Awake()!!!\n    /// \u003c/summary\u003e\n    protected virtual void Awake()\n    {\n        //已经存在一个对应的单例模式对象了，不需要再有一个\n        if (instance != null)\n        {\n            Destroy(this);\n            return;\n        }\n        instance = this as T;\n        DontDestroyOnLoad(this.gameObject);\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]}]},{"ID":"20240415155335-xsy0po4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240415155335-xsy0po4","updated":"20240415155336"},"Children":[{"ID":"20240415155335-afjyky0","Type":"NodeParagraph","Properties":{"id":"20240415155335-afjyky0","updated":"20240415155336"},"Children":[{"Type":"NodeText","Data":"对于自动挂载式的单例模式脚本，制定使用规则，不允许手动挂载或代码添加"}]}]}]},{"ID":"20240104202632-o0fd1n2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240104202632-o0fd1n2","updated":"20250208153505"},"Children":[{"Type":"NodeText","Data":"线程安全——是否加锁"}]},{"ID":"20240104204038-mzjgrzq","Type":"NodeList","ListData":{},"Properties":{"id":"20240104204038-mzjgrzq","updated":"20250208153436"},"Children":[{"ID":"20240415155124-dhbnzrs","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240415155124-dhbnzrs","updated":"20250208153436"},"Children":[{"ID":"20240415155124-veo542i","Type":"NodeParagraph","Properties":{"id":"20240415155124-veo542i","updated":"20250208153436"},"Children":[{"Type":"NodeText","Data":"对于不继承 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​ 的单例模式对象，建议加锁"}]}]},{"ID":"20240415155142-tbn2ocj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240415155142-tbn2ocj","updated":"20250208153434"},"Children":[{"ID":"20240415155142-oeguzoq","Type":"NodeParagraph","Properties":{"id":"20240415155142-oeguzoq","updated":"20250208153434"},"Children":[{"Type":"NodeText","Data":"对于继承 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​ 的单例模式对象，可以不加"}]}]}]},{"ID":"20240104202831-xk1w4jy","Type":"NodeParagraph","Properties":{"id":"20240104202831-xk1w4jy","updated":"20240104202837"},"Children":[{"Type":"NodeText","Data":"如果程序当中存在多线程，我们需要考虑当多个线程同时访问同一个内存空间时出现的问题\n如果不加以控制，可能会导致数据出错，我们一般称这种问题为多线程并发问题，指多线程对共享数据的并发访问和操作。"}]},{"ID":"20240104202831-wnzd2fc","Type":"NodeParagraph","Properties":{"id":"20240104202831-wnzd2fc","updated":"20250208153442"},"Children":[{"Type":"NodeText","Data":"而一般解决该问题的方式，就是通过 C"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"#"}]},{"Type":"NodeText","Data":" 中的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"lock"},{"Type":"NodeText","Data":"​ 关键字进行加锁，我们需要考虑我们的单例模式对象们是否需要加锁"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"(lock)"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240104202831-qxhjsvn","Type":"NodeParagraph","Properties":{"id":"20240104202831-qxhjsvn","updated":"20240104202857"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"lock"},{"Type":"NodeText","Data":"​ 的原理保证了在任何时刻只有一个线程能够执行被锁保护的代码块\n从而防止多个线程同时访问或修改共享资源，确保线程安全"}]},{"ID":"20240104204038-82f8wnr","Type":"NodeParagraph","Properties":{"id":"20240104204038-82f8wnr","updated":"20240415161123"},"Children":[{"Type":"NodeText","Data":"但是具体是否加锁，都根据需求来定，如果你的项目中压根就不会使用多线程，那么完全可以不用考虑加锁问题"}]},{"ID":"20240104202926-vpp5l2h","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240104202926-vpp5l2h","updated":"20250208153505"},"Children":[{"ID":"20240104202930-f9wwtze","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240104202930-f9wwtze","updated":"20250208153445"},"Children":[{"ID":"20240104202930-ddsglsa","Type":"NodeParagraph","Properties":{"id":"20240104202930-ddsglsa","updated":"20250208153445"},"Children":[{"Type":"NodeText","Data":"不继承 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​ 的单例模式"}]},{"ID":"20240104202933-v99h8u9","Type":"NodeParagraph","Properties":{"id":"20240104202933-v99h8u9","updated":"20240415162232"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"建议加锁，避免以后使用多线程时出现并发问题，"},{"Type":"NodeText","Data":"比如在处理网络通讯模块、复杂算法模块时，经常会进行多线程并发处理"}]},{"ID":"20240415162513-imo9ur7","Type":"NodeParagraph","Properties":{"id":"20240415162513-imo9ur7","updated":"20240415162513"},"Children":[{"Type":"NodeText","Data":"例如多线程访问"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Instance"},{"Type":"NodeText","Data":"​时，需要避免"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"instance"},{"Type":"NodeText","Data":"​单例对象被多个线程同时访问"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Instance"},{"Type":"NodeText","Data":"​导致重复实例化\n因此需要为实例化"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"instance"},{"Type":"NodeText","Data":"​的代码块加锁，为了性能考虑，判断"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"instance == null"},{"Type":"NodeText","Data":"​是不需要放入锁中的"}]},{"ID":"20240415162232-rej29x7","Type":"NodeParagraph","Properties":{"id":"20240415162232-rej29x7","updated":"20240415162757"},"Children":[{"Type":"NodeText","Data":"但是如果多个线程同时进入了外层"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"instance == null"},{"Type":"NodeText","Data":"​的代码块，线程先后进入带锁代码块，还是会出现重复实例化"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"instance"},{"Type":"NodeText","Data":"​的情况\n因此锁内必须再添加判断"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"instance == null"},{"Type":"NodeText","Data":"​，确保最先进入锁内的线程在实例化"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"instance"},{"Type":"NodeText","Data":"​后，后进入带锁代码块的线程将不能再实例化"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"instance"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240104222748-5lzjsi1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240104222748-5lzjsi1","style":"line-height: 22px;","updated":"20240415162551"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"/// \u003csummary\u003e\n/// 不继承MonoBehaviour的单例模式基类，实现静态变量和静态属性的声明，单例模式类可以直接继承该类，继承后无需自行实现单例声明相关内容\n/// \u003c/summary\u003e\n/// \u003ctypeparam name=\"T\"\u003e继承该类的类\u003c/typeparam\u003e\npublic abstract class BaseManager\u003cT\u003e where T : class\n{\n    private static T instance;\n\n    private static bool internalInitializeToken = false;        //类内部实例化标识，只有Intance内才可以修改它，用于确保内部可以实例化对象\n  \n    protected static readonly object lockObj = new object();    //用于加锁的对象\n\n    //当instance不为null时且内部标识是false时，则表示不能实例化\n    protected static bool CanInitialize =\u003e instance == null \u0026\u0026 internalInitializeToken;\n\n    public static T Instance\n    {\n        get\n        {\n            if (instance == null)\n            {\n                lock (lockObj)\n                {\n                    //这里的判空不可以删除！它确保最先进入锁内的线程在实例化结束后，后进入带锁代码块的线程不能再实例化instance\n                    if (instance == null)\n                    {\n                        Type type = typeof(T);\n                        //使用反射来获取私有无参构造函数，并用于对象的实例化\n                        //在这里实例化前先让该标识为true\n                        internalInitializeToken = true;\n                        instance = Activator.CreateInstance(type, true) as T;\n                        if (instance == null)\n                            Debug.LogError(\"无法实例化对象！\");\n                        //实例化后恢复为false\n                        internalInitializeToken = false;\n                    }\n                }\n            }\n            return instance;\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20240104202930-fwoer48","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240104202930-fwoer48","updated":"20250208153505"},"Children":[{"ID":"20240104202930-kca7i3o","Type":"NodeParagraph","Properties":{"id":"20240104202930-kca7i3o","updated":"20250208153457"},"Children":[{"Type":"NodeText","Data":"继承 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​ 的单例模式"}]},{"ID":"20240104202935-ou5rqn0","Type":"NodeParagraph","Properties":{"id":"20240104202935-ou5rqn0","updated":"20250208153505"},"Children":[{"Type":"NodeText","Data":"可加可不加，但是建议不加\n因为 Unity 中的机制是，Unity 主线程中处理的一些对象（如 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GameObject"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Transform"},{"Type":"NodeText","Data":"​ 等等）是不允许被其他多线程修改访问的，会直接报错\n因此我们一般不会通过多线程去访问继承 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MonoBehaviour"},{"Type":"NodeText","Data":"​ 的相关对象，既然如此，就不会发生多线程并发问题"}]}]}]},{"ID":"20240409140011-e4u20pn","Type":"NodeParagraph","Properties":{"id":"20240409140011-e4u20pn"}}]}