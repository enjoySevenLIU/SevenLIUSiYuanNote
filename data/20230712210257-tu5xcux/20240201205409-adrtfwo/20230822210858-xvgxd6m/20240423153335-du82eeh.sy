{
	"ID": "20240423153335-du82eeh",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20240423153335-du82eeh",
		"title": "UFL13——数学计算工具模块",
		"type": "doc",
		"updated": "20240425210603"
	},
	"Children": [
		{
			"ID": "20240423153335-gb4u2o2",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240423153335-gb4u2o2",
				"updated": "20240423153423"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240423153349-u3hie70",
					"Type": "NodeHeading",
					"HeadingLevel": 2,
					"Properties": {
						"id": "20240423153349-u3hie70",
						"updated": "20240423153352"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "前置知识点"
						}
					]
				},
				{
					"ID": "20240423153353-hld47fq",
					"Type": "NodeList",
					"ListData": {
						"Typ": 1
					},
					"Properties": {
						"id": "20240423153353-hld47fq",
						"updated": "20240423153423"
					},
					"Children": [
						{
							"ID": "20240423153400-j7ph6rr",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "MS4=",
								"Num": 1
							},
							"Properties": {
								"id": "20240423153400-j7ph6rr",
								"updated": "20240423153414"
							},
							"Children": [
								{
									"ID": "20240423153400-y1jing7",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20240423153400-y1jing7",
										"updated": "20240423153414"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "Unity中"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "block-ref",
											"TextMarkBlockRefID": "20230711013705-qw85hvn",
											"TextMarkBlockRefSubtype": "s",
											"TextMarkTextContent": "向量"
										},
										{
											"Type": "NodeText",
											"Data": "、"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "block-ref",
											"TextMarkBlockRefID": "20230711221541-zer4ley",
											"TextMarkBlockRefSubtype": "s",
											"TextMarkTextContent": "四元数"
										},
										{
											"Type": "NodeText",
											"Data": " 相关知识点（Unity四部曲之Unity基础中）"
										}
									]
								}
							]
						},
						{
							"ID": "20240423153400-0r26fuw",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "Mi4=",
								"Num": 2
							},
							"Properties": {
								"id": "20240423153400-0r26fuw",
								"updated": "20240423153419"
							},
							"Children": [
								{
									"ID": "20240423153400-hcpfzj9",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20240423153400-hcpfzj9",
										"updated": "20240423153419"
									},
									"Children": [
										{
											"Type": "NodeTextMark",
											"TextMarkType": "block-ref",
											"TextMarkBlockRefID": "20230714194240-hh7kxpj",
											"TextMarkBlockRefSubtype": "s",
											"TextMarkTextContent": "射线检测"
										},
										{
											"Type": "NodeText",
											"Data": " 相关知识点（Unity四部曲之Unity基础中）"
										}
									]
								}
							]
						},
						{
							"ID": "20240423153400-ql9h1cs",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "My4=",
								"Num": 3
							},
							"Properties": {
								"id": "20240423153400-ql9h1cs",
								"updated": "20240423153423"
							},
							"Children": [
								{
									"ID": "20240423153400-55gdb1o",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20240423153400-55gdb1o",
										"updated": "20240423153423"
									},
									"Children": [
										{
											"Type": "NodeTextMark",
											"TextMarkType": "block-ref",
											"TextMarkBlockRefID": "20230714163601-ghjk8c8",
											"TextMarkBlockRefSubtype": "s",
											"TextMarkTextContent": "范围检测"
										},
										{
											"Type": "NodeText",
											"Data": " 相关知识点 （Unity四部曲之Unity基础中）"
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240423153431-hgdfqsm",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240423153431-hgdfqsm",
				"updated": "20240423153432"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "数学计算工具模块 主要作用"
				}
			]
		},
		{
			"ID": "20240423153437-peuxfep",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240423153437-peuxfep",
				"updated": "20240423153443"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在游戏开发中，经常会进行一些通用的数学计算，为了减少代码冗余\n我们往往会把常用的数学计算逻辑，封装到一个工具类中提供给外部使用"
				}
			]
		},
		{
			"ID": "20240423153437-noyi31j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240423153437-noyi31j",
				"updated": "20240423153447"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此数学计算工具模块，主要就是将通用的数学计算逻辑封装为方法，供外部使用"
				}
			]
		},
		{
			"ID": "20240423153448-engpw72",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240423153448-engpw72",
				"updated": "20240423153453"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "数学计算工具模块 基本原理"
				}
			]
		},
		{
			"ID": "20240423153457-rykqjb9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240423153457-rykqjb9",
				"updated": "20240423153503"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们将新建一个数学计算工具类，主要提供以下方法："
				}
			]
		},
		{
			"ID": "20240423153501-rro31ck",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240423153501-rro31ck",
				"updated": "20240423153501"
			},
			"Children": [
				{
					"ID": "20240423153501-8kqc2yx",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240423153501-8kqc2yx",
						"updated": "20240423153501"
					},
					"Children": [
						{
							"ID": "20240423153501-whzptim",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240423153501-whzptim",
								"updated": "20240423153501"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "角度和弧度的转换"
								}
							]
						}
					]
				},
				{
					"ID": "20240423153501-1v3wi4q",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240423153501-1v3wi4q",
						"updated": "20240423153501"
					},
					"Children": [
						{
							"ID": "20240423153501-zc47197",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240423153501-zc47197",
								"updated": "20240423153501"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "得到两个对象在xz平面上的距离"
								}
							]
						}
					]
				},
				{
					"ID": "20240423153501-w6zr5sx",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20240423153501-w6zr5sx",
						"updated": "20240423153501"
					},
					"Children": [
						{
							"ID": "20240423153501-xa2su8f",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240423153501-xa2su8f",
								"updated": "20240423153501"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "判断对象是否在屏幕范围外"
								}
							]
						}
					]
				},
				{
					"ID": "20240423153501-mj19zou",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20240423153501-mj19zou",
						"updated": "20240423153501"
					},
					"Children": [
						{
							"ID": "20240423153501-66f6ega",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240423153501-66f6ega",
								"updated": "20240423153501"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "判断对象位置是否在xz平面扇形范围内"
								}
							]
						}
					]
				},
				{
					"ID": "20240423153501-hu95jod",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20240423153501-hu95jod",
						"updated": "20240423153501"
					},
					"Children": [
						{
							"ID": "20240423153501-jvy3i77",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240423153501-jvy3i77",
								"updated": "20240423153501"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "射线检测"
								}
							]
						}
					]
				},
				{
					"ID": "20240423153501-x36g8qq",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ni4=",
						"Num": 6
					},
					"Properties": {
						"id": "20240423153501-x36g8qq",
						"updated": "20240423153501"
					},
					"Children": [
						{
							"ID": "20240423153501-uk4yvwk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240423153501-uk4yvwk",
								"updated": "20240423153501"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "范围检测"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240423153459-4xrgky7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240423153459-4xrgky7",
				"updated": "20240423153459"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "等等"
				}
			]
		},
		{
			"ID": "20240423153457-u4yz376",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240423153457-u4yz376",
				"updated": "20240423153506"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们只实现以上方法，更多内容，在实际开发时根据需求加入到工具类中即可"
				}
			]
		},
		{
			"ID": "20240425190212-opbt5ai",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240425190212-opbt5ai",
				"updated": "20240425190223"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "角度和弧度相互转换 的方法"
				}
			]
		},
		{
			"ID": "20240425190412-hkqxi8p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425190412-hkqxi8p",
				"updated": "20240425190447"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虽然Unity中的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code block-ref",
					"TextMarkBlockRefID": "20230710233350-w8858ww",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "Mathf"
				},
				{
					"Type": "NodeText",
					"Data": "​ 类中已经有 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code block-ref",
					"TextMarkBlockRefID": "20230711005703-1sbh3lf",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "Mathf.Deg2Rad"
				},
				{
					"Type": "NodeText",
					"Data": "​ 、 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code block-ref",
					"TextMarkBlockRefID": "20230711005655-g56tad5",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "Mathf.Rad2Deg"
				},
				{
					"Type": "NodeText",
					"Data": "​ 相关的系数\n但是为了避免使用错误，我们完全可以将其封装为方法，外部只需传入角度或弧度 便可以得到结果\n无需在外部进行乘法运算"
				}
			]
		},
		{
			"ID": "20240425190412-pediefd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425190412-pediefd",
				"updated": "20240425190412"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "让这些常规操作使用起来更加的方便"
				}
			]
		},
		{
			"ID": "20240425190456-1usee8k",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425190456-1usee8k",
				"style": "line-height: 22px;",
				"updated": "20240425190822"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/// \u003csummary\u003e\n/// 角度转弧度的方法\n/// \u003c/summary\u003e\n/// \u003cparam name=\"deg\"\u003e要转换的角度\u003c/param\u003e\n/// \u003creturns\u003e转换出来的弧度\u003c/returns\u003e\npublic static float DegToRad(float deg)\n{\n    return deg * Mathf.Deg2Rad;\n}\n\n/// \u003csummary\u003e\n/// 弧度转角度的方法\n/// \u003c/summary\u003e\n/// \u003cparam name=\"rad\"\u003e要转换的弧度\u003c/param\u003e\n/// \u003creturns\u003e转换出来的弧度\u003c/returns\u003e\npublic static float RadToDeg(float rad)\n{\n    return rad * Mathf.Rad2Deg;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425191051-d5enhy4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425191051-d5enhy4",
				"updated": "20240425191055"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用示例"
				}
			]
		},
		{
			"ID": "20240425191056-qxus58i",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425191056-qxus58i",
				"style": "line-height: 22px;",
				"updated": "20240425191059"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "void Start()\n{\n    float rad = MathUtil.DegToRad(60);\n    print(\"弧度：\" + rad);\n    print(\"角度：\" + MathUtil.RadToDeg(rad));\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425191100-92bli74",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425191100-92bli74",
				"updated": "20240425191118"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "输出："
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 391px;",
						"style": "width: 381px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240425191118-gt7ow0q.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 381px;\" parent-style=\"width: 391px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240425191123-79ojxy9",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240425191123-79ojxy9",
				"updated": "20240425191236"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "距离判断相关 的方法"
				}
			]
		},
		{
			"ID": "20240425191240-36kk6dr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425191240-36kk6dr",
				"updated": "20240425191246"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在进行游戏开发时，我们经常要去判断两点之间的距离\n但是对于游戏中的对象，我们经常只需要判断它在某一个2D平面上的距离"
				}
			]
		},
		{
			"ID": "20240425191247-9mvalij",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425191247-9mvalij",
				"updated": "20240425191249"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如："
				}
			]
		},
		{
			"ID": "20240425191249-ecn7maj",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240425191249-ecn7maj",
				"updated": "20240425191301"
			},
			"Children": [
				{
					"ID": "20240425191249-0boa24u",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240425191249-0boa24u",
						"updated": "20240425191301"
					},
					"Children": [
						{
							"ID": "20240425191249-4zne0e7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240425191249-4zne0e7",
								"updated": "20240425191301"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "部分 2D 游戏中，我们往往只关心 xy 平面上的距离，z的变化不应该影响距离的计算"
								}
							]
						}
					]
				},
				{
					"ID": "20240425191249-37wo54q",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240425191249-37wo54q",
						"updated": "20240425191301"
					},
					"Children": [
						{
							"ID": "20240425191249-zbibhtd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240425191249-zbibhtd",
								"updated": "20240425191301"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "部分 3D 游戏中，我们往往只关心 xz 平面上的距离，y的变化不应该影响距离的计算"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240425191240-qbqls1d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425191240-qbqls1d",
				"updated": "20240425191304"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了方便我们得到对象之间在某个平面的距离，我们可以为其封装一些方法，专门用于计算 XZ、XY 平面上两点的距离"
				}
			]
		},
		{
			"ID": "20240425193659-idegx09",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425193659-idegx09",
				"style": "line-height: 22px;",
				"updated": "20240425193709"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/// \u003csummary\u003e\n/// 获取 XZ平面上 两点的距离\n/// \u003c/summary\u003e\n/// \u003cparam name=\"srcPos\"\u003e点1\u003c/param\u003e\n/// \u003cparam name=\"targetPos\"\u003e点2\u003c/param\u003e\n/// \u003creturns\u003eXZ平面上的距离\u003c/returns\u003e\npublic static float GetObjDistanceXZ(Vector3 srcPos, Vector3 targetPos)\n{\n    srcPos.y = 0;\n    targetPos.y = 0;\n    return Vector3.Distance(srcPos, targetPos);\n}\n\n/// \u003csummary\u003e\n/// 判断两点在XZ平面的距离 是否小于目标距离\n/// \u003c/summary\u003e\n/// \u003cparam name=\"srcPos\"\u003e点1\u003c/param\u003e\n/// \u003cparam name=\"targetPos\"\u003e点2\u003c/param\u003e\n/// \u003cparam name=\"dis\"\u003e判断距离\u003c/param\u003e\n/// \u003creturns\u003e是否小于判断距离\u003c/returns\u003e\npublic static bool CheckObjDistanceXZ(Vector3 srcPos, Vector3 targetPos, float dis)\n{\n    return GetObjDistanceXZ(srcPos, targetPos) \u003c= dis;\n}\n\n/// \u003csummary\u003e\n/// 获取 XY平面上 两点的距离\n/// \u003c/summary\u003e\n/// \u003cparam name=\"srcPos\"\u003e点1\u003c/param\u003e\n/// \u003cparam name=\"targetPos\"\u003e点2\u003c/param\u003e\n/// \u003creturns\u003eXY平面上的距离\u003c/returns\u003e\npublic static float GetObjDistanceXY(Vector3 srcPos, Vector3 targetPos)\n{\n    srcPos.z = 0;\n    targetPos.z = 0;\n    return Vector3.Distance(srcPos, targetPos);\n}\n\n/// \u003csummary\u003e\n/// 判断两点在XY平面的距离 是否小于目标距离\n/// \u003c/summary\u003e\n/// \u003cparam name=\"srcPos\"\u003e点1\u003c/param\u003e\n/// \u003cparam name=\"targetPos\"\u003e点2\u003c/param\u003e\n/// \u003cparam name=\"dis\"\u003e判断距离\u003c/param\u003e\n/// \u003creturns\u003e是否小于判断距离\u003c/returns\u003e\npublic static bool CheckObjDistanceXY(Vector3 srcPos, Vector3 targetPos, float dis)\n{\n    return GetObjDistanceXY(srcPos, targetPos) \u003c= dis;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425193620-iti3omg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425193620-iti3omg",
				"updated": "20240425193624"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用示例："
				}
			]
		},
		{
			"ID": "20240425193616-whm6keo",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425193616-whm6keo",
				"style": "line-height: 22px;",
				"updated": "20240425193656"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "void Start()\n{\n    Vector3 src = new Vector3(1, 5, 0);\n    Vector3 target = new Vector3(0, 19, 1);\n    print(MathUtil.GetObjDistanceXZ(src, target));\n    if (MathUtil.CheckObjDistanceXZ(src, target, 5))\n    {\n        print(\"两点间距离小于5\");\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425191305-4qd9dfg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425191305-4qd9dfg",
				"updated": "20240425193615"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "输出："
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240425193615-zfb7iwd.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240425193755-ib3zp6o",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240425193755-ib3zp6o",
				"updated": "20240425193756"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "屏幕外判断 的方法"
				}
			]
		},
		{
			"ID": "20240425193801-eesrfvw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425193801-eesrfvw",
				"updated": "20240425193803"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在进行游戏开发时，我们可能会有判断对象是否在屏幕外的需求\n因此我们可以封装一个判断某一个位置是否在屏幕显示范围外的方法"
				}
			]
		},
		{
			"ID": "20240425193923-2dh2jso",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425193923-2dh2jso",
				"style": "line-height: 22px;",
				"updated": "20240425194436"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/// \u003csummary\u003e\n/// 判断世界坐标系下的某个点是否在屏幕可见范围外\n/// \u003c/summary\u003e\n/// \u003cparam name=\"pos\"\u003e世界坐标系下的一个点的位置\u003c/param\u003e\n/// \u003creturns\u003e如果在可见范围外返回true，否则返回false\u003c/returns\u003e\npublic static bool IsWorldPosOutScreen(Vector3 pos)\n{\n    //将世界坐标转为屏幕坐标\n    Vector3 screenPos = Camera.main.WorldToScreenPoint(pos);\n    //判断是否在屏幕内\n    if (screenPos.x \u003e= 0 \u0026\u0026 screenPos.x \u003c= Screen.width \u0026\u0026\n        screenPos.y \u003e= 0 \u0026\u0026 screenPos.y \u003c= Screen.height)\n        return false;\n    return true;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425194436-r0jsmxe",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240425194436-r0jsmxe",
				"updated": "20240425194944"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "扇形范围判断 的方法"
				}
			]
		},
		{
			"ID": "20240425194951-8xohonx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425194951-8xohonx",
				"updated": "20240425195010"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在进行游戏开发时，我们经常需要判断目标是否在自己前方的扇形范围内，用于触发下一步的行为，\n比如 触发攻击、触发伤害等等，因此我们可以把 扇形范围判断 封装为一个方法，方便外部使用"
				}
			]
		},
		{
			"ID": "20240425194951-n4tgcbt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425194951-n4tgcbt",
				"updated": "20240425195013"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需求：我们只需要实现判断XZ平面的扇形范围内即可"
				}
			]
		},
		{
			"ID": "20240425200335-5h3gs5d",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425200335-5h3gs5d",
				"style": "line-height: 22px;",
				"updated": "20240425200421"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/// \u003csummary\u003e\n/// 判断某一个位置在XZ平面上是否在指定的扇形范围内，传入的坐标向量必须是基于同一个坐标系下的！！！\n/// \u003c/summary\u003e\n/// \u003cparam name=\"pos\"\u003e\u003c扇形中心点位置/param\u003e\n/// \u003cparam name=\"forward\"\u003e自己的面朝向\u003c/param\u003e\n/// \u003cparam name=\"targetPos\"\u003e目标对象\u003c/param\u003e\n/// \u003cparam name=\"radius\"\u003e半径\u003c/param\u003e\n/// \u003cparam name=\"angle\"\u003e扇形的角度\u003c/param\u003e\n/// \u003creturns\u003e目标是否在扇形范围内\u003c/returns\u003e\npublic static bool isInSectorRangeXZ(Vector3 pos, Vector3 forward, Vector3 targetPos, float radius, float angle)\n{\n    pos.y = 0;\n    forward.y = 0;\n    targetPos.y = 0;\n    //距离 + 角度\n    return Vector3.Distance(forward, targetPos) \u003c= radius \u0026\u0026 Vector3.Angle(forward, targetPos - pos) \u003c= angle / 2f;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425195015-zcnp7q6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425195015-zcnp7q6",
				"updated": "20240425200243"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用示例："
				}
			]
		},
		{
			"ID": "20240425200243-qtp0fh7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425200243-qtp0fh7",
				"style": "line-height: 22px;",
				"updated": "20240425200249"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "void Start()\n{\n    Vector3 pos = Vector3.zero;\n    Vector3 forward = Vector3.forward;\n    Vector3 targetPos = new Vector3(1f, 0f, 1f);\n    if (MathUtil.isInSectorRangeXZ(pos, forward, targetPos, 2, 90))\n    {\n        print(\"目标在扇形范围内\");\n    }\n    else\n    {\n        print(\"目标不在扇形范围内\");\n    }\n    if (MathUtil.isInSectorRangeXZ(pos, forward, targetPos, 2, 60))\n    {\n        print(\"目标在扇形范围内\");\n    }\n    else\n    {\n        print(\"目标不在扇形范围内\");\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425200312-qwcpsj5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425200312-qwcpsj5",
				"updated": "20240425200316"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "输出："
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 419px;",
						"style": "width: 409px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240425200312-2x9cqgd.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 409px;\" parent-style=\"width: 419px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240425200425-xarqrw3",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240425200425-xarqrw3",
				"updated": "20240425200456"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "射线检测 相关方法"
				}
			]
		},
		{
			"ID": "20240425200501-uz44hk8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425200501-uz44hk8",
				"updated": "20240425200509"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "射线检测是在游戏开发中经常会使用的功能，我们完全可以基于Unity的射线检测进行二次封装\n让其使用起来更加的方便，可以直接通过委托回调的形式对获取到的内容进行操作"
				}
			]
		},
		{
			"ID": "20240425200501-7q42xqg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425200501-7q42xqg",
				"updated": "20240425200519"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需求：通过委托回调的形式获取到射线检测得到的对象\n可以有几种重载，分别获取到"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "RaycastHit"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GameObject"
				},
				{
					"Type": "NodeText",
					"Data": "​、指定脚本"
				}
			]
		},
		{
			"ID": "20240425200541-o3aqsef",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425200541-o3aqsef",
				"style": "line-height: 22px;",
				"updated": "20240425202109"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/// \u003csummary\u003e\n/// 指定距离 指定层级 的射线检测，获取一个对象 \n/// \u003c/summary\u003e\n/// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n/// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的RaycastHit消息传递出去）\u003c/param\u003e\n/// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n/// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\npublic void Raycast(Ray ray, UnityAction\u003cRaycastHit\u003e callBack, float maxDistance, int layerMask)\n{\n    if (Physics.Raycast(ray, out RaycastHit hitInfo, maxDistance, layerMask))\n    {\n        callBack(hitInfo);\n    }\n}\n\n/// \u003csummary\u003e\n/// 指定距离 指定层级 的射线检测，获取一个对象 \n/// \u003c/summary\u003e\n/// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n/// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的GameObject消息传递出去）\u003c/param\u003e\n/// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n/// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\npublic void Raycast(Ray ray, UnityAction\u003cGameObject\u003e callBack, float maxDistance, int layerMask)\n{\n    if (Physics.Raycast(ray, out RaycastHit hitInfo, maxDistance, layerMask))\n    {\n        callBack(hitInfo.collider.gameObject);\n    }\n}\n\n/// \u003csummary\u003e\n/// 指定距离 指定层级 的射线检测，获取一个对象 \n/// \u003c/summary\u003e\n/// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n/// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的对象上指定的脚本传递出去）\u003c/param\u003e\n/// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n/// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\npublic void Raycast\u003cT\u003e(Ray ray, UnityAction\u003cT\u003e callBack, float maxDistance, int layerMask)\n{\n    if (Physics.Raycast(ray, out RaycastHit hitInfo, maxDistance, layerMask))\n    {\n        callBack(hitInfo.collider.gameObject.GetComponent\u003cT\u003e());\n    }\n}\n\n/// \u003csummary\u003e\n/// 指定距离 指定层级 的射线检测，可获取多个对象，会执行多次委托以传递\n/// \u003c/summary\u003e\n/// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n/// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的RaycastHit消息传递出去）\u003c/param\u003e\n/// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n/// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\npublic void RayCastAll(Ray ray, UnityAction\u003cRaycastHit\u003e callBack, float maxDistance, int layerMask)\n{\n    RaycastHit[] hitInfos = Physics.RaycastAll(ray, maxDistance, layerMask);\n    for (int i = 0; i \u003c hitInfos.Length; i++)\n    {\n        callBack.Invoke(hitInfos[i]);\n    }\n}\n\n/// \u003csummary\u003e\n/// 指定距离 指定层级 的射线检测，可获取多个对象，会执行多次委托以传递\n/// \u003c/summary\u003e\n/// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n/// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的GameObject消息传递出去）\u003c/param\u003e\n/// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n/// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\npublic void RayCastAll(Ray ray, UnityAction\u003cGameObject\u003e callBack, float maxDistance, int layerMask)\n{\n    RaycastHit[] hitInfos = Physics.RaycastAll(ray, maxDistance, layerMask);\n    for (int i = 0; i \u003c hitInfos.Length; i++)\n    {\n        callBack.Invoke(hitInfos[i].collider.gameObject);\n    }\n}\n\n/// \u003csummary\u003e\n/// 指定距离 指定层级 的射线检测，可获取多个对象，会执行多次委托以传递\n/// \u003c/summary\u003e\n/// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n/// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的对象上指定的脚本传递出去）\u003c/param\u003e\n/// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n/// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\npublic void RayCastAll\u003cT\u003e(Ray ray, UnityAction\u003cT\u003e callBack, float maxDistance, int layerMask)\n{\n    RaycastHit[] hitInfos = Physics.RaycastAll(ray, maxDistance, layerMask);\n    for (int i = 0; i \u003c hitInfos.Length; i++)\n    {\n        callBack.Invoke(hitInfos[i].collider.gameObject.GetComponent\u003cT\u003e());\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425200528-rj1ybsd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425200528-rj1ybsd",
				"updated": "20240425200535"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用示例："
				}
			]
		},
		{
			"ID": "20240425202625-517s07w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425202625-517s07w",
				"updated": "20240425202718"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "假设要通过射线检测是否点击到了场景上的怪物层对象"
				}
			]
		},
		{
			"ID": "20240425202640-a3x134u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425202640-a3x134u",
				"updated": "20240425202640"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 703px;",
						"style": "width: 693px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240425202640-l4uzzet.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 693px;\" parent-style=\"width: 703px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240425202656-0yf9gvx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425202656-0yf9gvx",
				"style": "line-height: 22px;",
				"updated": "20240425202757"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "void Update()\n{\n    if (Input.GetMouseButtonDown(0))\n    {\n        MathUtil.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition),\n                         GetRayCastObj,\n                         1000,\n                         1 \u003c\u003c LayerMask.NameToLayer(\"Monster\"));\n    }\n}\n\nprivate void GetRayCastObj(GameObject obj)\n{\n    print(obj.name);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425200535-p8qy1ku",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425200535-p8qy1ku",
				"updated": "20240425202916"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "点击到指定对象后输出："
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 444px;",
						"style": "width: 434px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240425202916-y2iuxev.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 434px;\" parent-style=\"width: 444px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240425202915-zq0vtp0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425202915-zq0vtp0",
				"updated": "20240425203014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "假设要检测多个对象"
				}
			]
		},
		{
			"ID": "20240425203040-scudgxc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425203040-scudgxc",
				"updated": "20240425203040"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 669px;",
						"style": "width: 659px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240425203040-3n5fglu.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 659px;\" parent-style=\"width: 669px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240425203124-nm3ojkr",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425203124-nm3ojkr",
				"style": "line-height: 22px;",
				"updated": "20240425203133"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "void Update()\n{\n    if (Input.GetMouseButtonDown(0))\n    {\n        MathUtil.RaycastAll(Camera.main.ScreenPointToRay(Input.mousePosition),\n                            GetRayCastObj,\n                            1000,\n                            1 \u003c\u003c LayerMask.NameToLayer(\"Monster\"));\n    }\n}\n\nprivate void GetRayCastObj(GameObject obj)\n{\n    print(obj.name);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425203137-j7796gi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425203137-j7796gi",
				"updated": "20240425203209"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "点击到两个指定对象后输出："
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 411px;",
						"style": "width: 401px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240425203208-ltf5b7f.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 401px;\" parent-style=\"width: 411px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240425203215-xa148ii",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240425203215-xa148ii",
				"updated": "20240425203322"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "范围检测 相关方法"
				}
			]
		},
		{
			"ID": "20240425203328-rdcqt6h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425203328-rdcqt6h",
				"updated": "20240425203332"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "范围检测是在游戏开发中经常会使用的功能，我们完全可以基于Unity的范围检测进行二次封装\n让其使用起来更加的方便，可以直接通过委托回调的形式对获取到的内容进行操作"
				}
			]
		},
		{
			"ID": "20240425203328-exwo5a9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425203328-exwo5a9",
				"updated": "20240425203337"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需求：\n通过委托回调的形式获取到范围检测得到的对象\n主要封装 盒装检测和球体检测 即可（胶囊检测使用很少）\n可以指定获取到"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Collider"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "GameObject"
				},
				{
					"Type": "NodeText",
					"Data": "​、指定脚本"
				}
			]
		},
		{
			"ID": "20240425210413-1a0hib8",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425210413-1a0hib8",
				"style": "line-height: 22px;",
				"updated": "20240425210447"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/// \u003csummary\u003e\n/// 进行盒状检测\n/// \u003c/summary\u003e\n/// \u003ctypeparam name=\"T\"\u003e要获取的对象类型\u003c/typeparam\u003e\n/// \u003cparam name=\"center\"\u003e盒子中心点\u003c/param\u003e\n/// \u003cparam name=\"rotation\"\u003e盒子的角度\u003c/param\u003e\n/// \u003cparam name=\"halfExtents\"\u003e长宽高的一半\u003c/param\u003e\n/// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n/// \u003cparam name=\"callBack\"\u003e回调函数\u003c/param\u003e\npublic static void OverlapBox\u003cT\u003e(Vector3 center, Quaternion rotation, Vector3 halfExtents, int layerMask, UnityAction\u003cT\u003e callBack) where T : cl\n{\n    Type type = typeof(T);\n    Collider[] colliders = Physics.OverlapBox(center, halfExtents, rotation, layerMask, QueryTriggerInteraction.Collide);\n    for (int i = 0; i \u003c colliders.Length; i++)\n    {\n        if (type == typeof(Collider))\n        {\n            callBack.Invoke(colliders[i] as T);\n        }\n        else if (type == typeof(GameObject))\n        {\n            callBack.Invoke(colliders[i].gameObject as T);\n        }\n        else\n        {\n            callBack.Invoke(colliders[i].gameObject.GetComponent\u003cT\u003e());\n        }\n    }\n}\n\n/// \u003csummary\u003e\n/// 进行球状检测\n/// \u003c/summary\u003e\n/// \u003ctypeparam name=\"T\"\u003e要获取的对象类型\u003c/typeparam\u003e\n/// \u003cparam name=\"center\"\u003e球体中心点\u003c/param\u003e\n/// \u003cparam name=\"radius\"\u003e球体半径\u003c/param\u003e\n/// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n/// \u003cparam name=\"callBack\"\u003e回调函数\u003c/param\u003e\npublic static void OverlapSphere\u003cT\u003e(Vector3 center, float radius, int layerMask, UnityAction\u003cT\u003e callBack) where T : class\n{\n    Type type = typeof(T);\n    Collider[] colliders = Physics.OverlapSphere(center, radius, layerMask, QueryTriggerInteraction.Collide);\n    for (int i = 0; i \u003c colliders.Length; i++)\n    {\n        if (type == typeof(Collider))\n        {\n            callBack.Invoke(colliders[i] as T);\n        }\n        else if (type == typeof(GameObject))\n        {\n            callBack.Invoke(colliders[i].gameObject as T);\n        }\n        else\n        {\n            callBack.Invoke(colliders[i].gameObject.GetComponent\u003cT\u003e());\n        }\n    }\n}\n\n/// \u003csummary\u003e\n/// 进行胶囊体检测\n/// \u003c/summary\u003e\n/// \u003ctypeparam name=\"T\"\u003e要获取的对象类型\u003c/typeparam\u003e\n/// \u003cparam name=\"point0\"\u003e胶囊体端点一\u003c/param\u003e\n/// \u003cparam name=\"point1\"\u003e胶囊体端点二\u003c/param\u003e\n/// \u003cparam name=\"radius\"\u003e胶囊体半径\u003c/param\u003e\n/// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n/// \u003cparam name=\"callBack\"\u003e回调函数\u003c/param\u003e\npublic static void OverlapCapsule\u003cT\u003e(Vector3 point0, Vector3 point1, float radius, int layerMask, UnityAction\u003cT\u003e callBack) where T : class\n{\n    Type type = typeof(T);\n    Collider[] colliders = Physics.OverlapCapsule(point0, point1, radius, layerMask, QueryTriggerInteraction.Collide);\n    for (int i = 0; i \u003c colliders.Length; i++)\n    {\n        if (type == typeof(Collider))\n        {\n            callBack.Invoke(colliders[i] as T);\n        }\n        else if (type == typeof(GameObject))\n        {\n            callBack.Invoke(colliders[i].gameObject as T);\n        }\n        else\n        {\n            callBack.Invoke(colliders[i].gameObject.GetComponent\u003cT\u003e());\n        }\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425205642-msamq3z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425205642-msamq3z",
				"updated": "20240425205749"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用示例："
				}
			]
		},
		{
			"ID": "20240425210127-iraw7yf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425210127-iraw7yf",
				"updated": "20240425210142"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "假设要检测原点位置附近的Monster层级对象："
				}
			]
		},
		{
			"ID": "20240425210212-nefr7ff",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425210212-nefr7ff",
				"updated": "20240425210212"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 616px;",
						"style": "width: 606px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240425210212-rs7n5gj.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 606px;\" parent-style=\"width: 616px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240425205750-do717an",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425205750-do717an",
				"style": "line-height: 22px;",
				"updated": "20240425205755"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "void Update()\n{\n    if (Input.GetMouseButtonDown(1))\n    {\n        MathUtil.OverlapBox\u003cGameObject\u003e(Vector3.zero,\n                                        Quaternion.identity,\n                                        0.5f * Vector3.one,\n                                        1 \u003c\u003c LayerMask.NameToLayer(\"Monster\"),\n                                        (obj) =\u003e {\n                                            print(obj.name);\n                                        });\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240425210257-53w4d57",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240425210257-53w4d57",
				"updated": "20240425210334"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "输出："
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 367px;",
						"style": "width: 357px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240425210334-jzhvgv1.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 357px;\" parent-style=\"width: 367px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240425210552-q8j0crj",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240425210552-q8j0crj",
				"updated": "20240425210555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "具体代码"
				}
			]
		},
		{
			"ID": "20240425210555-lmyltpv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240425210555-lmyltpv",
				"style": "line-height: 22px;",
				"updated": "20240425210603"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class MathUtil : MonoBehaviour\n{\n    #region 位置判断相关\n    /// \u003csummary\u003e\n    /// 判断世界坐标系下的某个点是否在屏幕可见范围外\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"pos\"\u003e世界坐标系下的一个点的位置\u003c/param\u003e\n    /// \u003creturns\u003e如果在可见范围外返回true，否则返回false\u003c/returns\u003e\n    public static bool IsWorldPosOutScreen(Vector3 pos)\n    {\n        //将世界坐标转为屏幕坐标\n        Vector3 screenPos = Camera.main.WorldToScreenPoint(pos);\n        //判断是否在屏幕内\n        if (screenPos.x \u003e= 0 \u0026\u0026 screenPos.x \u003c= Screen.width \u0026\u0026\n            screenPos.y \u003e= 0 \u0026\u0026 screenPos.y \u003c= Screen.height)\n            return false;\n        return true;\n    }\n\n    /// \u003csummary\u003e\n    /// 判断某一个位置在XZ平面上是否在指定的扇形范围内，传入的坐标向量必须是基于同一个坐标系下的！！！\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"pos\"\u003e\u003c扇形中心点位置/param\u003e\n    /// \u003cparam name=\"forward\"\u003e自己的面朝向\u003c/param\u003e\n    /// \u003cparam name=\"targetPos\"\u003e目标对象\u003c/param\u003e\n    /// \u003cparam name=\"radius\"\u003e半径\u003c/param\u003e\n    /// \u003cparam name=\"angle\"\u003e扇形的角度\u003c/param\u003e\n    /// \u003creturns\u003e目标是否在扇形范围内\u003c/returns\u003e\n    public static bool isInSectorRangeXZ(Vector3 pos, Vector3 forward, Vector3 targetPos, float radius, float angle)\n    {\n        pos.y = 0;\n        forward.y = 0;\n        targetPos.y = 0;\n        //距离 + 角度\n        return Vector3.Distance(forward, targetPos) \u003c= radius \u0026\u0026 Vector3.Angle(forward, targetPos - pos) \u003c= angle / 2f;\n    }\n    #endregion\n\n    #region 距离计算相关\n    /// \u003csummary\u003e\n    /// 获取 XZ平面上 两点的距离\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"srcPos\"\u003e点1\u003c/param\u003e\n    /// \u003cparam name=\"targetPos\"\u003e点2\u003c/param\u003e\n    /// \u003creturns\u003eXZ平面上的距离\u003c/returns\u003e\n    public static float GetObjDistanceXZ(Vector3 srcPos, Vector3 targetPos)\n    {\n        srcPos.y = 0;\n        targetPos.y = 0;\n        return Vector3.Distance(srcPos, targetPos);\n    }\n\n    /// \u003csummary\u003e\n    /// 判断两点在XZ平面的距离 是否小于目标距离\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"srcPos\"\u003e点1\u003c/param\u003e\n    /// \u003cparam name=\"targetPos\"\u003e点2\u003c/param\u003e\n    /// \u003cparam name=\"dis\"\u003e判断距离\u003c/param\u003e\n    /// \u003creturns\u003e是否小于判断距离\u003c/returns\u003e\n    public static bool CheckObjDistanceXZ(Vector3 srcPos, Vector3 targetPos, float dis)\n    {\n        return GetObjDistanceXZ(srcPos, targetPos) \u003c= dis;\n    }\n\n    /// \u003csummary\u003e\n    /// 获取 XY平面上 两点的距离\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"srcPos\"\u003e点1\u003c/param\u003e\n    /// \u003cparam name=\"targetPos\"\u003e点2\u003c/param\u003e\n    /// \u003creturns\u003eXY平面上的距离\u003c/returns\u003e\n    public static float GetObjDistanceXY(Vector3 srcPos, Vector3 targetPos)\n    {\n        srcPos.z = 0;\n        targetPos.z = 0;\n        return Vector3.Distance(srcPos, targetPos);\n    }\n\n    /// \u003csummary\u003e\n    /// 判断两点在XY平面的距离 是否小于目标距离\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"srcPos\"\u003e点1\u003c/param\u003e\n    /// \u003cparam name=\"targetPos\"\u003e点2\u003c/param\u003e\n    /// \u003cparam name=\"dis\"\u003e判断距离\u003c/param\u003e\n    /// \u003creturns\u003e是否小于判断距离\u003c/returns\u003e\n    public static bool CheckObjDistanceXY(Vector3 srcPos, Vector3 targetPos, float dis)\n    {\n        return GetObjDistanceXY(srcPos, targetPos) \u003c= dis;\n    }\n    #endregion\n\n    #region 角度转弧度\n    /// \u003csummary\u003e\n    /// 角度转弧度的方法\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"deg\"\u003e要转换的角度\u003c/param\u003e\n    /// \u003creturns\u003e转换出来的弧度\u003c/returns\u003e\n    public static float DegToRad(float deg)\n    {\n        return deg * Mathf.Deg2Rad;\n    }\n\n    /// \u003csummary\u003e\n    /// 弧度转角度的方法\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"rad\"\u003e要转换的弧度\u003c/param\u003e\n    /// \u003creturns\u003e转换出来的弧度\u003c/returns\u003e\n    public static float RadToDeg(float rad)\n    {\n        return rad * Mathf.Rad2Deg;\n    }\n    #endregion\n\n    #region 射线检测相关\n    /// \u003csummary\u003e\n    /// 指定距离 指定层级 的射线检测，获取一个对象 \n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的RaycastHit消息传递出去）\u003c/param\u003e\n    /// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n    /// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n    public static void Raycast(Ray ray, UnityAction\u003cRaycastHit\u003e callBack, float maxDistance, int layerMask)\n    {\n        if (Physics.Raycast(ray, out RaycastHit hitInfo, maxDistance, layerMask))\n        {\n            callBack(hitInfo);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 指定距离 指定层级 的射线检测，获取一个对象 \n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的GameObject消息传递出去）\u003c/param\u003e\n    /// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n    /// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n    public static void Raycast(Ray ray, UnityAction\u003cGameObject\u003e callBack, float maxDistance, int layerMask)\n    {\n        if (Physics.Raycast(ray, out RaycastHit hitInfo, maxDistance, layerMask))\n        {\n            callBack(hitInfo.collider.gameObject);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 指定距离 指定层级 的射线检测，获取一个对象 \n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的对象上指定的脚本传递出去）\u003c/param\u003e\n    /// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n    /// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n    public static void Raycast\u003cT\u003e(Ray ray, UnityAction\u003cT\u003e callBack, float maxDistance, int layerMask)\n    {\n        if (Physics.Raycast(ray, out RaycastHit hitInfo, maxDistance, layerMask))\n        {\n            callBack(hitInfo.collider.gameObject.GetComponent\u003cT\u003e());\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 指定距离 指定层级 的射线检测，可获取多个对象，会执行多次委托以传递\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的RaycastHit消息传递出去）\u003c/param\u003e\n    /// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n    /// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n    public static void RaycastAll(Ray ray, UnityAction\u003cRaycastHit\u003e callBack, float maxDistance, int layerMask)\n    {\n        RaycastHit[] hitInfos = Physics.RaycastAll(ray, maxDistance, layerMask);\n        for (int i = 0; i \u003c hitInfos.Length; i++)\n        {\n            callBack.Invoke(hitInfos[i]);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 指定距离 指定层级 的射线检测，可获取多个对象，会执行多次委托以传递\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的GameObject消息传递出去）\u003c/param\u003e\n    /// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n    /// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n    public static void RaycastAll(Ray ray, UnityAction\u003cGameObject\u003e callBack, float maxDistance, int layerMask)\n    {\n        RaycastHit[] hitInfos = Physics.RaycastAll(ray, maxDistance, layerMask);\n        for (int i = 0; i \u003c hitInfos.Length; i++)\n        {\n            callBack.Invoke(hitInfos[i].collider.gameObject);\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 指定距离 指定层级 的射线检测，可获取多个对象，会执行多次委托以传递\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"ray\"\u003e射线\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e回调函数（会把碰到的对象上指定的脚本传递出去）\u003c/param\u003e\n    /// \u003cparam name=\"maxDistance\"\u003e最大距离\u003c/param\u003e\n    /// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n    public static void RaycastAll\u003cT\u003e(Ray ray, UnityAction\u003cT\u003e callBack, float maxDistance, int layerMask)\n    {\n        RaycastHit[] hitInfos = Physics.RaycastAll(ray, maxDistance, layerMask);\n        for (int i = 0; i \u003c hitInfos.Length; i++)\n        {\n            callBack.Invoke(hitInfos[i].collider.gameObject.GetComponent\u003cT\u003e());\n        }\n    }\n    #endregion\n\n    #region 范围检测相关\n    /// \u003csummary\u003e\n    /// 进行盒状检测\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e要获取的对象类型\u003c/typeparam\u003e\n    /// \u003cparam name=\"center\"\u003e盒子中心点\u003c/param\u003e\n    /// \u003cparam name=\"rotation\"\u003e盒子的角度\u003c/param\u003e\n    /// \u003cparam name=\"halfExtents\"\u003e长宽高的一半\u003c/param\u003e\n    /// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e回调函数\u003c/param\u003e\n    public static void OverlapBox\u003cT\u003e(Vector3 center, Quaternion rotation, Vector3 halfExtents, int layerMask, UnityAction\u003cT\u003e callBack) where T : class\n    {\n        Type type = typeof(T);\n        Collider[] colliders = Physics.OverlapBox(center, halfExtents, rotation, layerMask, QueryTriggerInteraction.Collide);\n        for (int i = 0; i \u003c colliders.Length; i++)\n        {\n            if (type == typeof(Collider))\n            {\n                callBack.Invoke(colliders[i] as T);\n            }\n            else if (type == typeof(GameObject))\n            {\n                callBack.Invoke(colliders[i].gameObject as T);\n            }\n            else\n            {\n                callBack.Invoke(colliders[i].gameObject.GetComponent\u003cT\u003e());\n            }\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 进行球状检测\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e要获取的对象类型\u003c/typeparam\u003e\n    /// \u003cparam name=\"center\"\u003e球体中心点\u003c/param\u003e\n    /// \u003cparam name=\"radius\"\u003e球体半径\u003c/param\u003e\n    /// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e回调函数\u003c/param\u003e\n    public static void OverlapSphere\u003cT\u003e(Vector3 center, float radius, int layerMask, UnityAction\u003cT\u003e callBack) where T : class\n    {\n        Type type = typeof(T);\n        Collider[] colliders = Physics.OverlapSphere(center, radius, layerMask, QueryTriggerInteraction.Collide);\n        for (int i = 0; i \u003c colliders.Length; i++)\n        {\n            if (type == typeof(Collider))\n            {\n                callBack.Invoke(colliders[i] as T);\n            }\n            else if (type == typeof(GameObject))\n            {\n                callBack.Invoke(colliders[i].gameObject as T);\n            }\n            else\n            {\n                callBack.Invoke(colliders[i].gameObject.GetComponent\u003cT\u003e());\n            }\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 进行胶囊体检测\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e要获取的对象类型\u003c/typeparam\u003e\n    /// \u003cparam name=\"point0\"\u003e胶囊体端点一\u003c/param\u003e\n    /// \u003cparam name=\"point1\"\u003e胶囊体端点二\u003c/param\u003e\n    /// \u003cparam name=\"radius\"\u003e胶囊体半径\u003c/param\u003e\n    /// \u003cparam name=\"layerMask\"\u003e层级筛选\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e回调函数\u003c/param\u003e\n    public static void OverlapCapsule\u003cT\u003e(Vector3 point0, Vector3 point1, float radius, int layerMask, UnityAction\u003cT\u003e callBack) where T : class\n    {\n        Type type = typeof(T);\n        Collider[] colliders = Physics.OverlapCapsule(point0, point1, radius, layerMask, QueryTriggerInteraction.Collide);\n        for (int i = 0; i \u003c colliders.Length; i++)\n        {\n            if (type == typeof(Collider))\n            {\n                callBack.Invoke(colliders[i] as T);\n            }\n            else if (type == typeof(GameObject))\n            {\n                callBack.Invoke(colliders[i].gameObject as T);\n            }\n            else\n            {\n                callBack.Invoke(colliders[i].gameObject.GetComponent\u003cT\u003e());\n            }\n        }\n    }\n    #endregion\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}