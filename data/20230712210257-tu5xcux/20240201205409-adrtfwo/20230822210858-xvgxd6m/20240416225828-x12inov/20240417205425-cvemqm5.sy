{
	"ID": "20240417205425-cvemqm5",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20240417205425-cvemqm5",
		"title": "UFL5-3——添加引用计数的Resource资源加载模块",
		"type": "doc",
		"updated": "20240417225244"
	},
	"Children": [
		{
			"ID": "20240417205425-13cpz2z",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240417205425-13cpz2z",
				"updated": "20240417205452"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过引用计数判断资源是否使用的问题"
				}
			]
		},
		{
			"ID": "20240417205500-nqi8jsq",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240417205500-nqi8jsq",
				"updated": "20240417205503"
			},
			"Children": [
				{
					"ID": "20240417205503-s3s0223",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240417205503-s3s0223",
						"updated": "20240417205503"
					},
					"Children": [
						{
							"ID": "20240417205503-i8to1xl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205503-i8to1xl",
								"updated": "20240417205503"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在卸载资源时，我们并不知道是否还有地方使用着该资源"
								}
							]
						}
					]
				},
				{
					"ID": "20240417205503-qg68gbt",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240417205503-qg68gbt",
						"updated": "20240417205503"
					},
					"Children": [
						{
							"ID": "20240417205503-oc23241",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205503-oc23241",
								"updated": "20240417205505"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UnloadUnusedAssets"
								},
								{
									"Type": "NodeText",
									"Data": "​是卸载没有使用的资源，我们无法判断是否使用"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240417205519-an6vypd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240417205519-an6vypd",
				"updated": "20240417205540"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们可以使用引用计数来解决上述问题"
				}
			]
		},
		{
			"ID": "20240417205545-37ow99w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240417205545-37ow99w",
				"updated": "20240417205550"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "引用计数是一种内存管理技术，用于跟踪资源被引用的次数\n我们通过一个整形"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "int"
				},
				{
					"Type": "NodeText",
					"Data": "​变量来记录资源的使用次数\n当有对象引用该资源时，计数器会增加；当对象不再引用该资源时，计数器会减少"
				}
			]
		},
		{
			"ID": "20240417205550-um4290e",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240417205550-um4290e",
				"updated": "20240417210252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "向"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ResManager"
				},
				{
					"Type": "NodeText",
					"Data": "​中加入引用计数功能"
				}
			]
		},
		{
			"ID": "20240417205606-l34xycj",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240417205606-l34xycj",
				"updated": "20240417225227"
			},
			"Children": [
				{
					"ID": "20240417205613-3q2eyew",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240417205613-3q2eyew",
						"updated": "20240417205613"
					},
					"Children": [
						{
							"ID": "20240417205613-a1wyk0p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205613-a1wyk0p",
								"updated": "20240417205615"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "为"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "ResInfo"
								},
								{
									"Type": "NodeText",
									"Data": "​类加入引用计数成员变量和方法"
								}
							]
						},
						{
							"ID": "20240417212257-1807hlo",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417212257-1807hlo",
								"style": "line-height: 22px;",
								"updated": "20240417212309"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public class ResInfo\u003cT\u003e : ResInfoBase\n{\n    public T asset;                     //资源\n    public UnityAction\u003cT\u003e callBack;     //用于异步资源加载完后 传递资源到外部的委托\n    public Coroutine coroutine;         //用于异步加载时 开启的协同程序\n    public bool isDel;                  //是否需要移除\n    public int refCount;                //引用计数\n\n    public void AddRefCount()\n    {\n        ++refCount;\n    }\n\n    public void SubRedCount()\n    {\n        --refCount;\n        if (refCount \u003c 0)\n            Debug.LogError(\"引用计数小于0了，请检查使用或者卸载是否配对执行\");\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				},
				{
					"ID": "20240417205613-jsw882g",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240417205613-jsw882g",
						"updated": "20240417205613"
					},
					"Children": [
						{
							"ID": "20240417205613-oo4atwk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205613-oo4atwk",
								"updated": "20240417221235"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用资源时引用计数加一"
								}
							]
						},
						{
							"ID": "20240417212315-7uy22kl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417212315-7uy22kl",
								"updated": "20240417221220"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "每当调用加载资源时（无论是同步加载"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Load"
								},
								{
									"Type": "NodeText",
									"Data": "​还是异步加载"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "LoadAsync"
								},
								{
									"Type": "NodeText",
									"Data": "​），都会添加引用计数"
								}
							]
						},
						{
							"ID": "20240417212312-iu33umw",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417212312-iu33umw",
								"style": "line-height: 22px;",
								"updated": "20240417212531"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public T Load\u003cT\u003e(string path) where T : UnityEngine.Object\n{\n    //资源的唯一ID，通过路径名_资源类型拼接而成\n    string resName = $\"{path}_{typeof(T).Name}\";\n    ResInfo\u003cT\u003e info;\n    //字典中不存在资源时\n    if (!resDic.ContainsKey(resName))\n    {\n        //直接同步加载，并且记录资源消息到字典中，方便下次直接取出来用\n        T res = Resources.Load\u003cT\u003e(path);\n        info = new ResInfo\u003cT\u003e();\n        info.asset = res;\n        info.AddRefCount();         //增加引用计数\n        resDic.Add(resName, info);\n        return res;\n    }\n    else\n    {\n        //取出字典的记录\n        info = resDic[resName] as ResInfo\u003cT\u003e;\n        info.AddRefCount();         //增加引用计数\n        //存在异步加载且还在加载中\n        if (info.asset == null)\n        {\n\t\t\t//...\n            return res;\n        }\n        //已经加载过资源\n        else\n        {\n            return info.asset;\n        }\n    }\n}\n\npublic void LoadAsync\u003cT\u003e(string path, UnityAction\u003cT\u003e callBack) where T : UnityEngine.Object\n{\n    //资源的唯一ID，通过路径名_资源类型拼接而成\n    string resName = $\"{path}_{typeof(T).Name}\";\n    ResInfo\u003cT\u003e info;\n    //不存在消息记录时，说明资源未加载过\n    if (!resDic.ContainsKey(resName))\n    {\n        info = new ResInfo\u003cT\u003e();        //声明一个 资源信息对象\n        info.AddRefCount();             //增加引用计数\n        resDic.Add(resName, info);      //将资源记录添加到资源内（资源没有加载成功）\n        info.callBack += callBack;      //记录传入的委托函数，一会加载完成了再使用\n        //通过协同程序去异步加载资源，并记录该协同程序\n        info.coroutine = MonoManager.Instance.StartCoroutine(ReallyLoadAsync\u003cT\u003e(path));\n    }\n    //存在消息记录时，资源已经加载过\n    else\n    {\n        info = resDic[resName] as ResInfo\u003cT\u003e;   //从字典中取出资源信息\n        info.AddRefCount();                     //增加引用计数\n        //资源尚未加载成功\n        if (info.asset == null)\n            info.callBack += callBack;          //将回调函数添加到委托内，等待加载完毕后一起执行\n        //资源已经加载完毕\n        else\n            callBack?.Invoke(info.asset);       //直接执行传入的回调函数\n    }\n}\n\npublic void LoadAsync(string path, Type type, UnityAction\u003cUnityEngine.Object\u003e callBack)\n{\n    //资源的唯一ID，通过路径名_资源类型拼接而成\n    string resName = $\"{path}_{type.Name}\";\n    ResInfo\u003cUnityEngine.Object\u003e info;\n    //不存在消息记录时，说明资源未加载过\n    if (!resDic.ContainsKey(resName))\n    {\n        info = new ResInfo\u003cUnityEngine.Object\u003e();   //声明一个 资源信息对象\n        info.AddRefCount();             //增加引用计数\n        resDic.Add(resName, info);      //将资源记录添加到资源内（资源没有加载成功）\n        info.callBack += callBack;      //记录传入的委托函数，一会加载完成了再使用\n        //通过协同程序去异步加载资源，并记录该协同程序\n        info.coroutine = MonoManager.Instance.StartCoroutine(ReallyLoadAsync(path, type));\n    }\n    //存在消息记录时，资源已经加载过\n    else\n    {\n        info = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;   //从字典中取出资源信息\n        info.AddRefCount();                     //增加引用计数\n        //资源尚未加载成功\n        if (info.asset == null)\n            info.callBack += callBack;          //将回调函数添加到委托内，等待加载完毕后一起执行\n        //资源已经加载完毕\n        else\n            callBack?.Invoke(info.asset);       //直接执行传入的回调函数\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				},
				{
					"ID": "20240417205613-b7hlrhg",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20240417205613-b7hlrhg",
						"updated": "20240417205613"
					},
					"Children": [
						{
							"ID": "20240417205613-qlh8c0o",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205613-qlh8c0o",
								"updated": "20240417221245"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "不使用资源时引用计数减一"
								}
							]
						},
						{
							"ID": "20240417212555-k4xmp5s",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417212555-k4xmp5s",
								"updated": "20240417212615"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "每当调用卸载资源时，引用计数就减一"
								}
							]
						},
						{
							"ID": "20240417212616-7q4xut4",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417212616-7q4xut4",
								"style": "line-height: 22px;",
								"updated": "20240417220524"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public void UnloadAsset\u003cT\u003e(string path)\n{\n    string resName = $\"{path}_{typeof(T).Name}\";\n    //是否存在对应资源\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cT\u003e resInfo = resDic[resName] as ResInfo\u003cT\u003e;\n        resInfo.SubRefCount();      //减少引用计数\n\t\t//...\n    }\n}\n\npublic void UnloadAsset(string path, Type type)\n{\n    string resName = $\"{path}_{type.Name}\";\n    //是否存在对应资源\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cUnityEngine.Object\u003e resInfo = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;\n        resInfo.SubRefCount();      //减少引用计数\n\t\t//...\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				},
				{
					"ID": "20240417205613-qksp2yg",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20240417205613-qksp2yg",
						"updated": "20240417205613"
					},
					"Children": [
						{
							"ID": "20240417205613-p9lao8o",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205613-p9lao8o",
								"updated": "20240417215439"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "处理异步回调问题，某一个异步加载决定不使用资源了应该移除该异步对应的回调函数的记录，而不是直接移除资源"
								}
							]
						}
					]
				},
				{
					"ID": "20240417205613-wtembrx",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20240417205613-wtembrx",
						"updated": "20240417205613"
					},
					"Children": [
						{
							"ID": "20240417205613-rowamg2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205613-rowamg2",
								"updated": "20240417205613"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "修改移除资源函数逻辑，引用计数为0时才真正移除资源"
								}
							]
						},
						{
							"ID": "20240417220545-ut1296p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417220545-ut1296p",
								"updated": "20240417222619"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "修改移除资源方法"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UnloadAsset"
								},
								{
									"Type": "NodeText",
									"Data": "​的逻辑，添加一个可以移除回调的参数，便于在资源未加载完毕时移除回调函数，\n同时，只有检查到"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "资源已经加载出来且资源引用计数归0"
								},
								{
									"Type": "NodeText",
									"Data": "时，才需要移除资源"
								}
							]
						},
						{
							"ID": "20240417220850-6me2b41",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417220850-6me2b41",
								"style": "line-height: 22px;",
								"updated": "20240417220907"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public void UnloadAsset\u003cT\u003e(string path, UnityAction\u003cT\u003e callBack = null)\n{\n    string resName = $\"{path}_{typeof(T).Name}\";\n    //是否存在对应资源\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cT\u003e resInfo = resDic[resName] as ResInfo\u003cT\u003e;\n        resInfo.SubRefCount();      //减少引用计数\n\n        //资源已经加载结束，且引用计数归0\n        if (resInfo.asset != null \u0026\u0026 resInfo.refCount == 0)\n        {\n            //从字典移除，通过api卸载资源\n            resDic.Remove(resName);\n            Resources.UnloadAsset(resInfo.asset as UnityEngine.Object);\n        }\n        //资源正在异步加载中\n        else if (resInfo.asset == null)\n        {\n            if (callBack != null)\n                resInfo.callBack -= callBack;\n        }\n    }\n}\n\n// 指定卸载一个资源\npublic void UnloadAsset(string path, Type type, UnityAction\u003cUnityEngine.Object\u003e callBack = null)\n{\n    string resName = $\"{path}_{type.Name}\";\n    //是否存在对应资源\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cUnityEngine.Object\u003e resInfo = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;\n        resInfo.SubRefCount();      //减少引用计数\n        //资源已经加载结束\n        if (resInfo.asset != null \u0026\u0026 resInfo.refCount == 0)\n        {\n            //从字典移除，通过api卸载资源\n            resDic.Remove(resName);\n            Resources.UnloadAsset(resInfo.asset as UnityEngine.Object);\n        }\n        //资源正在异步加载中\n        else if (resInfo.asset == null)\n        {\n            //当异步加载不想使用时，我们应该移除它的回调记录，而不是直接去卸载资源\n            if (callBack != null)\n                resInfo.callBack -= callBack;\n        }\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240417220910-xacl120",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417220910-xacl120",
								"updated": "20240417222802"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当资源异步加载完毕但是发现资源引用计数已经归0的时候，需要直接移除资源，\n为此，异步加载资源的协程"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "ReallyLoadAsync"
								},
								{
									"Type": "NodeText",
									"Data": "​调用移除资源方法"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UnloadAsset"
								},
								{
									"Type": "NodeText",
									"Data": "​的条件需要从 移除标识 改为 资源引用计数归0"
								}
							]
						},
						{
							"ID": "20240417221323-p8rpz5d",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417221323-p8rpz5d",
								"style": "line-height: 22px;",
								"updated": "20240417221400"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "private IEnumerator ReallyLoadAsync\u003cT\u003e(string path) where T : UnityEngine.Object\n{\n    //异步加载资源\n    ResourceRequest req = Resources.LoadAsync\u003cT\u003e(path);\n    //等待资源加载结束后，才会继续执行yield return后面的代码\n    yield return req;\n    string resName = $\"{path}_{typeof(T).Name}\";\n    //资源加载结束，将资源传到外部的委托函数去进行调用\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cT\u003e resInfo = resDic[resName] as ResInfo\u003cT\u003e;     //取出资源消息\n        resInfo.asset = req.asset as T;                         //将资源记录到资源信息内\n        //如果发现引用计数归0，说明需要移除该资源\n        if (resInfo.refCount == 0)\n        {\n            UnloadAsset\u003cT\u003e(path);\n        }\n        else\n        {\n            resInfo.callBack?.Invoke(resInfo.asset);            //将加载出来的资源传递出去\n            //加载完毕后，这些引用就可以清空，避免引用的占用带来的内存泄露问题\n            resInfo.callBack = null;\n            resInfo.coroutine = null;\n        }\n    }\n}\n\nprivate IEnumerator ReallyLoadAsync(string path, Type type)\n{\n    //异步加载资源\n    ResourceRequest req = Resources.LoadAsync(path, type);\n    //等待资源加载结束后，才会继续执行yield return后面的代码\n    yield return req;\n    string resName = $\"{path}_{type.Name}\";\n    //资源加载结束，将资源传到外部的委托函数去进行调用\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cUnityEngine.Object\u003e resInfo = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;   //取出资源消息\n        resInfo.asset = req.asset;                              //将资源记录到资源信息内\n        //如果发现引用计数归0，说明需要移除该资源\n        if (resInfo.refCount == 0)\n        {\n            UnloadAsset(path, type);\n        }\n        else\n        {\n            resInfo.callBack?.Invoke(resInfo.asset);            //将加载出来的资源传递出去\n            //加载完毕后，这些引用就可以清空，避免引用的占用带来的内存泄露问题\n            resInfo.callBack = null;\n            resInfo.coroutine = null;\n        }\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240417221556-u9sj6hm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417221556-u9sj6hm",
								"updated": "20240417221626"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "针对以上的内容进行测试，首先需要声明一个查看引用计数的方法"
								}
							]
						},
						{
							"ID": "20240417221612-recm8lk",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417221612-recm8lk",
								"style": "line-height: 22px;",
								"updated": "20240417221635"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public int GetRefCount\u003cT\u003e(string path)\n{\n    string resName = $\"{path}_{typeof(T).Name}\";\n    if (resDic.ContainsKey(resName))\n    {\n        return (resDic[resName] as ResInfo\u003cT\u003e).refCount;\n    }\n    return 0;\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240417221636-6xevwk7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417221636-6xevwk7",
								"updated": "20240417221656"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "然后调用加载和卸载方法，观察引用计数变化"
								}
							]
						},
						{
							"ID": "20240417221657-qrd9vgx",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417221657-qrd9vgx",
								"style": "line-height: 22px;",
								"updated": "20240417221709"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "ResManager.Instance.LoadAsync\u003cGameObject\u003e(\"Test\", TestFun);\nDebug.Log(ResManager.Instance.GetRefCount\u003cGameObject\u003e(\"Test\"));\nResManager.Instance.LoadAsync\u003cGameObject\u003e(\"Test\", TestFun);\nDebug.Log(ResManager.Instance.GetRefCount\u003cGameObject\u003e(\"Test\"));\n\nResManager.Instance.UnloadAsset\u003cGameObject\u003e(\"Test\", TestFun);\nDebug.Log(ResManager.Instance.GetRefCount\u003cGameObject\u003e(\"Test\"));\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240417221710-4k999gn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417221710-4k999gn",
								"updated": "20240417221724"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "输出："
								},
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText",
											"Data": "image"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "assets/image-20240417221724-hm8dany.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						}
					]
				},
				{
					"ID": "20240417205613-ethlvl5",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ni4=",
						"Num": 6
					},
					"Properties": {
						"id": "20240417205613-ethlvl5",
						"updated": "20240417205613"
					},
					"Children": [
						{
							"ID": "20240417205613-cbpwrn5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205613-cbpwrn5",
								"updated": "20240417205618"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "考虑资源频繁移除问题，加入马上移除"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "bool"
								},
								{
									"Type": "NodeText",
									"Data": "​标签"
								}
							]
						},
						{
							"ID": "20240417222333-98684zs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417222333-98684zs",
								"updated": "20240417222533"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将原来作为删除标识的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "ResInfo.isDel"
								},
								{
									"Type": "NodeText",
									"Data": "​（在上述的修改下，原来的作用已经废弃），改为判断是否在引用计数归0后就直接移除资源"
								}
							]
						},
						{
							"ID": "20240417222535-bwu7hjp",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417222535-bwu7hjp",
								"style": "line-height: 22px;",
								"updated": "20240417222551"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public class ResInfo\u003cT\u003e : ResInfoBase\n{\n    public T asset;                     //资源\n    public UnityAction\u003cT\u003e callBack;     //用于异步资源加载完后 传递资源到外部的委托\n    public Coroutine coroutine;         //用于异步加载时 开启的协同程序\n    public bool isDel;                  //当引用计数归0时，是否需要立刻移除\n    public int refCount;                //引用计数\n\n    public void AddRefCount()\n    {\n        ++refCount;\n    }\n\n    public void SubRefCount()\n    {\n        --refCount;\n        if (refCount \u003c 0)\n            Debug.LogError(\"引用计数小于0了，请检查使用或者卸载是否配对执行\");\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240417222553-dauj623",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417222553-dauj623",
								"updated": "20240417223027"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "因此，在移除资源方法"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UnloadAsset"
								},
								{
									"Type": "NodeText",
									"Data": "​中，添加一个是否在引用计数归0后就移除资源的参数，每当调用该方法，就记录传入的值\n同时根据"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "ResInfo.isDel"
								},
								{
									"Type": "NodeText",
									"Data": "​是否为"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "true"
								},
								{
									"Type": "NodeText",
									"Data": "​，决定是否在引用计数归0后就移除资源"
								}
							]
						},
						{
							"ID": "20240417222739-jws835w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417222739-jws835w",
								"updated": "20240417223859"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "ReallyLoadAsync"
								},
								{
									"Type": "NodeText",
									"Data": "​中调用的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UnloadAsset"
								},
								{
									"Type": "NodeText",
									"Data": "​，需要传入"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "ResInfo"
								},
								{
									"Type": "NodeText",
									"Data": "​原本的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "isDel"
								},
								{
									"Type": "NodeText",
									"Data": "​的值，保持原有状态"
								}
							]
						},
						{
							"ID": "20240417222706-d8mms41",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417222706-d8mms41",
								"style": "line-height: 22px;",
								"updated": "20240417223221"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public void UnloadAsset\u003cT\u003e(string path, bool isDel = false, UnityAction\u003cT\u003e callBack = null)\n{\n    string resName = $\"{path}_{typeof(T).Name}\";\n    //是否存在对应资源\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cT\u003e resInfo = resDic[resName] as ResInfo\u003cT\u003e;\n        resInfo.SubRefCount();      //减少引用计数\n        resInfo.isDel = isDel;      //记录引用计数为0时，是否立刻移除\n        //资源已经加载结束，且引用计数归0\n        if (resInfo.asset != null \u0026\u0026 resInfo.refCount == 0 \u0026\u0026 resInfo.isDel == true)\n        {\n            //从字典移除，通过api卸载资源\n            resDic.Remove(resName);\n            Resources.UnloadAsset(resInfo.asset as UnityEngine.Object);\n        }\n        //资源正在异步加载中\n        else if (resInfo.asset == null)\n        {\n            if (callBack != null)\n                resInfo.callBack -= callBack;\n        }\n    }\n}\n\npublic void UnloadAsset(string path, Type type, bool isDel = false, UnityAction\u003cUnityEngine.Object\u003e callBack = null)\n{\n    string resName = $\"{path}_{type.Name}\";\n    //是否存在对应资源\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cUnityEngine.Object\u003e resInfo = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;\n        resInfo.SubRefCount();      //减少引用计数\n        resInfo.isDel = isDel;      //记录引用计数为0时，是否立刻移除\n        //资源已经加载结束\n        if (resInfo.asset != null \u0026\u0026 resInfo.refCount == 0 \u0026\u0026 resInfo.isDel == true)\n        {\n            //从字典移除，通过api卸载资源\n            resDic.Remove(resName);\n            Resources.UnloadAsset(resInfo.asset as UnityEngine.Object);\n        }\n        //资源正在异步加载中\n        else if (resInfo.asset == null)\n        {\n            //当异步加载不想使用时，我们应该移除它的回调记录，而不是直接去卸载资源\n            if (callBack != null)\n                resInfo.callBack -= callBack;\n        }\n    }\n}\n\nprivate IEnumerator ReallyLoadAsync\u003cT\u003e(string path) where T : UnityEngine.Object\n{\n    //异步加载资源\n    ResourceRequest req = Resources.LoadAsync\u003cT\u003e(path);\n    //等待资源加载结束后，才会继续执行yield return后面的代码\n    yield return req;\n    string resName = $\"{path}_{typeof(T).Name}\";\n    //资源加载结束，将资源传到外部的委托函数去进行调用\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cT\u003e resInfo = resDic[resName] as ResInfo\u003cT\u003e;     //取出资源消息\n        resInfo.asset = req.asset as T;                         //将资源记录到资源信息内\n        //如果发现引用计数归0，说明需要移除该资源\n        if (resInfo.refCount == 0)\n        {\n            UnloadAsset\u003cT\u003e(path, resInfo.isDel);\n        }\n        else\n        {\n            resInfo.callBack?.Invoke(resInfo.asset);            //将加载出来的资源传递出去\n            //加载完毕后，这些引用就可以清空，避免引用的占用带来的内存泄露问题\n            resInfo.callBack = null;\n            resInfo.coroutine = null;\n        }\n    }\n}\n\nprivate IEnumerator ReallyLoadAsync(string path, Type type)\n{\n    //异步加载资源\n    ResourceRequest req = Resources.LoadAsync(path, type);\n    //等待资源加载结束后，才会继续执行yield return后面的代码\n    yield return req;\n    string resName = $\"{path}_{type.Name}\";\n    //资源加载结束，将资源传到外部的委托函数去进行调用\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cUnityEngine.Object\u003e resInfo = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;   //取出资源消息\n        resInfo.asset = req.asset;                              //将资源记录到资源信息内\n        //如果发现引用计数归0，说明需要移除该资源\n        if (resInfo.refCount == 0)\n        {\n            UnloadAsset(path, type, resInfo.isDel);\n        }\n        else\n        {\n            resInfo.callBack?.Invoke(resInfo.asset);            //将加载出来的资源传递出去\n            //加载完毕后，这些引用就可以清空，避免引用的占用带来的内存泄露问题\n            resInfo.callBack = null;\n            resInfo.coroutine = null;\n        }\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				},
				{
					"ID": "20240417205613-t3ui83p",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ny4=",
						"Num": 7
					},
					"Properties": {
						"id": "20240417205613-t3ui83p",
						"updated": "20240417205613"
					},
					"Children": [
						{
							"ID": "20240417205613-zozysbo",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205613-zozysbo",
								"updated": "20240417223247"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "修改移除不使用资源函数"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UnloadUnusedAssets"
								},
								{
									"Type": "NodeText",
									"Data": "​逻辑，释放时引用计数为0的记录"
								}
							]
						},
						{
							"ID": "20240417223633-dd682f5",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417223633-dd682f5",
								"style": "line-height: 22px;",
								"updated": "20240417223644"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public void UnloadUnusedAssets(UnityAction callBack)\n{\n    MonoManager.Instance.StartCoroutine(ReallyUnloadUnusedAssets(callBack));\n}\n\nprivate IEnumerator ReallyUnloadUnusedAssets(UnityAction callBack)\n{\n    //在真正移除不使用的资源之前，应该将字典内引用计数归0的资源消息且尚未移除记录的移除掉\n    List\u003cstring\u003e list = new List\u003cstring\u003e();\n    foreach (string path in resDic.Keys)\n    {\n        if (resDic[path].refCount == 0)\n            list.Add(path);\n    }\n    foreach (string path in list)\n    {\n        resDic.Remove(path);\n    }\n\n    AsyncOperation ao = Resources.UnloadUnusedAssets();\n    yield return ao;\n    callBack?.Invoke();\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				},
				{
					"ID": "20240417224755-1ldnu0o",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "OC4=",
						"Num": 8
					},
					"Properties": {
						"id": "20240417224755-1ldnu0o",
						"updated": "20240417225227"
					},
					"Children": [
						{
							"ID": "20240417224755-ddxnm2p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417224755-ddxnm2p",
								"updated": "20240417225000"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "为移除资源方法"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UnloadAsset"
								},
								{
									"Type": "NodeText",
									"Data": "​添加一个是否减少引用计数的参数，用于内部的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "ReallyLoadAsync"
								},
								{
									"Type": "NodeText",
									"Data": "​调用"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UnloadAsset"
								},
								{
									"Type": "NodeText",
									"Data": "​时不减少引用计数"
								}
							]
						},
						{
							"ID": "20240417225000-4sw8ky7",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417225000-4sw8ky7",
								"style": "line-height: 22px;",
								"updated": "20240417225227"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public void UnloadAsset\u003cT\u003e(string path, bool isDel = false, UnityAction\u003cT\u003e callBack = null, bool isSub = true)\n{\n    string resName = $\"{path}_{typeof(T).Name}\";\n    //是否存在对应资源\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cT\u003e resInfo = resDic[resName] as ResInfo\u003cT\u003e;\n        if (isSub)\n            resInfo.SubRefCount();  //减少引用计数\n        resInfo.isDel = isDel;      //记录引用计数为0时，是否立刻移除\n        //资源已经加载结束，且引用计数归0\n        if (resInfo.asset != null \u0026\u0026 resInfo.refCount == 0 \u0026\u0026 resInfo.isDel == true)\n        {\n            //从字典移除，通过api卸载资源\n            resDic.Remove(resName);\n            Resources.UnloadAsset(resInfo.asset as UnityEngine.Object);\n        }\n        //资源正在异步加载中\n        else if (resInfo.asset == null)\n        {\n            if (callBack != null)\n                resInfo.callBack -= callBack;\n        }\n    }\n}\n\n// 指定卸载一个资源\npublic void UnloadAsset(string path, Type type, bool isDel = false, UnityAction\u003cUnityEngine.Object\u003e callBack = null, bool isSub = true)\n{\n    string resName = $\"{path}_{type.Name}\";\n    //是否存在对应资源\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cUnityEngine.Object\u003e resInfo = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;\n        if (isSub)\n            resInfo.SubRefCount();  //减少引用计数\n        resInfo.isDel = isDel;      //记录引用计数为0时，是否立刻移除\n        //资源已经加载结束\n        if (resInfo.asset != null \u0026\u0026 resInfo.refCount == 0 \u0026\u0026 resInfo.isDel == true)\n        {\n            //从字典移除，通过api卸载资源\n            resDic.Remove(resName);\n            Resources.UnloadAsset(resInfo.asset as UnityEngine.Object);\n        }\n        //资源正在异步加载中\n        else if (resInfo.asset == null)\n        {\n            //当异步加载不想使用时，我们应该移除它的回调记录，而不是直接去卸载资源\n            if (callBack != null)\n                resInfo.callBack -= callBack;\n        }\n    }\n}\n\nprivate IEnumerator ReallyLoadAsync\u003cT\u003e(string path) where T : UnityEngine.Object\n{\n    //异步加载资源\n    ResourceRequest req = Resources.LoadAsync\u003cT\u003e(path);\n    //等待资源加载结束后，才会继续执行yield return后面的代码\n    yield return req;\n    string resName = $\"{path}_{typeof(T).Name}\";\n    //资源加载结束，将资源传到外部的委托函数去进行调用\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cT\u003e resInfo = resDic[resName] as ResInfo\u003cT\u003e;     //取出资源消息\n        resInfo.asset = req.asset as T;                         //将资源记录到资源信息内\n        //如果发现引用计数归0，说明需要移除该资源\n        if (resInfo.refCount == 0)\n        {\n            UnloadAsset\u003cT\u003e(path, resInfo.isDel, null, false);\n        }\n        else\n        {\n            resInfo.callBack?.Invoke(resInfo.asset);            //将加载出来的资源传递出去\n            //加载完毕后，这些引用就可以清空，避免引用的占用带来的内存泄露问题\n            resInfo.callBack = null;\n            resInfo.coroutine = null;\n        }\n    }\n}\n\nprivate IEnumerator ReallyLoadAsync(string path, Type type)\n{\n    //异步加载资源\n    ResourceRequest req = Resources.LoadAsync(path, type);\n    //等待资源加载结束后，才会继续执行yield return后面的代码\n    yield return req;\n    string resName = $\"{path}_{type.Name}\";\n    //资源加载结束，将资源传到外部的委托函数去进行调用\n    if (resDic.ContainsKey(resName))\n    {\n        ResInfo\u003cUnityEngine.Object\u003e resInfo = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;   //取出资源消息\n        resInfo.asset = req.asset;                              //将资源记录到资源信息内\n        //如果发现引用计数归0，说明需要移除该资源\n        if (resInfo.refCount == 0)\n        {\n            UnloadAsset(path, type, resInfo.isDel, null, false);\n        }\n        else\n        {\n            resInfo.callBack?.Invoke(resInfo.asset);            //将加载出来的资源传递出去\n            //加载完毕后，这些引用就可以清空，避免引用的占用带来的内存泄露问题\n            resInfo.callBack = null;\n            resInfo.coroutine = null;\n        }\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240417225101-i8jana5",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240417225101-i8jana5",
				"updated": "20240417225107"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用示例"
				}
			]
		},
		{
			"ID": "20240417225141-8b1ci3m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240417225141-8b1ci3m",
				"updated": "20240417225200"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "同时加载和卸载两次同一资源，观察引用计数的变化"
				}
			]
		},
		{
			"ID": "20240417225108-hfpl354",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240417225108-hfpl354",
				"style": "line-height: 22px;",
				"updated": "20240417225107"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "ResManager.Instance.LoadAsync\u003cGameObject\u003e(\"Test\", TestFun);\nDebug.Log(ResManager.Instance.GetRefCount\u003cGameObject\u003e(\"Test\"));\nResManager.Instance.LoadAsync\u003cGameObject\u003e(\"Test\", TestFun);\nDebug.Log(ResManager.Instance.GetRefCount\u003cGameObject\u003e(\"Test\"));\n\nResManager.Instance.UnloadAsset\u003cGameObject\u003e(\"Test\", false, TestFun);\nDebug.Log(ResManager.Instance.GetRefCount\u003cGameObject\u003e(\"Test\"));\n\nResManager.Instance.UnloadAsset\u003cGameObject\u003e(\"Test\", false, TestFun);\nDebug.Log(ResManager.Instance.GetRefCount\u003cGameObject\u003e(\"Test\"));\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240417225202-o0tms44",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240417225202-o0tms44",
				"updated": "20240417225219"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "输出："
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240417225218-e15xrad.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240417205620-1puaz5a",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240417205620-1puaz5a",
				"updated": "20240417205628"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意事项"
				}
			]
		},
		{
			"ID": "20240417205632-k17o1bh",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240417205632-k17o1bh",
				"updated": "20240417224158"
			},
			"Children": [
				{
					"ID": "20240417205635-owsddpo",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240417205635-owsddpo",
						"updated": "20240417205635"
					},
					"Children": [
						{
							"ID": "20240417205635-hbp7gbx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205635-hbp7gbx",
								"updated": "20240417223724"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "加入引用计数的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "ResManager"
								},
								{
									"Type": "NodeText",
									"Data": "​，我们在使用资源时就需要"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "有用就有删"
								},
								{
									"Type": "NodeText",
									"Data": "\n"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "当使用某个资源的对象移除时，一定要记得调用移除方法"
								}
							]
						}
					]
				},
				{
					"ID": "20240417205635-tlhts1u",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240417205635-tlhts1u",
						"updated": "20240417224158"
					},
					"Children": [
						{
							"ID": "20240417205635-qj0alzm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240417205635-qj0alzm",
								"updated": "20240417223759"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果觉得"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "卸载资源的功能麻烦，也完全可以不使用卸载的相关方法"
								},
								{
									"Type": "NodeText",
									"Data": "\n加载相关逻辑不会有任何影响，和以前直接使用"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Resources"
								},
								{
									"Type": "NodeText",
									"Data": "​的用法几乎一样\n只需要再"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "添加一个主动清空字典的方法即可"
								}
							]
						},
						{
							"ID": "20240417224147-toqbfyg",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240417224147-toqbfyg",
								"style": "line-height: 22px;",
								"updated": "20240417224158"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "// 清空资源记录，同时释放掉未使用的资源\npublic void ClearDic(UnityAction callBack)\n{\n    resDic.Clear();\n    MonoManager.Instance.StartCoroutine(ReallyClearDic(callBack));\n}\n\nprivate IEnumerator ReallyClearDic (UnityAction callBack)\n{\n    resDic.Clear();\n    AsyncOperation ao = Resources.UnloadUnusedAssets();\n    yield return ao;\n    callBack?.Invoke();\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240417205654-gv80g3z",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240417205654-gv80g3z",
				"updated": "20240417225235"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "具体代码"
				}
			]
		},
		{
			"ID": "20240417225235-ysmajvj",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240417225235-ysmajvj",
				"style": "line-height: 22px;",
				"updated": "20240417225244"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\n/// \u003csummary\u003e\n/// 资源消息基类\n/// \u003c/summary\u003e\npublic abstract class ResInfoBase \n{\n    public int refCount;                //引用计数\n}\n\n/// \u003csummary\u003e\n/// 资源消息对象 主要用于存储资源消息，异步加载委托消息，异步加载协程消息\n/// \u003c/summary\u003e\n/// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e\npublic class ResInfo\u003cT\u003e : ResInfoBase\n{\n    public T asset;                     //资源\n    public UnityAction\u003cT\u003e callBack;     //用于异步资源加载完后 传递资源到外部的委托\n    public Coroutine coroutine;         //用于异步加载时 开启的协同程序\n    public bool isDel;                  //当引用计数归0时，是否需要立刻移除\n\n\n    public void AddRefCount()\n    {\n        ++refCount;\n    }\n\n    public void SubRefCount()\n    {\n        --refCount;\n        if (refCount \u003c 0)\n            Debug.LogError(\"引用计数小于0了，请检查使用或者卸载是否配对执行\");\n    }\n}\n\n/// \u003csummary\u003e\n/// Resources 资源加载模块管理器\n/// \u003c/summary\u003e\npublic class ResManager : BaseManager\u003cResManager\u003e\n{\n    //主要用于存储加载过的资源或者加载中的资源的容器\n    private Dictionary\u003cstring, ResInfoBase\u003e resDic = new Dictionary\u003cstring, ResInfoBase\u003e();\n\n    private ResManager() { }\n\n    /// \u003csummary\u003e\n    /// 同步加载资源的方法\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e资源类型\u003c/typeparam\u003e\n    /// \u003cparam name=\"path\"\u003e\u003c/param\u003e\n    /// \u003creturns\u003e\u003c/returns\u003e\n    public T Load\u003cT\u003e(string path) where T : UnityEngine.Object\n    {\n        //资源的唯一ID，通过路径名_资源类型拼接而成\n        string resName = $\"{path}_{typeof(T).Name}\";\n        ResInfo\u003cT\u003e info;\n        //字典中不存在资源时\n        if (!resDic.ContainsKey(resName))\n        {\n            //直接同步加载，并且记录资源消息到字典中，方便下次直接取出来用\n            T res = Resources.Load\u003cT\u003e(path);\n            info = new ResInfo\u003cT\u003e();\n            info.asset = res;\n            info.AddRefCount();         //增加引用计数\n            resDic.Add(resName, info);\n            return res;\n        }\n        else\n        {\n            //取出字典的记录\n            info = resDic[resName] as ResInfo\u003cT\u003e;\n            info.AddRefCount();         //增加引用计数\n            //存在异步加载且还在加载中\n            if (info.asset == null)\n            {\n                //停止异步加载，直接采用同步加载的方式加载，并记录\n                MonoManager.Instance.StopCoroutine(info.coroutine);\n                T res = Resources.Load\u003cT\u003e(path);\n                info.asset = res;\n                //将同步加载出来的内容传递到已存在的回调函数内执行\n                info.callBack?.Invoke(res);\n                //执行结束回调，将记录的回调和协程清空，避免内存泄露\n                info.callBack = null;\n                info.coroutine = null;\n                return res;\n            }\n            //已经加载过资源\n            else\n            {\n                return info.asset;\n            }\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 异步加载资源的方法\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e资源类型\u003c/typeparam\u003e\n    /// \u003cparam name=\"path\"\u003e资源路径（Resources下的）\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e加载结束后的回调函数\u003c/param\u003e\n    public void LoadAsync\u003cT\u003e(string path, UnityAction\u003cT\u003e callBack) where T : UnityEngine.Object\n    {\n        //资源的唯一ID，通过路径名_资源类型拼接而成\n        string resName = $\"{path}_{typeof(T).Name}\";\n        ResInfo\u003cT\u003e info;\n        //不存在消息记录时，说明资源未加载过\n        if (!resDic.ContainsKey(resName))\n        {\n            info = new ResInfo\u003cT\u003e();        //声明一个 资源信息对象\n            info.AddRefCount();             //增加引用计数\n            resDic.Add(resName, info);      //将资源记录添加到资源内（资源没有加载成功）\n            info.callBack += callBack;      //记录传入的委托函数，一会加载完成了再使用\n            //通过协同程序去异步加载资源，并记录该协同程序\n            info.coroutine = MonoManager.Instance.StartCoroutine(ReallyLoadAsync\u003cT\u003e(path));\n        }\n        //存在消息记录时，资源已经加载过\n        else\n        {\n            info = resDic[resName] as ResInfo\u003cT\u003e;   //从字典中取出资源信息\n            info.AddRefCount();                     //增加引用计数\n            //资源尚未加载成功\n            if (info.asset == null)\n                info.callBack += callBack;          //将回调函数添加到委托内，等待加载完毕后一起执行\n            //资源已经加载完毕\n            else\n                callBack?.Invoke(info.asset);       //直接执行传入的回调函数\n        }\n    }\n\n    private IEnumerator ReallyLoadAsync\u003cT\u003e(string path) where T : UnityEngine.Object\n    {\n        //异步加载资源\n        ResourceRequest req = Resources.LoadAsync\u003cT\u003e(path);\n        //等待资源加载结束后，才会继续执行yield return后面的代码\n        yield return req;\n        string resName = $\"{path}_{typeof(T).Name}\";\n        //资源加载结束，将资源传到外部的委托函数去进行调用\n        if (resDic.ContainsKey(resName))\n        {\n            ResInfo\u003cT\u003e resInfo = resDic[resName] as ResInfo\u003cT\u003e;     //取出资源消息\n            resInfo.asset = req.asset as T;                         //将资源记录到资源信息内\n            //如果发现引用计数归0，说明需要移除该资源\n            if (resInfo.refCount == 0)\n            {\n                UnloadAsset\u003cT\u003e(path, resInfo.isDel, null, false);\n            }\n            else\n            {\n                resInfo.callBack?.Invoke(resInfo.asset);            //将加载出来的资源传递出去\n                //加载完毕后，这些引用就可以清空，避免引用的占用带来的内存泄露问题\n                resInfo.callBack = null;\n                resInfo.coroutine = null;\n            }\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 异步加载资源的方法\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"path\"\u003e资源路径（Resources下的）\u003c/param\u003e\n    /// \u003cparam name=\"type\"\u003e资源类型\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e加载结束后的回调函数\u003c/param\u003e\n    [Obsolete(\"注意：建议使用泛型方法，如果需要使用Type加载，请不要和泛型加载混用去加载同类型同名资源\")]\n    public void LoadAsync(string path, Type type, UnityAction\u003cUnityEngine.Object\u003e callBack)\n    {\n        //资源的唯一ID，通过路径名_资源类型拼接而成\n        string resName = $\"{path}_{type.Name}\";\n        ResInfo\u003cUnityEngine.Object\u003e info;\n        //不存在消息记录时，说明资源未加载过\n        if (!resDic.ContainsKey(resName))\n        {\n            info = new ResInfo\u003cUnityEngine.Object\u003e();   //声明一个 资源信息对象\n            info.AddRefCount();             //增加引用计数\n            resDic.Add(resName, info);      //将资源记录添加到资源内（资源没有加载成功）\n            info.callBack += callBack;      //记录传入的委托函数，一会加载完成了再使用\n            //通过协同程序去异步加载资源，并记录该协同程序\n            info.coroutine = MonoManager.Instance.StartCoroutine(ReallyLoadAsync(path, type));\n        }\n        //存在消息记录时，资源已经加载过\n        else\n        {\n            info = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;   //从字典中取出资源信息\n            info.AddRefCount();                     //增加引用计数\n            //资源尚未加载成功\n            if (info.asset == null)\n                info.callBack += callBack;          //将回调函数添加到委托内，等待加载完毕后一起执行\n            //资源已经加载完毕\n            else\n                callBack?.Invoke(info.asset);       //直接执行传入的回调函数\n        }\n    }\n\n    private IEnumerator ReallyLoadAsync(string path, Type type)\n    {\n        //异步加载资源\n        ResourceRequest req = Resources.LoadAsync(path, type);\n        //等待资源加载结束后，才会继续执行yield return后面的代码\n        yield return req;\n        string resName = $\"{path}_{type.Name}\";\n        //资源加载结束，将资源传到外部的委托函数去进行调用\n        if (resDic.ContainsKey(resName))\n        {\n            ResInfo\u003cUnityEngine.Object\u003e resInfo = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;   //取出资源消息\n            resInfo.asset = req.asset;                              //将资源记录到资源信息内\n            //如果发现引用计数归0，说明需要移除该资源\n            if (resInfo.refCount == 0)\n            {\n                UnloadAsset(path, type, resInfo.isDel, null, false);\n            }\n            else\n            {\n                resInfo.callBack?.Invoke(resInfo.asset);            //将加载出来的资源传递出去\n                //加载完毕后，这些引用就可以清空，避免引用的占用带来的内存泄露问题\n                resInfo.callBack = null;\n                resInfo.coroutine = null;\n            }\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 指定卸载一个资源\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e要卸载的资源类型\u003c/typeparam\u003e\n    /// \u003cparam name=\"path\"\u003e要卸载的资源的路径\u003c/param\u003e\n    /// \u003cparam name=\"isDel\"\u003e引用计数为0时，是否立刻移除\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e要移除的回调函数（可选，适用于尚未加载完毕时移除回调）\u003c/param\u003e\n    /// \u003cparam name=\"isSub\"\u003e引用计数是否减一\u003c/param\u003e\n    public void UnloadAsset\u003cT\u003e(string path, bool isDel = false, UnityAction\u003cT\u003e callBack = null, bool isSub = true)\n    {\n        string resName = $\"{path}_{typeof(T).Name}\";\n        //是否存在对应资源\n        if (resDic.ContainsKey(resName))\n        {\n            ResInfo\u003cT\u003e resInfo = resDic[resName] as ResInfo\u003cT\u003e;\n            if (isSub)\n                resInfo.SubRefCount();  //减少引用计数\n            resInfo.isDel = isDel;      //记录引用计数为0时，是否立刻移除\n            //资源已经加载结束，且引用计数归0\n            if (resInfo.asset != null \u0026\u0026 resInfo.refCount == 0 \u0026\u0026 resInfo.isDel == true)\n            {\n                //从字典移除，通过api卸载资源\n                resDic.Remove(resName);\n                Resources.UnloadAsset(resInfo.asset as UnityEngine.Object);\n            }\n            //资源正在异步加载中\n            else if (resInfo.asset == null)\n            {\n                if (callBack != null)\n                    resInfo.callBack -= callBack;\n            }\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 指定卸载一个资源\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"path\"\u003e要卸载的资源的路径\u003c/param\u003e\n    /// \u003cparam name=\"type\"\u003e要卸载的资源类型\u003c/param\u003e\n    /// \u003cparam name=\"isDel\"\u003e引用计数为0时，是否立刻移除\u003c/param\u003e\n    /// \u003cparam name=\"callBack\"\u003e要移除的回调函数（可选，适用于尚未加载完毕时移除回调）\u003c/param\u003e\n    /// \u003cparam name=\"isSub\"\u003e引用计数是否减一\u003c/param\u003e\n    public void UnloadAsset(string path, Type type, bool isDel = false, UnityAction\u003cUnityEngine.Object\u003e callBack = null, bool isSub = true)\n    {\n        string resName = $\"{path}_{type.Name}\";\n        //是否存在对应资源\n        if (resDic.ContainsKey(resName))\n        {\n            ResInfo\u003cUnityEngine.Object\u003e resInfo = resDic[resName] as ResInfo\u003cUnityEngine.Object\u003e;\n            if (isSub)\n                resInfo.SubRefCount();  //减少引用计数\n            resInfo.isDel = isDel;      //记录引用计数为0时，是否立刻移除\n            //资源已经加载结束\n            if (resInfo.asset != null \u0026\u0026 resInfo.refCount == 0 \u0026\u0026 resInfo.isDel == true)\n            {\n                //从字典移除，通过api卸载资源\n                resDic.Remove(resName);\n                Resources.UnloadAsset(resInfo.asset as UnityEngine.Object);\n            }\n            //资源正在异步加载中\n            else if (resInfo.asset == null)\n            {\n                //当异步加载不想使用时，我们应该移除它的回调记录，而不是直接去卸载资源\n                if (callBack != null)\n                    resInfo.callBack -= callBack;\n            }\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 异步卸载对应没有使用的Resources相关资源\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"callBack\"\u003e回调函数\u003c/param\u003e\n    public void UnloadUnusedAssets(UnityAction callBack)\n    {\n        MonoManager.Instance.StartCoroutine(ReallyUnloadUnusedAssets(callBack));\n    }\n\n    private IEnumerator ReallyUnloadUnusedAssets(UnityAction callBack)\n    {\n        //在真正移除不使用的资源之前，应该将字典内引用计数归0的资源消息且尚未移除记录的移除掉\n        List\u003cstring\u003e list = new List\u003cstring\u003e();\n        foreach (string path in resDic.Keys)\n        {\n            if (resDic[path].refCount == 0)\n                list.Add(path);\n        }\n        foreach (string path in list)\n        {\n            resDic.Remove(path);\n        }\n\n        AsyncOperation ao = Resources.UnloadUnusedAssets();\n        yield return ao;\n        callBack?.Invoke();\n    }\n\n    /// \u003csummary\u003e\n    /// 获取当前某个资源的引用计数\n    /// \u003c/summary\u003e\n    /// \u003ctypeparam name=\"T\"\u003e资源的类型\u003c/typeparam\u003e\n    /// \u003cparam name=\"path\"\u003e资源的路径\u003c/param\u003e\n    /// \u003creturns\u003e引用计数（若传入无效资源则返回0）\u003c/returns\u003e\n    public int GetRefCount\u003cT\u003e(string path)\n    {\n        string resName = $\"{path}_{typeof(T).Name}\";\n        if (resDic.ContainsKey(resName))\n        {\n            return resDic[resName].refCount;\n        }\n        return 0;\n    }\n\n    /// \u003csummary\u003e\n    /// 清空资源记录，同时释放掉未使用的资源\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"callBack\"\u003e资源释放完毕后要执行的方法\u003c/param\u003e\n    public void ClearDic(UnityAction callBack)\n    {\n        resDic.Clear();\n        MonoManager.Instance.StartCoroutine(ReallyClearDic(callBack));\n    }\n\n    private IEnumerator ReallyClearDic (UnityAction callBack)\n    {\n        resDic.Clear();\n        AsyncOperation ao = Resources.UnloadUnusedAssets();\n        yield return ao;\n        callBack?.Invoke();\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}