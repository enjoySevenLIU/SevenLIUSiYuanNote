{
	"ID": "20240308190703-v6cen7d",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20240308190703-v6cen7d",
		"title": "UN2L5——分包、黏包",
		"type": "doc",
		"updated": "20240703140013"
	},
	"Children": [
		{
			"ID": "20240308190752-8z0v6w3",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20240308190752-8z0v6w3",
				"updated": "20240703140013"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分包、黏包"
				}
			]
		},
		{
			"ID": "20240308190846-91umc60",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240308190846-91umc60",
				"updated": "20240308190846"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分包、黏包指在网络通信中由于各种因素（网络环境、API规则等）造成的消息与消息之间出现的两种状态"
				}
			]
		},
		{
			"ID": "20240308191632-4klk43j",
			"Type": "NodeSuperBlock",
			"Properties": {
				"id": "20240308191632-4klk43j",
				"updated": "20240703140000"
			},
			"Children": [
				{
					"Type": "NodeSuperBlockOpenMarker"
				},
				{
					"Type": "NodeSuperBlockLayoutMarker",
					"Data": "col"
				},
				{
					"ID": "20240308190848-lo6zq1u",
					"Type": "NodeList",
					"ListData": {},
					"Properties": {
						"id": "20240308190848-lo6zq1u",
						"updated": "20240308191632"
					},
					"Children": [
						{
							"ID": "20240308190851-p45222y",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20240308190851-p45222y",
								"updated": "20240308190851"
							},
							"Children": [
								{
									"ID": "20240308190851-6ydjuuh",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20240308190851-6ydjuuh",
										"updated": "20240308190851"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "分包：一个消息分成了多个消息进行发送\n"
										}
									]
								}
							]
						},
						{
							"ID": "20240308190852-p72rvfu",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20240308190852-p72rvfu"
							},
							"Children": [
								{
									"ID": "20240308190852-hflmtfg",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20240308190852-hflmtfg"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "黏包：一个消息和另一个消息黏在了一起"
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20240308191548-dil9joz",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240308191548-dil9joz",
						"updated": "20240703140000"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "​"
						},
						{
							"Type": "NodeImage",
							"Data": "span",
							"Properties": {
								"parent-style": "width: 505px;",
								"style": "width: 495px;"
							},
							"Children": [
								{
									"Type": "NodeBang"
								},
								{
									"Type": "NodeOpenBracket"
								},
								{
									"Type": "NodeLinkText",
									"Data": "image"
								},
								{
									"Type": "NodeCloseBracket"
								},
								{
									"Type": "NodeOpenParen"
								},
								{
									"Type": "NodeLinkDest",
									"Data": "assets/分包黏包示意图-20240308191548-vo8gs8z.png"
								},
								{
									"Type": "NodeCloseParen"
								}
							]
						},
						{
							"Type": "NodeKramdownSpanIAL",
							"Data": "{: style=\"width: 495px;\" parent-style=\"width: 505px;\"}"
						},
						{
							"Type": "NodeText",
							"Data": "​"
						}
					]
				},
				{
					"Type": "NodeSuperBlockCloseMarker"
				}
			]
		},
		{
			"ID": "20240308190846-i45tjr9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240308190846-i45tjr9",
				"style": "background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);",
				"updated": "20240308190846"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意：分包和黏包可能同时发生"
				}
			]
		},
		{
			"ID": "20240308190703-km37k16",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240308190703-km37k16",
				"updated": "20240703140013"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如何解决分包、黏包的问题"
				}
			]
		},
		{
			"ID": "20240308191620-kf9fqyi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240308191620-kf9fqyi",
				"updated": "20240308191646"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​​"
				}
			]
		},
		{
			"ID": "20240308191303-papencw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240308191303-papencw",
				"updated": "20240308190919"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "处理分包、黏包问题首先要了解什么是分包和黏包，解决该问题的逻辑实现的写法可能有很多种，我们采用最节约性能的方式解决问题就行"
				}
			]
		},
		{
			"ID": "20240308190930-nb1i9f2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240308190930-nb1i9f2",
				"updated": "20240308190919"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在的处理：\n我们收到的消息都是以字节数组的形式在程序中体现，目前我们的处理规则是默认传过来的消息就是正常情况\n前4个字节是消息ID，后面的字节数组全部用来反序列化"
				}
			]
		},
		{
			"ID": "20240308191004-zxs5h23",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240308191004-zxs5h23",
				"updated": "20240308190919"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果出现分包、黏包会导致我们反序列化报错，因为数据可能不完整"
				}
			]
		},
		{
			"ID": "20240308190930-6nv6jbi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240308190930-6nv6jbi",
				"updated": "20240308190919"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "思考：那么通过接收到的字节数组我们应该如何判断收到的字节数组处于以下状态"
				}
			]
		},
		{
			"ID": "20240308190933-3meahq0",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240308190933-3meahq0",
				"updated": "20240308190919"
			},
			"Children": [
				{
					"ID": "20240308190933-yqxrwi4",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240308190933-yqxrwi4",
						"updated": "20240308190933"
					},
					"Children": [
						{
							"ID": "20240308190933-94v2ckf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240308190933-94v2ckf",
								"updated": "20240308190933"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "正常"
								}
							]
						}
					]
				},
				{
					"ID": "20240308190933-7q3mhx4",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240308190933-7q3mhx4",
						"updated": "20240308190933"
					},
					"Children": [
						{
							"ID": "20240308190933-fd28idc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240308190933-fd28idc",
								"updated": "20240308190933"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "分包"
								}
							]
						}
					]
				},
				{
					"ID": "20240308190933-ao2h8cg",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20240308190933-ao2h8cg",
						"updated": "20240308190933"
					},
					"Children": [
						{
							"ID": "20240308190933-oczmhd1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240308190933-oczmhd1",
								"updated": "20240308190933"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "黏包"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240308190930-7r8ymv9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240308190930-7r8ymv9",
				"updated": "20240308190919"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "突破点：如何判断一个消息没有出现分包或者黏包呢？"
				}
			]
		},
		{
			"ID": "20240308191028-2du72wz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240308191028-2du72wz",
				"updated": "20240308192433"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "答案：就是消息长度\n我们可以如同处理 区分消息类型 的逻辑一样，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "为消息添加头部，头部记录消息的长度"
				},
				{
					"Type": "NodeText",
					"Data": "\n当我们接收到消息时，通过消息长度来判断是否分包、黏包\n对消息进行拆分处理、合并处理，我们每次只处理完整的消息"
				}
			]
		},
		{
			"ID": "20240308191648-4fnouj1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240308191648-4fnouj1",
				"updated": "20240703140013"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 758px;",
						"style": "width: 748px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/分包黏包解决方案图-20240308191620-r92vn8w.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 748px;\" parent-style=\"width: 758px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240308191041-5rg8zlh",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240308191041-5rg8zlh",
				"updated": "20240308205113"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "实践"
				}
			]
		},
		{
			"ID": "20240308191045-bbdd6cn",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240308191045-bbdd6cn",
				"updated": "20240408140554"
			},
			"Children": [
				{
					"ID": "20240308191247-rrnf4r2",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240308191247-rrnf4r2",
						"updated": "20240308191247"
					},
					"Children": [
						{
							"ID": "20240308191247-yqfgosf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240308191247-yqfgosf",
								"updated": "20240308191247"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "为所有消息添加头部信息，用于存储其消息长度"
								}
							]
						},
						{
							"ID": "20240309200103-g0gi4kp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240309200103-g0gi4kp",
								"updated": "20240309205115"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "重新声明一个"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "BaseMessage"
								},
								{
									"Type": "NodeText",
									"Data": "​，继承"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "BaseData"
								},
								{
									"Type": "NodeText",
									"Data": "​，让用于消息传递的类继承该基类，\n规定继承"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "BaseMessage"
								},
								{
									"Type": "NodeText",
									"Data": "​的类必须要有一个自己的唯一ID消息并可以被外部获取\n同时，继承"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "BaseMessage"
								},
								{
									"Type": "NodeText",
									"Data": "​的类的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Writeing"
								},
								{
									"Type": "NodeText",
									"Data": "​除了消息体以外，还需要序列化自己的ID和消息体的长度值，\n​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "GetBytesNum"
								},
								{
									"Type": "NodeText",
									"Data": "​获取的消息长度还需要加上ID长度（"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "int"
								},
								{
									"Type": "NodeText",
									"Data": "​）和消息体长度值的长度（"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "int"
								},
								{
									"Type": "NodeText",
									"Data": "​），也就是多加一个8\n这样，所有的用于通信的数据就包括头数据和消息体，头数据固定8字节，存储ID和消息体长度"
								}
							]
						},
						{
							"ID": "20240309200429-u99cbzg",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240309200429-u99cbzg",
								"style": "line-height: 22px;",
								"updated": "20240309200443"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public class BaseMessage : BaseData\n{\n    public override int GetBytesNum()\n    {\n        throw new System.NotImplementedException();\n    }\n\n    public override int Reading(byte[] bytes, int BeginIndex = 0)\n    {\n        throw new System.NotImplementedException();\n    }\n\n    public override byte[] Writeing()\n    {\n        throw new System.NotImplementedException();\n    }\n\n    public virtual int GetID()\n    {\n        return 0;\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240309201504-qaep86b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240309201504-qaep86b",
								"updated": "20240309201519"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "继承"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "BaseMessage"
								},
								{
									"Type": "NodeText",
									"Data": "​的类示例"
								}
							]
						},
						{
							"ID": "20240309201421-vm46agk",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240309201421-vm46agk",
								"style": "line-height: 22px;",
								"updated": "20240309201544"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "using System.Text;\n\npublic class PlayerMessage : BaseMessage\n{\n    public int playerID;\n    public PlayerData playerData;\n\n    public override byte[] Writeing()\n    {\n        int index = 0;\n        int bytesNum = GetBytesNum();\n        byte[] bytes = new byte[bytesNum];\n        WriteInt(bytes, GetID(), ref index);        //先写消息ID\n        WriteInt(bytes, bytesNum - 8, ref index);\n        WriteInt(bytes, playerID, ref index);       //再写消息的成员变量\n        WriteData(bytes, playerData, ref index);\n        return bytes;\n    }\n\n    public override int Reading(byte[] bytes, int beginIndex = 0)\n    {\n        //反序列化不需要去解析ID 因为在这一步之前 就应该把ID反序列化出来\n        //用来判断到底使用哪一个自定义类来反序化\n        int index = beginIndex;\n        playerID = ReadInt(bytes, ref index);\n        playerData = ReadData\u003cPlayerData\u003e(bytes, ref index);\n        return index - beginIndex;\n    }\n\n    public override int GetBytesNum()\n    {\n        return 4 +                          //消息ID的长度\n               4 +                          //消息体长度数值的长度\n               4 +                          //playerID的字节数组长度\n               playerData.GetBytesNum();    //playerData\n    }\n\n    //自定义的消息ID 主要是用于区分是哪一个消息类\n    public override int GetID()\n    {\n        return 1001;\n    }\n}\n\n//玩家数据类\npublic class PlayerData : BaseData\n{\n    public string name;\n    public int atk;\n    public int lev;\n\n    public override int GetBytesNum()\n    {\n        return 4 + 4 + 4 + Encoding.UTF8.GetBytes(name).Length;\n    }\n\n    public override int Reading(byte[] bytes, int beginIndex = 0)\n    {\n        int index = beginIndex;\n        name = ReadString(bytes, ref index);\n        atk = ReadInt(bytes, ref index);\n        lev = ReadInt(bytes, ref index);\n        return index - beginIndex;\n    }\n\n    public override byte[] Writeing()\n    {\n        int index = 0;\n        byte[] bytes = new byte[GetBytesNum()];\n        WriteString(bytes, name, ref index);\n        WriteInt(bytes, atk, ref index);\n        WriteInt(bytes, lev, ref index);\n        return bytes;\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				},
				{
					"ID": "20240308191247-pbvd0tf",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240308191247-pbvd0tf",
						"updated": "20240408140554"
					},
					"Children": [
						{
							"ID": "20240308191247-1xxoz67",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240308191247-1xxoz67",
								"updated": "20240308191247"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "根据分包、黏包的表现情况，修改接收消息处的逻辑"
								}
							]
						},
						{
							"ID": "20240309201623-cr0zy9a",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240309201623-cr0zy9a",
								"style": "line-height: 22px;",
								"updated": "20240309202257"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "//服务器端 ClientSocket类内部\n//是否连接\npublic bool Connented =\u003e socket.Connected;\n\npublic void Receive()\n{\n\t//如果没有连接就返回\n    if (!Connented)\n\t\treturn;\n    try\n    {\n\t\t//当需要接收消息时\n        if (socket.Available \u003e 0)\n        {\n            byte[] result = new byte[1024 * 5];\n            int receiveNum = socket.Receive(result);\n\t\t\t//处理接收到的消息，需要传入接收到的数据长度\n            HandleReceiveMsg(result, receiveNum);\n        }\n    }\n    catch (Exception e)\n    {\n        Console.WriteLine($\"从客户端{clientID}接收消息失败：{e.Message}\");\n        //如果解析错误，也认为要把这个socket断开\n        Program.socket.AddDelSocket(this);\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240309201757-7lswjqp",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240309201757-7lswjqp",
								"style": "line-height: 22px;",
								"updated": "20240309211926"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "//客户端 NetManager类内部\n\nprivate void ReceiveMessage(object obj)\n{\n    while (isConnented)\n    {\n        if (socket.Available \u003e 0)\n        {\n            byte[] receiveBytes = new byte[1024 * 1024];\n            int receiveNum = socket.Receive(receiveBytes);\n\t\t\t//处理接收到的消息，需要传入接收到的数据长度，具体实现在下面写\n            HandleReceiveMsg(receiveBytes, receiveNum);\n        }\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240309200318-425m7ip",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240309200318-425m7ip",
								"updated": "20240309205939"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "处理分包、黏包的逻辑较为复杂，分析如下："
								}
							]
						},
						{
							"ID": "20240309202324-cshsdzn",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20240309202324-cshsdzn",
								"updated": "20240408140554"
							},
							"Children": [
								{
									"ID": "20240309202324-pyk0yom",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240309202324-pyk0yom",
										"updated": "20240309202324"
									},
									"Children": [
										{
											"ID": "20240309202324-b0xz2lr",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240309202324-b0xz2lr",
												"updated": "20240309205016"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "首先，需要将接收到的字节数组内的数据全部转存到另一个缓存数组内，再通过读取该缓存数组内的数据处理数据包"
												}
											]
										}
									]
								},
								{
									"ID": "20240309202601-mag58hc",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240309202601-mag58hc"
									},
									"Children": [
										{
											"ID": "20240309202601-xz58aqt",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240309202601-xz58aqt",
												"updated": "20240309204917"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "strong",
													"TextMarkTextContent": "假设发来的数据是两个甚至是多个完整的包黏在一起了"
												}
											]
										},
										{
											"ID": "20240309202715-j3ra4eo",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240309202715-j3ra4eo",
												"updated": "20240309203941"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "先反序列化缓存数组的前8个字节数据，确认ID和消息体长度，通过ID确定反序列化逻辑，通过消息体长度来确定反序列化多少字节数据，\n序列化一次后，发现缓存数组内还有数据未反序列化，就"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "strong",
													"TextMarkTextContent": "循环"
												},
												{
													"Type": "NodeText",
													"Data": "执行前面的步骤，最终所有数据被反序列化，清空缓存数组，并跳出循环"
												}
											]
										}
									]
								},
								{
									"ID": "20240309203046-awbyvyo",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240309203046-awbyvyo"
									},
									"Children": [
										{
											"ID": "20240309203046-euo3z8a",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240309203046-euo3z8a",
												"updated": "20240309204905"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "strong",
													"TextMarkTextContent": "假设发来的数据将一个完整的包分为两个甚至更多个"
												}
											]
										},
										{
											"ID": "20240309203127-doytu9k",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240309203127-doytu9k",
												"updated": "20240309205346"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "若发现缓存数组内数据不足8字节，则无法反序列化出ID和消息体长度，直接跳出处理逻辑循环，\n"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "strong",
													"TextMarkTextContent": "缓存数组内数据保留，下一次收到消息时，会将数据放在缓存数组中原有数据的后面"
												}
											]
										},
										{
											"ID": "20240309203850-5uysed4",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240309203850-5uysed4",
												"updated": "20240309205349"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "缓存数组内数据大于8字节后，反序列化缓存数组的前8个字节数据，确认ID和消息体长度，\n若发现剩余数据长度小于消息体长度，就跳出处理逻辑循环，\n"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "strong",
													"TextMarkTextContent": "缓存数组内数据保留，下一次收到消息时，会将数据放在缓存数组中原有数据的后面"
												}
											]
										},
										{
											"ID": "20240309204101-l6c8xjs",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240309204101-l6c8xjs",
												"updated": "20240309205312"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "直到缓存数组内的数据大于或等于之前反序列化出来的消息体长度后，就将这部分数据反序列化出来\n如果缓存数组内未反序列化的数据没有了，就清空缓存数组，并跳出循环"
												}
											]
										}
									]
								},
								{
									"ID": "20240309204427-v8zzfp5",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240309204427-v8zzfp5",
										"updated": "20240408140554"
									},
									"Children": [
										{
											"ID": "20240309204427-gybeuzz",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240309204427-gybeuzz",
												"updated": "20240309204911"
											},
											"Children": [
												{
													"Type": "NodeTextMark",
													"TextMarkType": "strong",
													"TextMarkTextContent": "假设同时遇到分包黏包，即发来的数据是完整的包黏着被分开的包的一部分，或者被分开的包的后面部分黏在另一个被分开的包的前面部分"
												}
											]
										},
										{
											"ID": "20240309204627-601f2t1",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240309204627-601f2t1",
												"updated": "20240309204933"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "先反序列化缓存数组前8个字节，若 不足8字节 或 不包括前8个字节的数据长度低于反序列化出来的消息体长度\n就等待下一次消息的接收，新接收到的数据放在缓存数组内原有数据的后面"
												}
											]
										},
										{
											"ID": "20240309204921-i1qmzxh",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240309204921-i1qmzxh",
												"updated": "20240408140554"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "当 不包括前8个字节的数据长度 大于或等于 反序列化出来的消息体长度，就反序列化出消息体\n如果缓存数组内未反序列化的数据没有了，就清空缓存数组，并跳出循环\n如果缓存数组内还有数据，"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "strong",
													"TextMarkTextContent": "先将剩余的数据转移到前面"
												},
												{
													"Type": "NodeText",
													"Data": "，然后按照上面的步骤重新执行"
												}
											]
										}
									]
								}
							]
						},
						{
							"ID": "20240309205841-rq7whom",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240309205841-rq7whom",
								"updated": "20240309210007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "根据分析，用伪代码阐述代码思路："
								}
							]
						},
						{
							"ID": "20240309210007-pcfc6mn",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240309210007-pcfc6mn",
								"style": "line-height: 22px;",
								"updated": "20240309212009"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "private byte[] 缓存数组 = new byte[1024 * 1024];\nprivate int 缓存数组内需要反序列化的数据长度 = 0;\n\n//每次接收到数据就调用\nvoid HandleReceiveMsg(接收到的数据, 接收到的数据的长度):\n\tvar 消息的ID、消息的长度、当前反序列化了几个字节 = 0;\n\t将接收到的数据复制到缓存数组内;\n\t缓存数组内需要反序列化的数据长度 += 接收到的数据的长度;\n\twhile (true)\t\t\t\t\t\t\t\t\t\t\t\t\t\t//当反序列化一次后，发现还能再序列化时就会继续循环\n\t\t消息的长度 = -1;\n\t\tif 缓存数组内需要反序列化的数据长度 - 当前反序列化了几个字节 \u003e= 8:\t\t//说明剩余未反序列化数据大于8字节，可以序列化头数据\n\t\t\t消息的ID、消息的长度 = 从缓存数组反序列化8个字节;\n\t\t\t当前反序列化了几个字节 += 8;\n\t\tif 缓存数组内剩余数据大于消息的长度 \u0026\u0026 消息的长度 != -1:\t\t\t\t//如果消息的长度等于-1说明连头数据都不能反序列化\n\t\t\t按照 消息的ID 和 消息的长度 从缓存数组内反序列化数据;\n\t\t\t当前反序列化了几个字节 += 消息的长度;\n\t\t\tif 当前反序列化了几个字节 == 缓存数组内需要反序列化的数据长度:\t\t//说明缓存数组内数据全部反序列化了\n\t\t\t\t缓存数组内需要反序列化的数据长度 = 0;\n\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t//跳出循环，结束消息处理\n\t\telse:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//说明无法继续反序列化\n\t\t\tif 消息的长度 == -1:\t\t\t\t\t\t\t\t\t\t\t//如果消息的长度不等于-1说明反序列化了头数据\n\t\t\t\t当前反序列化了几个字节 -= 8;\t\t\t\t\t\t\t\t//将反序列化的进度回退回去，头数据下一次继续反序列化\n\t\t\t根据 缓存数组内需要反序列化的数据长度 和 当前反序列化了几个字节 得到剩余未序列化数据长度\n\t\t\t将剩余未序列化数据移到缓存数组最前面\n\t\t\t缓存数组内需要反序列化的数据长度 -= 当前反序列化了几个字节\n\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\t//剩余数据等到下次接收到数据继续进行数据处理操作\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240309211907-rq4rwjn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240309211907-rq4rwjn",
								"updated": "20240309212022"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "具体代码实现为："
								}
							]
						},
						{
							"ID": "20240308191249-sz6l22p",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240308191249-sz6l22p",
								"style": "line-height: 22px;",
								"updated": "20240309212104"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "//服务器端 ClientSocket类内部或客户端 NetManager类内部，逻辑是一致的\n//用于处理分包时，缓存的字节数组和字节数组长度\nprivate byte[] cacheBytes = new byte[1024 * 1024];\nprivate int cacheNum = 0;\n\nprivate void HandleReceiveMsg(byte[] receiveBytes, int receiveNum)\n{\n    int msgID = 0;\n    int msgLength = 0;\n    int nowIndex = 0;\n\n    //收到消息后，将收到的消息直接拼接到缓存字节数组的后面\n    receiveBytes.CopyTo(cacheBytes, cacheNum);\n    cacheNum += receiveNum;\n    while (true)\n    {\n        //每次将长度设置为-1，是避免上一次解析的数据影响这一次的判断\n        msgLength = -1;\n        //处理解析一条消息，当该消息大于8时，才可能包含完整头信息\n        if (cacheNum - nowIndex \u003e= 8)\n        {\n            msgID = BitConverter.ToInt32(cacheBytes, nowIndex);       //解析ID\n            nowIndex += 4;\n            msgLength = BitConverter.ToInt32(cacheBytes, nowIndex);   //解析长度\n            nowIndex += 4;\n        }\n\n        //解析消息体\n        if (cacheNum - nowIndex \u003e= msgLength \u0026\u0026 msgLength != -1)\n        {\n            //消息体是完整的情况\n            BaseMessage? baseMsg = null;\n            switch (msgID)\n            {\n                case 1001:\n                    baseMsg = new PlayerMessage();\n                    baseMsg.Reading(cacheBytes, nowIndex);\n                    break;\n                case 1003:\n                    //由于该消息都没有消息体，因此我们无需反序列化它\n                    baseMsg = new QuitMessage();\n                    break;\n            }\n            if (baseMsg != null)\n                ThreadPool.QueueUserWorkItem(MsgHandle, baseMsg);\n            nowIndex += msgLength;\n            //解析完消息后正好缓存字节数组内的数据全部解析完毕了，说明数据解析完了，将缓存字节数组索引改为0\n            if (nowIndex == cacheNum)\n            {\n                cacheNum = 0;\n                break;\n            }\n        }\n        else\n        {\n            //消息体不完整的情况，证明有分包，因此需要把当前收到的内容记录下来\n            //需要等待下次接收到消息后再做处理\n            //如果进行了id和长度的解析，但是没有成功解析消息体，那么我们需要减去nowIndex移动的位置\n            if (msgLength != 1)\n                nowIndex -= 8;\n            //即将剩余没有解析的字节数组内容移到缓存数组前面，用于缓存下次继续解析\n            Array.Copy(cacheBytes, nowIndex, cacheBytes, 0, cacheNum - nowIndex);\n            cacheNum -= nowIndex;\n            break;\n        }\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				}
			]
		}
	]
}