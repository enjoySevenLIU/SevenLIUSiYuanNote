{
	"ID": "20230712231445-ihyij81",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230712231445-ihyij81",
		"name": "协同程序原理",
		"scroll": "\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230712231445-ihyij81\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20230712231445-wtd28tm\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230713001547-50wtavd\u0026quot;,\u0026quot;scrollTop\u0026quot;:1292,\u0026quot;focusId\u0026quot;:\u0026quot;20230712231445-wtd28tm\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;",
		"title": "U2L8——协同程序原理",
		"type": "doc",
		"updated": "20240321172346"
	},
	"Children": [
		{
			"ID": "20230712231445-wtd28tm",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230712231445-wtd28tm",
				"updated": "20230712231949"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "协同程序原理"
				}
			]
		},
		{
			"ID": "20230713001637-7kwuf57",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230713001637-7kwuf57",
				"updated": "20230713001653"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "协程本质 就是利用 C#的迭代器函数“分步执行”的特点 加上 协程调度逻辑 实现的一套分时执行函数的规则"
				}
			]
		},
		{
			"ID": "20230712231949-z1nx3zr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230712231949-z1nx3zr",
				"updated": "20230712232014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "关于协程的介绍和使用相关，在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20230712214614-4ja3qtk",
					"TextMarkBlockRefSubtype": "d",
					"TextMarkTextContent": "协同程序"
				},
				{
					"Type": "NodeText",
					"Data": "里"
				}
			]
		},
		{
			"ID": "20230712232015-700rpaf",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230712232015-700rpaf",
				"updated": "20230712233506"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "协程的本质"
				}
			]
		},
		{
			"ID": "20230712233514-h6m266s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230712233514-h6m266s",
				"updated": "20240310174442"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "协程可以分成两部分："
				}
			]
		},
		{
			"ID": "20240310174440-ryp7u53",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240310174440-ryp7u53",
				"updated": "20240310174522"
			},
			"Children": [
				{
					"ID": "20240310174440-71g8hfo",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240310174440-71g8hfo",
						"updated": "20240310174527"
					},
					"Children": [
						{
							"ID": "20240310174440-ys6gwoy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240310174440-ys6gwoy",
								"updated": "20240310174527"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "协程函数本体"
								},
								{
									"Type": "NodeText",
									"Data": "：就是一个可以中间暂停返回的函数"
								}
							]
						}
					]
				},
				{
					"ID": "20240310174440-l0w6k2q",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240310174440-l0w6k2q",
						"updated": "20240310174522"
					},
					"Children": [
						{
							"ID": "20240310174440-xnb3he4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240310174440-xnb3he4",
								"updated": "20240310174522"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "协程调度器"
								},
								{
									"Type": "NodeText",
									"Data": "：是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230712233514-qa710zl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230712233514-qa710zl",
				"updated": "20230713001418"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Unity只实现了协程调度部分，协程的本体本质上就是一个C#的迭代器方法"
				}
			]
		},
		{
			"ID": "20230713001246-51xh3eu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230713001246-51xh3eu",
				"updated": "20240321172331"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以简单把协程理解为迭代器函数\nC#看到迭代器函数和"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "yield return"
				},
				{
					"Type": "NodeText",
					"Data": "​语法糖，就会把原本是一个“函数”变成“几部分”\n我们就可以提供迭代器，从上到下遍历这几部分进行执行"
				}
			]
		},
		{
			"ID": "20230713001246-7l9eimp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230713001246-7l9eimp",
				"updated": "20240321172346"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而协程调度器就是利用迭代器函数返回的内容来进行之后的处理\n比如Unity中的协程调度器，根据"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "yield return"
				},
				{
					"Type": "NodeText",
					"Data": "​返回的内容，决定了下一次在何时继续执行迭代器函数中的“下一部分”"
				}
			]
		},
		{
			"ID": "20230713001246-vbnetrr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230713001246-vbnetrr",
				"updated": "20240310174537"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "理论上来说，我们可以利用迭代器函数的特点，自己实现协程调度器来取代Unity自带的调度器"
				}
			]
		},
		{
			"ID": "20230713000617-ps41v5n",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230713000617-ps41v5n",
				"updated": "20230713000624"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "协程本体是迭代器方法的体现"
				}
			]
		},
		{
			"ID": "20230713001148-ehwx0tt",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230713001148-ehwx0tt",
				"updated": "20240310174543"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "协程函数本体"
				}
			]
		},
		{
			"ID": "20230713000624-kiq9a8b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230713000624-kiq9a8b",
				"updated": "20240310174543"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果我们不通过 开启协程方法执行协程\nUnity的协程调度器是不会帮助我们管理协程函数的"
				}
			]
		},
		{
			"ID": "20230713000751-1ecr8ex",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230713000751-1ecr8ex",
				"updated": "20240310174543"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是我们可以自己执行迭代器函数内容"
				}
			]
		},
		{
			"ID": "20230713000640-pzer3ih",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230713000640-pzer3ih",
				"updated": "20240310174543"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class TestClass\n{\n    public int time;\n    public TestClass(int time)\n    {\n        this.time = time;\n    }\n}\n\nIEnumerator Test()\n{\n    print(\"第一次执行\");\n    yield return 1;\n    print(\"第二次执行\");\n    yield return 2;\n    print(\"第三次执行\");\n    yield return \"123\";\n    print(\"第四次执行\");\n    yield return new TestClass(10);\n}\n\nvoid Start()\n{\n    IEnumerator ie = Test();\n    ie.MoveNext();  //会执行函数中内容遇到yield return为止的逻辑\n    print(ie.Current);  //得到yield return返回的内容\n    ie.MoveNext();\n    print(ie.Current);\n    ie.MoveNext();\n    print(ie.Current);\n    ie.MoveNext();\n    TestClass tC = ie.Current as TestClass;\n    print(tC.time);\n}\n\n//MoveNext 返回值 代表着 是否到了结尾（这个迭代器函数 是否执行完毕）\nwhile (ie.MoveNext())\n{\n    print(ie.Current);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230713000636-hjo22qu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230713000636-hjo22qu",
				"updated": "20240310174543"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过我们自己分步执行迭代器函数，可以发现协程本质就是一个迭代器方法的体现，只不过Unity有自己的协程调度器来执行协程"
				}
			]
		},
		{
			"ID": "20230713001134-kwefipa",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230713001134-kwefipa",
				"updated": "20240310174546"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "协程调度器"
				}
			]
		},
		{
			"ID": "20230713001204-qx8qzhe",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230713001204-qx8qzhe",
				"updated": "20240321172339"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "继承"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "MonoBehaviour"
				},
				{
					"Type": "NodeText",
					"Data": "​后 开启协程，相当于是把一个协程函数（迭代器）放入一个Unity的协程调度器中帮助我们管理进行执行\n具体的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "yield return"
				},
				{
					"Type": "NodeText",
					"Data": "​后面的规则 也是Unity定义的一些规则"
				}
			]
		},
		{
			"ID": "20230713001442-naogumc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230713001442-naogumc",
				"updated": "20240310174546"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Coroutine c1 = StartCoroutine(Test());\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230713001547-50wtavd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230713001547-50wtavd",
				"updated": "20240310174546"
			}
		}
	]
}