{
	"ID": "20240910002726-zcsnyl1",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20240910002726-zcsnyl1",
		"title": "CS4L9——顺序存储和链式存储",
		"type": "doc",
		"updated": "20240910012325"
	},
	"Children": [
		{
			"ID": "20240910002726-opoc48g",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20240910002726-opoc48g",
				"updated": "20240910002908"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "数据结构"
				}
			]
		},
		{
			"ID": "20240910002807-qvp6r7a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910002807-qvp6r7a",
				"updated": "20240910002928"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "数据结构是计算机存储、组织数据的方式（规则）\n数据结构是指相互之间存在一种或多种特定关系的数据元素的集合\n比如自定义的一个 类 也可以成为一种数据结构 自己定义的数据组合规则、"
				}
			]
		},
		{
			"ID": "20240910002807-nix42kl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910002807-nix42kl",
				"updated": "20240910002932"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不需要把数据结构想的太复杂，简单来说，就是人定义的 存储数据 和 表示数据之间的 规则而已"
				}
			]
		},
		{
			"ID": "20240910002807-xxmpgsk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910002807-xxmpgsk",
				"updated": "20240910002936"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "常用的数据结构（前人总结和制定的一些经典规则）：数组、栈、队列、链表、树、图、堆、散列表"
				}
			]
		},
		{
			"ID": "20240910002920-024fijg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910002920-024fijg",
				"updated": "20240910002920"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "顺序存储和链式存储 是数据结构中两种 存储结构"
				}
			]
		},
		{
			"ID": "20240910002800-xzzj48p",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240910002800-xzzj48p",
				"updated": "20240910002908"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "线性表"
				}
			]
		},
		{
			"ID": "20240910002818-zqxx9sk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910002818-zqxx9sk",
				"updated": "20240910002908"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "线性表是一种数据结构，是由n个具有相同特性的数据元素的有限序列\n比如数组、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code block-ref",
					"TextMarkBlockRefID": "20240905132820-ckm65ix",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "ArrayList"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code block-ref",
					"TextMarkBlockRefID": "20240906154922-4dwiedd",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "Stack"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref code",
					"TextMarkBlockRefID": "20240906161252-6jtyajh",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "Queue"
				},
				{
					"Type": "NodeText",
					"Data": "​、链表等等"
				}
			]
		},
		{
			"ID": "20240910002904-ev2k8gv",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240910002904-ev2k8gv",
				"updated": "20240910005111"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "顺序存储"
				}
			]
		},
		{
			"ID": "20240910002954-gttalp8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910002954-gttalp8",
				"updated": "20240910005117"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "数组、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Stack"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Queue"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "List"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ArrayList"
				},
				{
					"Type": "NodeText",
					"Data": "​ —— 顺序存储\n只是 ​数组、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Stack"
				},
				{
					"Type": "NodeText",
					"Data": "​、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Queue"
				},
				{
					"Type": "NodeText",
					"Data": "​ 的 组织规则不同而已"
				}
			]
		},
		{
			"ID": "20240910003021-vgl4r2m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910003021-vgl4r2m",
				"updated": "20240910003021"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "顺序存储就是用一种地址连续的存储单元依次存储线性表的各个数据元素"
				}
			]
		},
		{
			"ID": "20240910005111-mbol4kr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910005111-mbol4kr",
				"updated": "20240910005111"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 555px;",
						"style": "width: 545px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240910005111-sk378xl.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 545px;\" parent-style=\"width: 555px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240910003026-cz30504",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240910003026-cz30504",
				"updated": "20240910005807"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "链式存储"
				}
			]
		},
		{
			"ID": "20240910003032-hm4i6f0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910003032-hm4i6f0",
				"updated": "20240910005232"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单向链表、双向链表、循环链表 —— 链式存储\n链式存储（链接存储）：用一组任意的存储单元（节点）存储线性表中的各个数据元素"
				}
			]
		},
		{
			"ID": "20240910005234-rtqhh1o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910005234-rtqhh1o",
				"updated": "20240910005400"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最基本的节点包括值和指向下一个节点的地址"
				}
			]
		},
		{
			"ID": "20240910005133-ahdxc2w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910005133-ahdxc2w",
				"updated": "20240910005807"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 550px;",
						"style": "width: 540px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240910005133-gx2jmhi.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 540px;\" parent-style=\"width: 550px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240910005336-yc2qwyb",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240910005336-yc2qwyb",
				"updated": "20240910011845"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "实现一个最简单的单向链表"
				}
			]
		},
		{
			"ID": "20240910005404-67wpc6q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910005404-67wpc6q",
				"updated": "20240910005619"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单向链表顾名思义，链表的一个节点只存储值和下一个节点的地址，\n因此节点只能访问下一个节点，而不能访问上一个节点"
				}
			]
		},
		{
			"ID": "20240910005648-8x1i3ys",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910005648-8x1i3ys",
				"updated": "20240910005648"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 468px;",
						"style": "width: 458px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240910005648-bvn5t7p.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 458px;\" parent-style=\"width: 468px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240910005653-v1x47u5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910005653-v1x47u5",
				"updated": "20240910010356"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此，节点类可以实现为：（使用泛型限制存储的类型）"
				}
			]
		},
		{
			"ID": "20240910005848-camxnmu",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240910005848-camxnmu",
				"style": "line-height: 22px;",
				"updated": "20240910005901"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class LinkedNode\u003cT\u003e\n{\n    public T value;\n    //存储下一个元素是什么 相当于钩子（指针）\n    public LinkedNode\u003cT\u003e nextNode;\n\n    public LinkedNode(T value)\n    {\n        this.value = value;\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240910010455-qra98ij",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910010455-qra98ij",
				"updated": "20240910010619"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用构造函数来初始化节点存储的值，然后对 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "nextNode"
				},
				{
					"Type": "NodeText",
					"Data": "​ 赋值使节点得到下一个节点的消息"
				}
			]
		},
		{
			"ID": "20240910010504-hhfozx4",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240910010504-hhfozx4",
				"style": "line-height: 22px;",
				"updated": "20240910010506"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "LinkedNode\u003cint\u003e node1 = new LinkedNode\u003cint\u003e(1);\nLinkedNode\u003cint\u003e node2 = new LinkedNode\u003cint\u003e(2);\nnode1.nextNode = node2;\nnode2.nextNode = new LinkedNode\u003cint\u003e(3);\nnode2.nextNode.nextNode = new LinkedNode\u003cint\u003e(4);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240910005838-r5j0ct0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910005838-r5j0ct0",
				"updated": "20240910011124"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对于单向链表类本身（使用泛型限制存储的类型），我们需要存储第一个元素和最后一个元素\n然后实现增和删的方法，每次增加节点时，需要让末尾的节点指向新增加的节点，\n删除值时，需要遍历节点得到存储对应值的节点，若找到移除节点，设置移除节点的上一个节点指向其下一个节点，这样就是移除出了链表"
				}
			]
		},
		{
			"ID": "20240910010239-cinri7w",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240910010239-cinri7w",
				"style": "line-height: 22px;",
				"updated": "20240910010248"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class LinkedList\u003cT\u003e\n{\n    public LinkedNode\u003cT\u003e head;\n    public LinkedNode\u003cT\u003e last;\n\n    //添加节点，必定是new一个新的节点\n    public void Add(T value)\n    {\n        LinkedNode\u003cT\u003e node = new LinkedNode\u003cT\u003e(value);\n        if (head == null)\n        {\n            head = node;\n            last = node;\n        }\n        else\n        {\n            last.nextNode = node;\n            last = node;\n        }\n    }\n\n    public void Remove(T value)\n    {\n        if (head == null)\n        {\n            return;\n        }\n        if (head.value.Equals(value))\n        {\n            head = head.nextNode;\n            //如果头节点被移除 发现头节点变空\n            //证明只有一个节点，则此时尾也需要清空！\n            if (head == null)\n            {\n                last = null;\n            }\n            return;\n        }\n        LinkedNode\u003cT\u003e node = head;\n        while (node.nextNode != null)\n        {\n            if (node.nextNode.value.Equals(value))\n            {\n                //先检查下一个元素是不是最后一个节点，是则last指向该节点\n                if (node.nextNode.value.Equals(last.value))\n                {\n                    last = node;\n                }\n                //让当前找到的这个元素的 上一个节点\n                //指向 自己的下一个节点\n                node.nextNode = node.nextNode.nextNode;\n                break;\n            }\n            else\n            {\n                node = node.nextNode;\n            }\n        }\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240910010429-uc7t2nz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910010429-uc7t2nz",
				"updated": "20240910011541"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这时，我们便得到了一个最简单的链表"
				}
			]
		},
		{
			"ID": "20240910010718-5suiosp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910010718-5suiosp",
				"updated": "20240910011706"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果要遍历链表，得到链表的首节点，读取值，然后获取其下一个节点，再读取值，再获取下一个节点，\n循环执行以上步骤直到节点不指向任何节点，说明已经遍历到最后一个节点，这样就完成了遍历链表所有节点"
				}
			]
		},
		{
			"ID": "20240910011311-kly8gqh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240910011311-kly8gqh",
				"style": "line-height: 22px;",
				"updated": "20240910011522"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "LinkedList\u003cint\u003e link = new LinkedList\u003cint\u003e();\nlink.Add(1);\nlink.Add(2);\nlink.Add(3);\nlink.Add(4);\nConsole.WriteLine(\"第一次遍历\");\nLinkedNode\u003cint\u003e node = link.head;\nwhile(node != null)\n{\n    Console.WriteLine(node.value);\n    node = node.nextNode;\n}\nlink.Remove(2);\nConsole.WriteLine(\"第二次遍历\");\nnode = link.head;\nwhile (node != null)\n{\n    Console.WriteLine(node.value);\n    node = node.nextNode;\n}\nlink.Remove(1);\nConsole.WriteLine(\"第三次遍历\");\nnode = link.head;\nwhile (node != null)\n{\n    Console.WriteLine(node.value);\n    node = node.nextNode;\n}\nlink.Add(99);\nConsole.WriteLine(\"第四次遍历\");\nnode = link.head;\nwhile (node != null)\n{\n    Console.WriteLine(node.value);\n    node = node.nextNode;\n}\nlink.Remove(99);\nConsole.WriteLine(\"第五次遍历\");\nnode = link.head;\nwhile (node != null)\n{\n    Console.WriteLine(node.value);\n    node = node.nextNode;\n}\nlink.Add(88);\nConsole.WriteLine(\"第六次遍历\");\nnode = link.head;\nwhile (node != null)\n{\n    Console.WriteLine(node.value);\n    node = node.nextNode;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240910011326-mb45tql",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910011326-mb45tql",
				"updated": "20240910011451"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "输出："
				}
			]
		},
		{
			"ID": "20240910011451-n39f5i9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240910011451-n39f5i9",
				"style": "line-height: 22px;",
				"updated": "20240910011453"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "第一次遍历\n1\n2\n3\n4\n第二次遍历\n1\n3\n4\n第三次遍历\n3\n4\n第四次遍历\n3\n4\n99\n第五次遍历\n3\n4\n第六次遍历\n3\n4\n88\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240910011129-37jfy0z",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240910011129-37jfy0z",
				"updated": "20240910012325"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "顺序存储和链式存储的优缺点"
				}
			]
		},
		{
			"ID": "20240910011845-g9jdxi9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910011845-g9jdxi9",
				"updated": "20240910011853"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从增删查改的角度去思考"
				}
			]
		},
		{
			"ID": "20240910011853-3aj21uk",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240910011853-3aj21uk",
				"updated": "20240910011853"
			},
			"Children": [
				{
					"ID": "20240910011853-azi7w6c",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240910011853-azi7w6c",
						"updated": "20240910011853"
					},
					"Children": [
						{
							"ID": "20240910011853-mu8hs1a",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240910011853-mu8hs1a",
								"updated": "20240910011853"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "增：链式存储 计算上 优于顺序存储（中间插入时链式不用像顺序一样去移动位置）\n"
								}
							]
						}
					]
				},
				{
					"ID": "20240910011854-ztiqusf",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240910011854-ztiqusf",
						"updated": "20240910011854"
					},
					"Children": [
						{
							"ID": "20240910011854-rfrvi7u",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240910011854-rfrvi7u",
								"updated": "20240910011854"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "删：链式存储 计算上 优于顺序存储（中间删除是链式不用像顺序一样去移动位置）\n"
								}
							]
						}
					]
				},
				{
					"ID": "20240910011855-nen8omi",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240910011855-nen8omi",
						"updated": "20240910011855"
					},
					"Children": [
						{
							"ID": "20240910011855-ujkjaxn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240910011855-ujkjaxn",
								"updated": "20240910011855"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "查：顺序存储 使用上 优于链式存储（数组可以直接通过下标来得到元素，链式需要遍历）\n"
								}
							]
						}
					]
				},
				{
					"ID": "20240910011855-6fb2vmz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240910011855-6fb2vmz",
						"updated": "20240910011855"
					},
					"Children": [
						{
							"ID": "20240910011855-ja521ge",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240910011855-ja521ge",
								"updated": "20240910011855"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "改：顺序存储 使用上 优于链式存储（数组可以直接通过下标来得到元素，链式需要遍历）"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240910012204-t6id7ly",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240910012204-t6id7ly",
				"updated": "20240910012325"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240910012206-pm6nnp1",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240910012206-pm6nnp1",
						"updated": "20240910012325"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "扩展阅读，关于数据结构的使用："
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "a",
							"TextMarkAHref": "https://www.zhihu.com/question/31082722/answer/1928249851",
							"TextMarkTextContent": "用链表的目的是什么？省空间还是省时间？ - 知乎 (zhihu.com)"
						}
					]
				}
			]
		},
		{
			"ID": "20240910012226-v856fzp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240910012226-v856fzp",
				"updated": "20240910012226"
			}
		}
	]
}