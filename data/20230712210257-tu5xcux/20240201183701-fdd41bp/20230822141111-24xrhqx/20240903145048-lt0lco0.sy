{
	"ID": "20240903145048-lt0lco0",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20240903145048-lt0lco0",
		"title": "CS3L20——接口",
		"type": "doc",
		"updated": "20240904215838"
	},
	"Children": [
		{
			"ID": "20240904141133-gg96w8u",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240904141133-gg96w8u",
				"updated": "20240904141152"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本章代码关键字"
				}
			]
		},
		{
			"ID": "20240904141138-njfnt1y",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240904141138-njfnt1y",
				"style": "line-height: 22px;",
				"updated": "20240904141152"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "interface\t//接口关键字\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240903145048-mikid94",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20240903145048-mikid94",
				"name": "interface",
				"updated": "20240904215838"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接口"
				}
			]
		},
		{
			"ID": "20240903160851-zi4eryh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240903160851-zi4eryh",
				"updated": "20240903160903"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接口是行为的抽象规范，它也是一种自定义类型，关键字："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "inferface"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240904134639-ptsa604",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240904134639-ptsa604",
				"updated": "20240904215838"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "继承接口和继承类的区别"
				}
			]
		},
		{
			"ID": "20240904134634-p6tghlk",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240904134634-p6tghlk",
				"updated": "20240904134713"
			},
			"Children": [
				{
					"ID": "20240904134713-epqxyxz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240904134713-epqxyxz",
						"updated": "20240904134713"
					},
					"Children": [
						{
							"ID": "20240904134713-7grcrrj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240904134713-7grcrrj",
								"updated": "20240904134713"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "继承类 是对象间的继承 包括特征行为等\n"
								}
							]
						}
					]
				},
				{
					"ID": "20240904134714-8ujcqc7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240904134714-8ujcqc7",
						"updated": "20240904134714"
					},
					"Children": [
						{
							"ID": "20240904134714-umb4lpf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240904134714-umb4lpf",
								"updated": "20240904134716"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "继承接口 是行为间的继承 继承接口的行为规范 按照规范去实现内容\n"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240904134717-0s3o97o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904134717-0s3o97o",
				"updated": "20240904134817"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "由于接口也是遵循 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20240903124139-mrvkfp1",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "里氏替换原则"
				},
				{
					"Type": "NodeText",
					"Data": "，所以可以用接口容器装对象，\n那么就可以实现装载 各种毫无关系但是却有相同行为 的对象"
				}
			]
		},
		{
			"ID": "20240904134634-cwua7jj",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240904134634-cwua7jj",
				"updated": "20240904134953"
			},
			"Children": [
				{
					"ID": "20240904134938-9vnrvru",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240904134938-9vnrvru",
						"updated": "20240904134953"
					},
					"Children": [
						{
							"ID": "20240904134938-9nagqu3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240904134938-9nagqu3",
								"updated": "20240904134953"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接口内部只能包含成员方法、索引器、属性、事件，且都不实现，都没有访问修饰符，"
								}
							]
						}
					]
				},
				{
					"ID": "20240904134941-rr8evpp",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240904134941-rr8evpp",
						"updated": "20240904134941"
					},
					"Children": [
						{
							"ID": "20240904134941-xomlip6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240904134941-xomlip6",
								"updated": "20240904134941"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "类可以继承多个接口，但只能继承一个类\n"
								}
							]
						}
					]
				},
				{
					"ID": "20240904134942-acp2xh5",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20240904134942-acp2xh5",
						"updated": "20240904134942"
					},
					"Children": [
						{
							"ID": "20240904134942-froo7ya",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240904134942-froo7ya",
								"updated": "20240904134942"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接口可以继承接口 相当于在进行行为合并 带子类继承时再去实现具体的行为\n"
								}
							]
						}
					]
				},
				{
					"ID": "20240904134942-17zfemb",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20240904134942-17zfemb",
						"updated": "20240904134942"
					},
					"Children": [
						{
							"ID": "20240904134942-pqccl1w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240904134942-pqccl1w",
								"updated": "20240904134942"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接口可以被显式实现 主要用于实现不同接口中的同名函数的不同表现\n"
								}
							]
						}
					]
				},
				{
					"ID": "20240904134943-6zzz2my",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20240904134943-6zzz2my",
						"updated": "20240904134943"
					},
					"Children": [
						{
							"ID": "20240904134943-ji48c2l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240904134943-ji48c2l",
								"updated": "20240904134943"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "实现接口的方法 可以加 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "virtual"
								},
								{
									"Type": "NodeText",
									"Data": "​ 关键字 在之后的子类里重写"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240904125728-u1mmvhc",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240904125728-u1mmvhc",
				"style": "background-color: var(--b3-card-success-background); color: var(--b3-card-success-color);",
				"updated": "20240904134617"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240904132545-131sj67",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240904132545-131sj67",
						"updated": "20240904132956"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "需要执行某种行为，就以行为对应的接口类型作为参数，传入拥有这种行为的对象（继承了对应接口的类对象）\n这样，执行行为就不需要指定具体的类型，以摆脱对具体实现的依赖"
						}
					]
				},
				{
					"ID": "20240904132545-fyc8l39",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240904132545-fyc8l39",
						"updated": "20240904133115"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "因此实际开发中，"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "u",
							"TextMarkTextContent": "建议多多使用接口抽象行为，通过接口类型变量接收具体类对象"
						},
						{
							"Type": "NodeText",
							"Data": "，通过接口调用方法"
						}
					]
				},
				{
					"ID": "20240904125728-037y8ky",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240904125728-037y8ky",
						"updated": "20240904132908"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "接口只规定一个类有什么行为，而不关心行为如何实现，因此相比继承基类，接口更灵活也更加解耦合（不会耦合基类的实现）"
						}
					]
				},
				{
					"ID": "20240904132908-tck5oy0",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240904132908-tck5oy0",
						"updated": "20240904133058"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "例如，飞 这种行为可以单独抽象成接口，\n这样 继承动物类的鸟类 和 继承机器类的飞机类 都可以继承该接口表明这两个类拥有这种行为，\n这样就不需要把 飞 耦合到它们各自的基类内，毕竟不是所有的动物和机器都会飞"
						}
					]
				}
			]
		},
		{
			"ID": "20240903160851-jzy2alj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240903160851-jzy2alj",
				"updated": "20240903160932"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接口申明的规范："
				}
			]
		},
		{
			"ID": "20240903160930-04r2omo",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240903160930-04r2omo",
				"updated": "20240904131644"
			},
			"Children": [
				{
					"ID": "20240903160935-yvipgt8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240903160935-yvipgt8",
						"updated": "20240904131644"
					},
					"Children": [
						{
							"ID": "20240903160935-kovwb96",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240903160935-kovwb96",
								"updated": "20240904131644"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "不包含成员变量，只包含：方法、属性、索引器、事件，且成员不能被实现"
								}
							]
						}
					]
				},
				{
					"ID": "20240903160941-yp7frub",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240903160941-yp7frub",
						"updated": "20240903160941"
					},
					"Children": [
						{
							"ID": "20240903160941-22pjkvz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240903160941-22pjkvz",
								"updated": "20240903160941"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "成员可以不用写访问修饰符，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "u",
									"TextMarkTextContent": "不能是私有的"
								},
								{
									"Type": "NodeText",
									"Data": "\n"
								}
							]
						}
					]
				},
				{
					"ID": "20240903160942-28ybgls",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240903160942-28ybgls",
						"updated": "20240903160942"
					},
					"Children": [
						{
							"ID": "20240903160942-0fis5he",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240903160942-0fis5he",
								"updated": "20240903160942"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接口不能继承类，但可以继承另一个接口"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240903160851-awafxih",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240903160851-awafxih",
				"updated": "20240904130951"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接口的使用规范："
				}
			]
		},
		{
			"ID": "20240903160945-kwhx6lf",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240903160945-kwhx6lf",
				"updated": "20240903160946"
			},
			"Children": [
				{
					"ID": "20240903160946-zvth7vs",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240903160946-zvth7vs",
						"updated": "20240903160946"
					},
					"Children": [
						{
							"ID": "20240903160946-ay5zmdy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240903160946-ay5zmdy",
								"updated": "20240903160946"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "类可以继承多个接口\n"
								}
							]
						}
					]
				},
				{
					"ID": "20240903160946-qgzcnct",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240903160946-qgzcnct",
						"updated": "20240903160946"
					},
					"Children": [
						{
							"ID": "20240903160946-bq6w0d7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240903160946-bq6w0d7",
								"updated": "20240903160946"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "类继承接口后，必须实现接口中的所有成员"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240903160851-50fnp2e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240903160851-50fnp2e",
				"updated": "20240904125637"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "特点："
				}
			]
		},
		{
			"ID": "20240903160957-lik8en9",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20240903160957-lik8en9",
				"updated": "20240903160957"
			},
			"Children": [
				{
					"ID": "20240903160957-i89t3tf",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240903160957-i89t3tf",
						"updated": "20240903160957"
					},
					"Children": [
						{
							"ID": "20240903160957-tfze43e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240903160957-tfze43e",
								"updated": "20240904125640"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "它与类的申明相似"
								}
							]
						}
					]
				},
				{
					"ID": "20240904125639-g9lrf99",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240904125639-g9lrf99",
						"updated": "20240904125639"
					},
					"Children": [
						{
							"ID": "20240904125639-2avt5h0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240904125639-2avt5h0",
								"updated": "20240904125639"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接口是用来继承的\n"
								}
							]
						}
					]
				},
				{
					"ID": "20240903160958-0ajkz5w",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20240903160958-0ajkz5w",
						"updated": "20240903160958"
					},
					"Children": [
						{
							"ID": "20240903160958-44l9zja",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240903160958-44l9zja",
								"updated": "20240903160958"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接口不能被实例化，但可以作为容器存储对象"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240904135009-53mm8v4",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240904135009-53mm8v4",
				"updated": "20240904135129"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240904135009-qrt7uzk",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240904135009-qrt7uzk",
						"updated": "20240904135129"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "C# 接口的更多特性可见："
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "a",
							"TextMarkAHref": "https://www.bilibili.com/video/BV11w411j78c",
							"TextMarkTextContent": "一期视频看透C#接口的全部特性及用法_哔哩哔哩_bilibili"
						},
						{
							"Type": "NodeText",
							"Data": "（注：Unity开发不能全部使用其中的介绍的特性）"
						}
					]
				}
			]
		},
		{
			"ID": "20240904215759-rsavfmv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904215759-rsavfmv",
				"updated": "20240904215838"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "关于接口和抽象类的区别，详见："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20240904215516-rszxf5e",
					"TextMarkBlockRefSubtype": "d",
					"TextMarkTextContent": "CS3L27——抽象类和接口的区别"
				}
			]
		},
		{
			"ID": "20240904130906-h7tz0n4",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240904130906-h7tz0n4",
				"updated": "20240904131636"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接口的声明"
				}
			]
		},
		{
			"ID": "20240904130937-6kg2clv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904130937-6kg2clv",
				"updated": "20240904131636"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接口关键字："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "interface"
				},
				{
					"Type": "NodeText",
					"Data": "​，接口可以认为是"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "抽象行为"
				},
				{
					"Type": "NodeText",
					"Data": "的基类，接口命名规范 帕斯卡前面加 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "I"
				},
				{
					"Type": "NodeText",
					"Data": "​\n不包含成员变量，只包含"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "u",
					"TextMarkTextContent": "方法、属性、索引器、事件"
				},
				{
					"Type": "NodeText",
					"Data": "，成员不能被实现"
				}
			]
		},
		{
			"ID": "20240904130911-syo5ymo",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240904130911-syo5ymo",
				"style": "line-height: 22px;",
				"updated": "20240904130929"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "interface 接口名\n{\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240904131032-jk60doq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904131032-jk60doq",
				"updated": "20240904131059"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "声明示例："
				}
			]
		},
		{
			"ID": "20240904131059-z8aglui",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240904131059-z8aglui",
				"style": "line-height: 22px;",
				"updated": "20240904131304"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "interface IFly\n{\n    //接口不能声明成员变量，成员也不能是私有的\n    void Fly();\t\t\t\t\t//注意 接口里的方法 必须要在 继承接口的子类 里实现，因此不能用private 不写访问修饰符默认是public\n    string Name { set; get; }\t//接口内的成员属性只能像自动属性一样写，不能在其中具体写实现，具体实现需要留到继承接口后的子类里去写\n    int this[int index] { get; set; }\t//接口里的索引器也类似于接口里的属性，不能在其中具体写实现，需要留到继承接口后的子类里去写\n    event Action doSomething;\t//接口可以实现事件，事件具体是什么会在进阶讲解\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240904131306-9xipu7b",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240904131306-9xipu7b",
				"updated": "20240904132346"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接口的使用"
				}
			]
		},
		{
			"ID": "20240904131703-2v6vdnw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904131703-2v6vdnw",
				"updated": "20240904131803"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接口用来继承，它表明某个类拥有这个接口的行为，接口也遵循里氏替换原则\n类可以继承一个类，n个接口，继承了接口后，必须实现其中的内容，且必须是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "public"
				},
				{
					"Type": "NodeText",
					"Data": "​ 的\n实现的接口函数，可以加 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "virtual"
				},
				{
					"Type": "NodeText",
					"Data": "​ 再在子类重写"
				}
			]
		},
		{
			"ID": "20240904132321-8iyobpb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904132321-8iyobpb",
				"updated": "20240904132321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Visual Studio 可以点击灯泡图标里的实现接口来自动实现接口内的所有内容"
				}
			]
		},
		{
			"ID": "20240904132321-6775mz2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904132321-6775mz2",
				"updated": "20240904132321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "width: 447px;",
						"style": "width: 437px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/image-20240904132035-c377tjk.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 437px;\" parent-style=\"width: 447px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20240904131830-jq5ltja",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240904131830-jq5ltja",
				"style": "line-height: 22px;",
				"updated": "20240904132346"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Animal { }\n\nclass Person : Animal, IFly\n{\n    //实现的接口函数，可以加virtual再在子类重写\n    public virtual void Fly() { }\n\n    public string Name \n    {\n        get =\u003e Name;\n        set =\u003e Name = value;\n    }\n    public int this[int index]\n    {\n        get =\u003e 0;\n        set =\u003e this[index] = value;\n    }\n  \n    public event Action doSomething;\n}\n\ninternal class Program\n{\n    static void Main(string[] args)\n    {\n        //IFly f = new IFly();\t//接口不能被实现\n        IFly f = new Person();\t//接口遵循里氏替换原则\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240904132114-ljp8jhr",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240904132114-ljp8jhr",
				"updated": "20240904133300"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接口可以继承接口"
				}
			]
		},
		{
			"ID": "20240904133143-vp0bcsy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904133143-vp0bcsy",
				"updated": "20240904133153"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接口继承接口时，不需要实现，待类继承接口后 类自己去实现所有内容"
				}
			]
		},
		{
			"ID": "20240904133154-piuj2wt",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240904133154-piuj2wt",
				"style": "line-height: 22px;",
				"updated": "20240904133242"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "interface IWalk\n{\n    void Walk();\n}\n\ninterface IMove:IFly, IWalk\n{\n    void Move();\n}\n\nclass Test : IMove\n{\n    public int this[int index] { get =\u003e throw new NotImplementedException(); set =\u003e throw new NotImplementedException(); }\n\n    public string Name { get =\u003e throw new NotImplementedException(); set =\u003e throw new NotImplementedException(); }\n\n    public event Action doSomething;\n\n    public void Fly()\n    {\n        throw new NotImplementedException();\n    }\n\n    public void Move()\n    {\n        throw new NotImplementedException();\n    }\n\n    public void Walk()\n    {\n        throw new NotImplementedException();\n    }\n}\n\ninternal class Program\n{\n    static void Main(string[] args)\n    {\n        //类继承的所有接口，包括接口继承的接口都遵循里氏替换原则\n        IMove im = new Test();\n        IFly If = new Test();\n        IWalk iw = new Test();\n\n        Player p = new Player();\n        ISuperAtk isa = new Player();\n        IAtk ia = new Player();\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240904133300-abu4fzg",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240904133300-abu4fzg",
				"updated": "20240904134543"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "显式实现接口"
				}
			]
		},
		{
			"ID": "20240904133307-igdt79n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904133307-igdt79n",
				"updated": "20240904133755"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当一个类继承两个接口，但是接口中存在着同名方法时，直接只实现一次同名方法是可以运行的，但是这样无法区分两个接口的区别"
				}
			]
		},
		{
			"ID": "20240904133538-0m6p2u4",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240904133538-0m6p2u4",
				"style": "line-height: 22px;",
				"updated": "20240904133810"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "interface IAtk\n{\n    void Atk();\n}\n\ninterface ISuperAtk\n{\n    void Atk();\n}\n\n//可以用灯泡图标里的显式实现所有成员来快速显式实现接口\nclass Player : IAtk, ISuperAtk\n{\n    public void Atk() { }\t// 如果不显式实现接口，虽然可以运行，但是这样就无法区分SuperAtk和Atk的区别了，继承两个接口的意义也不明\n}\n\ninternal class Program\n{\n    static void Main(string[] args)\n    {\n        Player p = new Player();\n        p.Atk()\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240904133723-ypca3uz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904133723-ypca3uz",
				"updated": "20240904134034"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果需要区分两个接口的行为，为不同的接口分别实现不同的方法，则需要显式实现接口\n显式实现接口 就是用 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "接口名.行为名"
				},
				{
					"Type": "NodeText",
					"Data": "​ 去实现\n"
				}
			]
		},
		{
			"ID": "20240904133326-ysjh6m2",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20240904133326-ysjh6m2",
				"style": "background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);",
				"updated": "20240904133326"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20240904133326-t11r10k",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20240904133326-t11r10k",
						"updated": "20240904133326"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "注意：显式实现接口时 不能写访问修饰符，如果接口里有方法是用 "
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "protected"
						},
						{
							"Type": "NodeText",
							"Data": "​ 修饰的也要用显式实现接口"
						}
					]
				}
			]
		},
		{
			"ID": "20240904134109-b26chhh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904134109-b26chhh",
				"updated": "20240904134443"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "显式实现接口后，接口的显式实现方法不能被直接点出来调用了，改成父类装子类或者用 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "as"
				},
				{
					"Type": "NodeText",
					"Data": "​ 来使用"
				}
			]
		},
		{
			"ID": "20240904134035-cqxqpol",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904134035-cqxqpol",
				"updated": "20240904134531"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "指的一提的是，即使显式实现了多个接口的同名方法，\n还是可以再实现一个没有显式实现的方法，通过类对象本身的类型执行\n但是要注意，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "这个方法和其他显式实现方法不构成重载！"
				},
				{
					"Type": "NodeText",
					"Data": "因为它们本质上不是一个名字"
				}
			]
		},
		{
			"ID": "20240904133334-d1e4zyn",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240904133334-d1e4zyn",
				"style": "line-height: 22px;",
				"updated": "20240904134543"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "interface IAtk\n{\n    void Atk();\n}\n\ninterface ISuperAtk\n{\n    void Atk();\n}\n\nclass Player : IAtk, ISuperAtk\n{\n    //显式实现接口 就是用接口名.行为名 去实现\n    void IAtk.Atk()\n    {\n        Console.WriteLine(\"显式实现IAtk的方法\");\n    }\n\n    void ISuperAtk.Atk()\n    {\n        Console.WriteLine(\"显式实现ISuperAtk的方法\");\n    }\n    //显式实现接口后 再在类里写一个atk方法也可以 注意：这不是重载！\n    public void Atk()\n    {\n        Console.WriteLine(\"不是显式实现的方法\");\n    }\n}\n\n\ninternal class Program\n{\n    static void Main(string[] args)\n    {\n        Player p = new Player();\n        ISuperAtk isa = new Player();\n        IAtk ia = new Player();\n\n        //显式实现接口后，接口的方法不能被直接点出来调用了，改成父类装子类或者用as来使用\n        p.Atk();\n        (p as IAtk).Atk();\n        (p as ISuperAtk).Atk();\n        isa.Atk();\n        ia.Atk();\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20240904134401-k1t1ijr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240904134401-k1t1ijr",
				"updated": "20240904134403"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "输出："
				}
			]
		},
		{
			"ID": "20240904134403-k7i5i9a",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20240904134403-k7i5i9a",
				"style": "line-height: 22px;",
				"updated": "20240904134431"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YyM="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "不是显式实现的方法\n显式实现IAtk的方法\n显式实现ISuperAtk的方法\n显式实现ISuperAtk的方法\n显式实现IAtk的方法\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}