{
	"ID": "20250319221505-lpbjtb0",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20250319221505-lpbjtb0",
		"title": "MIL12——模拟面试题",
		"type": "doc",
		"updated": "20250319224036"
	},
	"Children": [
		{
			"ID": "20250319221523-g6576nl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250319221523-g6576nl",
				"updated": "20250319221523"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "C#"
				}
			]
		},
		{
			"ID": "20250319221541-hsf9bym",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250319221541-hsf9bym",
				"updated": "20250319221726"
			},
			"Children": [
				{
					"ID": "20250319221555-7oij6ss",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250319221555-7oij6ss",
						"updated": "20250319221558"
					},
					"Children": [
						{
							"ID": "20250319221555-ivybpbj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221555-ivybpbj",
								"updated": "20250319221558"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "List"
								},
								{
									"Type": "NodeText",
									"Data": "​ 是链表还是数组"
								}
							]
						}
					]
				},
				{
					"ID": "20250319221555-5cprfm3",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250319221555-5cprfm3",
						"updated": "20250319221605"
					},
					"Children": [
						{
							"ID": "20250319221555-nt0xi0i",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221555-nt0xi0i",
								"updated": "20250319221605"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "上一题追问：当 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "list"
								},
								{
									"Type": "NodeText",
									"Data": "​ 满了的时候，我再加入一个元素它的效率会比较低啊，它内部大概是一个什么样的执行过程呢？"
								}
							]
						}
					]
				},
				{
					"ID": "20250319221555-jbvnj4q",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250319221555-jbvnj4q",
						"updated": "20250319221619"
					},
					"Children": [
						{
							"ID": "20250319221555-h3c9gfp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221555-h3c9gfp",
								"updated": "20250319221619"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C"
								},
								{
									"Type": "NodeBackslash",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeText",
											"Data": "#"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 里面有一个常用的接口叫做 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "IDispose"
								},
								{
									"Type": "NodeText",
									"Data": "​，它的作用是？"
								}
							]
						}
					]
				},
				{
					"ID": "20250319221555-8brktmh",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250319221555-8brktmh",
						"updated": "20250319221639"
					},
					"Children": [
						{
							"ID": "20250319221555-h3pthe6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221555-h3pthe6",
								"updated": "20250319221639"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "上一题追问：C"
								},
								{
									"Type": "NodeBackslash",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeText",
											"Data": "#"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 有垃圾回收机制，把一个对象设置为空的时候，系统会帮我们回收，它和接口 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "IDispose"
								},
								{
									"Type": "NodeText",
									"Data": "​ 有什么关系吗？为什么会存在两个做析构事情的东西呢？"
								}
							]
						}
					]
				},
				{
					"ID": "20250319221555-o1jmfxl",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250319221555-o1jmfxl",
						"updated": "20250319221726"
					},
					"Children": [
						{
							"ID": "20250319221555-eg3m3fe",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221555-eg3m3fe",
								"updated": "20250319221726"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity 中的生命周期函数，为什么设计为反射调用，而不是通过继承重写生命周期函数的形式去实现呢？（至少答出一种原因）"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250319221523-otnl96l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250319221523-otnl96l",
				"updated": "20250319221523"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Unity"
				}
			]
		},
		{
			"ID": "20250319221523-bxufa59",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250319221523-bxufa59",
				"updated": "20250319221926"
			},
			"Children": [
				{
					"ID": "20250319221806-p61g9lt",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250319221806-p61g9lt",
						"updated": "20250319221811"
					},
					"Children": [
						{
							"ID": "20250319221806-si9dj0x",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221806-si9dj0x",
								"updated": "20250319221811"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "CPU 和 GPU 他们分别是什么？他们主要完成什么工作"
								}
							]
						}
					]
				},
				{
					"ID": "20250319221806-18sv8x0",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250319221806-18sv8x0",
						"updated": "20250319221818"
					},
					"Children": [
						{
							"ID": "20250319221806-i6f4ufc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221806-i6f4ufc",
								"updated": "20250319221818"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "渲染管线中的几何阶段是由 CPU 主导还是 GPU 主导？该阶段主要是在做什么？"
								}
							]
						}
					]
				},
				{
					"ID": "20250319221806-awvy05s",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250319221806-awvy05s",
						"updated": "20250319221823"
					},
					"Children": [
						{
							"ID": "20250319221806-8d2z0lw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221806-8d2z0lw",
								"updated": "20250319221823"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "是不是所有矩阵都有逆矩阵？如何计算一个矩阵的逆矩阵？"
								}
							]
						}
					]
				},
				{
					"ID": "20250319221806-tw2xc9t",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250319221806-tw2xc9t",
						"updated": "20250319221836"
					},
					"Children": [
						{
							"ID": "20250319221806-3ld2gz3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221806-3ld2gz3",
								"updated": "20250319221836"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "齐次坐标是什么？对于我们有什么作用？"
								}
							]
						}
					]
				},
				{
					"ID": "20250319221806-nvucvvq",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250319221806-nvucvvq",
						"updated": "20250319221926"
					},
					"Children": [
						{
							"ID": "20250319221806-lnzdird",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221806-lnzdird",
								"updated": "20250319221926"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Shader 开发中的坐标空间变换，主要是在哪几个空间中进行变换？变换顺序是什么？"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250319221915-1ekekfp",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20250319221915-1ekekfp",
				"updated": "20250319224036"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "答案"
				}
			]
		},
		{
			"ID": "20250319223007-2huq6pg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250319223007-2huq6pg",
				"updated": "20250319223007"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "C#"
				}
			]
		},
		{
			"ID": "20250319223007-h4y0l79",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250319223007-h4y0l79",
				"updated": "20250319223622"
			},
			"Children": [
				{
					"ID": "20250319223007-8cetoca",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250319223007-8cetoca",
						"updated": "20250319223007"
					},
					"Children": [
						{
							"ID": "20250319223007-v6zbu7y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223007-v6zbu7y",
								"updated": "20250319223007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "List"
								},
								{
									"Type": "NodeText",
									"Data": "​ 是链表还是数组"
								}
							]
						},
						{
							"ID": "20250319223009-ysxtiel",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223009-ysxtiel",
								"updated": "20250319223011"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "数组"
								}
							]
						}
					]
				},
				{
					"ID": "20250319223007-4mi0wa0",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250319223007-4mi0wa0",
						"updated": "20250319223007"
					},
					"Children": [
						{
							"ID": "20250319223007-yhwetar",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223007-yhwetar",
								"updated": "20250319223007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "上一题追问：当 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "list"
								},
								{
									"Type": "NodeText",
									"Data": "​ 满了的时候，我再加入一个元素它的效率会比较低啊，它内部大概是一个什么样的执行过程呢？"
								}
							]
						},
						{
							"ID": "20250319223013-oprzirl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223013-oprzirl",
								"updated": "20250319223022"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "数组搬家，会讲原数组移动到一个更大容量的新数组中，效率较低，并且会产生内存垃圾"
								}
							]
						}
					]
				},
				{
					"ID": "20250319223007-82al4cp",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250319223007-82al4cp",
						"updated": "20250319223007"
					},
					"Children": [
						{
							"ID": "20250319223007-g0g1ni2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223007-g0g1ni2",
								"updated": "20250319223007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C"
								},
								{
									"Type": "NodeBackslash",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeText",
											"Data": "#"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 里面有一个常用的接口叫做 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "IDispose"
								},
								{
									"Type": "NodeText",
									"Data": "​，它的作用是？"
								}
							]
						},
						{
							"ID": "20250319223027-itge60y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223027-itge60y",
								"updated": "20250319223118"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "IDispose"
								},
								{
									"Type": "NodeText",
									"Data": "​ 接口是 C# 中用于手动释放资源的机制 通过显式调用 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Dispose()"
								},
								{
									"Type": "NodeText",
									"Data": "​ 方法来实现资源的释放，避免资源泄漏和浪费\n它允许对象在不再需要时显式地释放资源，而不依赖于垃圾回收器的自动内存管理"
								}
							]
						}
					]
				},
				{
					"ID": "20250319223007-d4nwd1y",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250319223007-d4nwd1y",
						"updated": "20250319223007"
					},
					"Children": [
						{
							"ID": "20250319223007-fjogxob",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223007-fjogxob",
								"updated": "20250319223007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "上一题追问：C"
								},
								{
									"Type": "NodeBackslash",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeText",
											"Data": "#"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 有垃圾回收机制，把一个对象设置为空的时候，系统会帮我们回收，它和接口 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "IDispose"
								},
								{
									"Type": "NodeText",
									"Data": "​ 有什么关系吗？为什么会存在两个做析构事情的东西呢？"
								}
							]
						},
						{
							"ID": "20250319223230-2hd7ggk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223230-2hd7ggk",
								"updated": "20250319223342"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 中的垃圾回收机制，只会回收托管堆上分配的对象。\n对于非托管资源以及其它需要显示释放的资源，垃圾回收是无法自动处理的，因为这些资源不属于托管堆，因此垃圾回收器无法自动识别和回收。\n这种情况下我们就需要显示的手动释放这些资源了。 而 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "IDispose"
								},
								{
									"Type": "NodeText",
									"Data": "​ 接口就提供了一种通用的机制来进行资源清理，主要用于释放非托管资源。"
								}
							]
						},
						{
							"ID": "20250319223345-twjs7pv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223345-twjs7pv",
								"updated": "20250319223355"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "非托管资源："
								}
							]
						},
						{
							"ID": "20250319223355-ztw6gtb",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250319223355-ztw6gtb",
								"updated": "20250319223355"
							},
							"Children": [
								{
									"ID": "20250319223355-t732v6p",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250319223355-t732v6p",
										"updated": "20250319223355"
									},
									"Children": [
										{
											"ID": "20250319223355-9ithj4r",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223355-9ithj4r",
												"updated": "20250319223357"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "文件句柄，在操作系统中打开的文件等"
												}
											]
										}
									]
								},
								{
									"ID": "20250319223357-7ko7z8a",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250319223357-7ko7z8a",
										"updated": "20250319223357"
									},
									"Children": [
										{
											"ID": "20250319223357-d5x6k0y",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223357-d5x6k0y",
												"updated": "20250319223401"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "数据库链接，与数据库服务器简历的链接"
												}
											]
										}
									]
								},
								{
									"ID": "20250319223401-6dw2fau",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "My4=",
										"Num": 3
									},
									"Properties": {
										"id": "20250319223401-6dw2fau",
										"updated": "20250319223401"
									},
									"Children": [
										{
											"ID": "20250319223401-m4xrdg7",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223401-m4xrdg7",
												"updated": "20250319223408"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "网络链接：比如 Socket 的连接对象"
												}
											]
										}
									]
								},
								{
									"ID": "20250319223408-rvut78z",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "NC4=",
										"Num": 4
									},
									"Properties": {
										"id": "20250319223408-rvut78z",
										"updated": "20250319223408"
									},
									"Children": [
										{
											"ID": "20250319223408-g0swthq",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223408-g0swthq",
												"updated": "20250319223414"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "unsafe"
												},
												{
													"Type": "NodeText",
													"Data": "​ 关键词中使用的指针"
												}
											]
										}
									]
								}
							]
						},
						{
							"ID": "20250319223414-l3ls3uf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223414-l3ls3uf",
								"updated": "20250319223415"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "等等"
								}
							]
						}
					]
				},
				{
					"ID": "20250319223007-qtc8nvl",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250319223007-qtc8nvl",
						"updated": "20250319223622"
					},
					"Children": [
						{
							"ID": "20250319223007-8fradp7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223007-8fradp7",
								"updated": "20250319223007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity 中的生命周期函数，为什么设计为反射调用，而不是通过继承重写生命周期函数的形式去实现呢？（至少答出一种原因）"
								}
							]
						},
						{
							"ID": "20250319223516-t8n5lg3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223516-t8n5lg3",
								"updated": "20250319223523"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "可能原因包括："
								}
							]
						},
						{
							"ID": "20250319223516-tm1556j",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250319223516-tm1556j",
								"updated": "20250319223622"
							},
							"Children": [
								{
									"ID": "20250319223448-w39azp2",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250319223448-w39azp2",
										"updated": "20250319223448"
									},
									"Children": [
										{
											"ID": "20250319223448-ticnuux",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223448-ticnuux",
												"updated": "20250319223510"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "并非所有继承 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "MonoBehaviour"
												},
												{
													"Type": "NodeText",
													"Data": "​ 的类都需要使用所有声明周期函数，如果使用继承，就会有大量的空虚函数被调用，\n而使用反射，有哪些生命周期就调用哪些，并且反射还可以调用私有方法。\nUnity 只需要维护有对应生命周期函数的脚本列表，就可以避免空虚函数的调用了。"
												}
											]
										}
									]
								},
								{
									"ID": "20250319223524-x0xyfzs",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250319223524-x0xyfzs",
										"updated": "20250319223524"
									},
									"Children": [
										{
											"ID": "20250319223524-ea8kf77",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223524-ea8kf77",
												"updated": "20250319223558"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "Unity 采用组件式设计，通过使用反射，可以将某些逻辑解耦，将组件的功能模块化，使得逻辑更加灵活和可复用，\n当触发一个生命周期，需要通知相应 GameObject 的所有组件，\n如果使用继承多态来实现，则所有组件都要派生自包含对应生命周期的基类，或者是筛选出派生自此基类的组件逐一通知。\n这样一来容易带来复杂的继承关系，并且很麻烦，就和组件式倡导的聚合代替继承的设计从理念上相悖了。"
												}
											]
										}
									]
								},
								{
									"ID": "20250319223602-gackmwf",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "My4=",
										"Num": 3
									},
									"Properties": {
										"id": "20250319223602-gackmwf",
										"updated": "20250319223622"
									},
									"Children": [
										{
											"ID": "20250319223602-f66fp6f",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223602-f66fp6f",
												"updated": "20250319223622"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "Unity 提供插件和外部脚本支持，这些脚本可能不是在 Unity 中编写的，\n而是通过第三方库或外部工具生成的，为了支持这些脚本，可以使用反射机制调用其生命周期函数"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250319223007-v12ts59",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250319223007-v12ts59",
				"updated": "20250319223007"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Unity"
				}
			]
		},
		{
			"ID": "20250319223007-a0l3vu5",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250319223007-a0l3vu5",
				"updated": "20250319224036"
			},
			"Children": [
				{
					"ID": "20250319223007-303ewf6",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250319223007-303ewf6",
						"updated": "20250319223007"
					},
					"Children": [
						{
							"ID": "20250319223007-wjk4kog",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223007-wjk4kog",
								"updated": "20250319223007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "CPU 和 GPU 他们分别是什么？他们主要完成什么工作"
								}
							]
						},
						{
							"ID": "20250319223636-irrsmqz",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20250319223636-irrsmqz",
								"updated": "20250319223639"
							},
							"Children": [
								{
									"ID": "20250319223639-xew0bvp",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319223639-xew0bvp",
										"updated": "20250319223639"
									},
									"Children": [
										{
											"ID": "20250319223639-gmkh270",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223639-gmkh270",
												"updated": "20250319223646"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "CPU为中央处理器"
												}
											]
										},
										{
											"ID": "20250319223646-yud3xzw",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223646-yud3xzw",
												"updated": "20250319223659"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "负责算数运算、逻辑操作、数据传输等通用计算任务，同时还管理和调度计算机的资源 （游戏开发中 —— 游戏逻辑处理），\n主要处理操作系统管理、程序执行、通用计算等等 CPU一般处理串行任务，即顺序执行的单个任务，适用于大多数常规计算"
												}
											]
										}
									]
								},
								{
									"ID": "20250319223707-meej5w0",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319223707-meej5w0",
										"updated": "20250319223707"
									},
									"Children": [
										{
											"ID": "20250319223707-zc1hfok",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223707-zc1hfok",
												"updated": "20250319223709"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "GPU为图形处理器"
												}
											]
										},
										{
											"ID": "20250319223709-2y6i55v",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223709-2y6i55v",
												"updated": "20250319223733"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "是专门用于图形和并行计算的处理器，显卡就是搭载 GPU 的硬件设备，\n显卡包含一个或多个 GPU 芯片，还包含显存（用于存储图像数据）、显示接口、视频解码器等等（游戏开发中—渲染相关处理）\nGPU 主要处理并行任务，适用于图形渲染、3D游戏、机器学习、科学计算等需要大量并行计算的领域"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20250319223007-eq6vhjt",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250319223007-eq6vhjt",
						"updated": "20250319223007"
					},
					"Children": [
						{
							"ID": "20250319223007-p3cbks4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223007-p3cbks4",
								"updated": "20250319223007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "渲染管线中的几何阶段是由 CPU 主导还是 GPU 主导？该阶段主要是在做什么？"
								}
							]
						},
						{
							"ID": "20250319223753-oa8muht",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223753-oa8muht",
								"updated": "20250319223811"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "渲染管线中的几何阶段主要由 GPU 主导，在几何阶段中完成的最主要工作就是 顶点、法线 等模型数据的相关处理\n对他们进行坐标空间转换，裁剪画面外图元等等，还可以进行顶点着色，为每个顶点计算颜色、纹理坐标、法线等属性，以便在后续阶段用于处理"
								}
							]
						}
					]
				},
				{
					"ID": "20250319223007-416arke",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250319223007-416arke",
						"updated": "20250319223007"
					},
					"Children": [
						{
							"ID": "20250319223007-jkmgt7e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223007-jkmgt7e",
								"updated": "20250319223007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "是不是所有矩阵都有逆矩阵？如何计算一个矩阵的逆矩阵？"
								}
							]
						},
						{
							"ID": "20250319223823-kw2ttyg",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250319223823-kw2ttyg",
								"updated": "20250319223850"
							},
							"Children": [
								{
									"ID": "20250319223850-zoz3x0r",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250319223850-zoz3x0r",
										"updated": "20250319223850"
									},
									"Children": [
										{
											"ID": "20250319223850-i8ph6gw",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223850-i8ph6gw",
												"updated": "20250319223852"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "并不是所有矩阵都有逆矩阵"
												}
											]
										}
									]
								},
								{
									"ID": "20250319223852-xukaxcs",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250319223852-xukaxcs",
										"updated": "20250319223852"
									},
									"Children": [
										{
											"ID": "20250319223852-u7xt0vb",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319223852-u7xt0vb",
												"updated": "20250319223858"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "计算流程"
												}
											]
										},
										{
											"ID": "20250319223859-oqdoozd",
											"Type": "NodeList",
											"ListData": {
												"Typ": 1
											},
											"Properties": {
												"id": "20250319223859-oqdoozd",
												"updated": "20250319223859"
											},
											"Children": [
												{
													"ID": "20250319223858-ttiefer",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "MS4=",
														"Num": 1
													},
													"Properties": {
														"id": "20250319223858-ttiefer",
														"updated": "20250319223858"
													},
													"Children": [
														{
															"ID": "20250319223858-v2exgxz",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319223858-v2exgxz",
																"updated": "20250319223858"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "第一步：确定矩阵是否为方阵（即行列数相等） "
																}
															]
														}
													]
												},
												{
													"ID": "20250319223901-xr9153e",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "Mi4=",
														"Num": 2
													},
													"Properties": {
														"id": "20250319223901-xr9153e",
														"updated": "20250319223901"
													},
													"Children": [
														{
															"ID": "20250319223901-aioi2a8",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319223901-aioi2a8",
																"updated": "20250319223904"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "第二步：计算矩阵的行列式（若行列式为0，则该矩阵没有逆矩阵）"
																}
															]
														}
													]
												},
												{
													"ID": "20250319223904-psjcoil",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "My4=",
														"Num": 3
													},
													"Properties": {
														"id": "20250319223904-psjcoil",
														"updated": "20250319223904"
													},
													"Children": [
														{
															"ID": "20250319223904-x1bb4ad",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319223904-x1bb4ad",
																"updated": "20250319223907"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "第三步：计算矩阵的代数余子式矩阵"
																}
															]
														}
													]
												},
												{
													"ID": "20250319223907-liur5l1",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "NC4=",
														"Num": 4
													},
													"Properties": {
														"id": "20250319223907-liur5l1",
														"updated": "20250319223907"
													},
													"Children": [
														{
															"ID": "20250319223907-1bfuap0",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319223907-1bfuap0",
																"updated": "20250319223909"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "第四步：计算标准伴随矩阵（转置代数余子式矩阵）"
																}
															]
														}
													]
												},
												{
													"ID": "20250319223910-1i5bi5o",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "NS4=",
														"Num": 5
													},
													"Properties": {
														"id": "20250319223910-1i5bi5o",
														"updated": "20250319223910"
													},
													"Children": [
														{
															"ID": "20250319223910-q2lxv1y",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319223910-q2lxv1y",
																"updated": "20250319223910"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "第五步：计算逆矩阵（标准伴随矩阵 / 行列式）"
																}
															]
														}
													]
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20250319223007-6hd3nul",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250319223007-6hd3nul",
						"updated": "20250319223007"
					},
					"Children": [
						{
							"ID": "20250319223007-yu6658e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223007-yu6658e",
								"updated": "20250319223007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "齐次坐标是什么？对于我们有什么作用？"
								}
							]
						},
						{
							"ID": "20250319223931-ei07p9d",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223931-ei07p9d",
								"updated": "20250319223957"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "齐次坐标就是将一个原本是 n 维的向量或矩阵用 n + 1 维来表示，是一种扩展的坐标系统，\n用于在计算机图形学等学科中进行数学运算，利用齐次坐标，我们可以明确的区分向量和点，能够表示出平移变换"
								}
							]
						}
					]
				},
				{
					"ID": "20250319223007-verdxys",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250319223007-verdxys",
						"updated": "20250319224036"
					},
					"Children": [
						{
							"ID": "20250319223007-fxmz5g1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319223007-fxmz5g1",
								"updated": "20250319223007"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Shader 开发中的坐标空间变换，主要是在哪几个空间中进行变换？变换顺序是什么？"
								}
							]
						},
						{
							"ID": "20250319224000-4kaw3l1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319224000-4kaw3l1",
								"updated": "20250319224036"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "主要是将模型相关数据（顶点、法线、切线等）在：模型空间 —\u003e 世界空间 —\u003e 观察空间 —\u003e 裁剪空间 —\u003e 屏幕空间 之间进行变换"
								}
							]
						}
					]
				}
			]
		}
	]
}