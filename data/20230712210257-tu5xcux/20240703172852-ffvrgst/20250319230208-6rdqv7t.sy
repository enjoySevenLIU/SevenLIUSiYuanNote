{
	"ID": "20250319230208-6rdqv7t",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20250319230208-6rdqv7t",
		"title": "MIL14——模拟面试题",
		"type": "doc",
		"updated": "20250319232404"
	},
	"Children": [
		{
			"ID": "20250319230232-7i1m8jz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250319230232-7i1m8jz",
				"updated": "20250319230232"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "C#"
				}
			]
		},
		{
			"ID": "20250319230232-129piml",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250319230232-129piml",
				"updated": "20250319231625"
			},
			"Children": [
				{
					"ID": "20250319230305-2lgghen",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250319230305-2lgghen",
						"updated": "20250319230305"
					},
					"Children": [
						{
							"ID": "20250319230305-iqtfiva",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319230305-iqtfiva",
								"updated": "20250319230316"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 中属性（Property）和字段（Field）的区别是什么？"
								}
							]
						},
						{
							"ID": "20250319231110-8067dns",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319231110-8067dns",
								"updated": "20250319231339"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "属性一般可以用来封装字段，属性相对字段来说，属性具有封装性，允许对字段进行封装，提供更多的控制和逻辑。\n相比直接访问字段来说，属性允许我们在字段访问的过程汇总添加验证、计算等逻辑，\n属性还可以在其中对 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "set"
								},
								{
									"Type": "NodeText",
									"Data": "​ 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "get"
								},
								{
									"Type": "NodeText",
									"Data": "​ 设置不同的访问级别，使得字段的读取和写入可以收到更精细的控制"
								}
							]
						}
					]
				},
				{
					"ID": "20250319230305-o4ale73",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250319230305-o4ale73",
						"updated": "20250319230305"
					},
					"Children": [
						{
							"ID": "20250319230305-2xdtvk2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319230305-2xdtvk2",
								"updated": "20250319230335"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请解释一下 C# 中的异步编程模型（"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "async"
								},
								{
									"Type": "NodeText",
									"Data": "​ / "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "await"
								},
								{
									"Type": "NodeText",
									"Data": "​），它是用来做什么的？"
								}
							]
						},
						{
							"ID": "20250319231341-5h5t5r0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319231341-5h5t5r0",
								"updated": "20250319231400"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C"
								},
								{
									"Type": "NodeBackslash",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeText",
											"Data": "#"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 中的异步编程模型是一种用于处理并发任务的技术\n允许在执行异步操作时，让程序继续执行其他任务，而不会阻塞主线程。\n这对于处理诸如网络请求、文件读写、长时间计算等耗时操作非常有用"
								}
							]
						}
					]
				},
				{
					"ID": "20250319230305-zmhef8q",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250319230305-zmhef8q",
						"updated": "20250319230305"
					},
					"Children": [
						{
							"ID": "20250319230305-iwu13rl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319230305-iwu13rl",
								"updated": "20250319230305"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请问七大排序算法一般指哪七种排序算法？你一般常用的排序算法是哪种？请简单描述它的排序原理"
								}
							]
						},
						{
							"ID": "20250319231410-qevjlze",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319231410-qevjlze",
								"updated": "20250319231423"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序"
								}
							]
						}
					]
				},
				{
					"ID": "20250319230305-plw0py8",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250319230305-plw0py8",
						"updated": "20250319230305"
					},
					"Children": [
						{
							"ID": "20250319230305-o97g382",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319230305-o97g382",
								"updated": "20250319230305"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请简单描述斐波那契数列的基本规则是什么"
								}
							]
						},
						{
							"ID": "20250319231426-pynqtye",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319231426-pynqtye",
								"updated": "20250319231527"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "假设数列从索引 0 开始，斐波那契数列的基本规则就是从数列的第2项开始，每一项的值都是前两项的和："
								}
							]
						},
						{
							"ID": "20250319231527-qs4pyyh",
							"Type": "NodeMathBlock",
							"Properties": {
								"id": "20250319231527-qs4pyyh",
								"updated": "20250319231558"
							},
							"Children": [
								{
									"Type": "NodeMathBlockOpenMarker"
								},
								{
									"Type": "NodeMathBlockContent",
									"Data": "F(n) = F(n-1)+F(n-2)"
								},
								{
									"Type": "NodeMathBlockCloseMarker"
								}
							]
						},
						{
							"ID": "20250319231518-skivedx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319231518-skivedx",
								"updated": "20250319231522"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "即：1,1,2,3,5,8,13,21......."
								}
							]
						}
					]
				},
				{
					"ID": "20250319230305-sd2bk6b",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250319230305-sd2bk6b",
						"updated": "20250319231625"
					},
					"Children": [
						{
							"ID": "20250319230305-3l95p1g",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319230305-3l95p1g",
								"updated": "20250319230344"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请简单描述 A 星寻路算法的基本原理"
								}
							]
						},
						{
							"ID": "20250319231601-c4wpj0k",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319231601-c4wpj0k",
								"updated": "20250319231612"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "关键点："
								}
							]
						},
						{
							"ID": "20250319231612-cm9z9hu",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250319231612-cm9z9hu",
								"updated": "20250319231625"
							},
							"Children": [
								{
									"ID": "20250319231612-7e3jbya",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250319231612-7e3jbya",
										"updated": "20250319231625"
									},
									"Children": [
										{
											"ID": "20250319231612-6qk82lb",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319231612-6qk82lb",
												"updated": "20250319231625"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "寻路消耗公式："
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "inline-math",
													"TextMarkInlineMathContent": "f(寻路消耗) = g(离起点距离) + h(离重点距离) "
												}
											]
										}
									]
								},
								{
									"ID": "20250319231615-cv3z9lp",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250319231615-cv3z9lp",
										"updated": "20250319231615"
									},
									"Children": [
										{
											"ID": "20250319231615-oxkjkui",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319231615-oxkjkui",
												"updated": "20250319231618"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "开启列表\n"
												}
											]
										}
									]
								},
								{
									"ID": "20250319231619-ae99dcx",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "My4=",
										"Num": 3
									},
									"Properties": {
										"id": "20250319231619-ae99dcx",
										"updated": "20250319231619"
									},
									"Children": [
										{
											"ID": "20250319231619-s4y4mb8",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319231619-s4y4mb8",
												"updated": "20250319231621"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "关闭列表"
												}
											]
										}
									]
								},
								{
									"ID": "20250319231621-e26y9jn",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "NC4=",
										"Num": 4
									},
									"Properties": {
										"id": "20250319231621-e26y9jn",
										"updated": "20250319231621"
									},
									"Children": [
										{
											"ID": "20250319231621-vzdxuai",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319231621-vzdxuai",
												"updated": "20250319231621"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "基本原理： 每一次寻路，计算周围点的寻路消耗，并放入开启列表，对开启列表进行排序，得到寻路消耗最小的点放入关闭列表中"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250319230232-cu8jwvi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250319230232-cu8jwvi",
				"updated": "20250319230232"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Unity"
				}
			]
		},
		{
			"ID": "20250319230232-a2shatl",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250319230232-a2shatl",
				"updated": "20250319232404"
			},
			"Children": [
				{
					"ID": "20250319230402-brdc1cq",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250319230402-brdc1cq",
						"updated": "20250319230402"
					},
					"Children": [
						{
							"ID": "20250319230402-kihoush",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319230402-kihoush",
								"updated": "20250319230406"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Unity 中，有时在第一次执行 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "GameObject.Instantiate"
								},
								{
									"Type": "NodeText",
									"Data": "​ 的时候有明显卡顿，该怎么解决？"
								}
							]
						},
						{
							"ID": "20250319231832-uj9cyos",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319231832-uj9cyos",
								"updated": "20250319231842"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "通过 Unity 的 Profiler 窗口排查卡顿原因，一般有以下几种可能性："
								}
							]
						},
						{
							"ID": "20250319231842-plc3f47",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250319231842-plc3f47",
								"updated": "20250319231842"
							},
							"Children": [
								{
									"ID": "20250319231842-xv9sd96",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250319231842-xv9sd96",
										"updated": "20250319231842"
									},
									"Children": [
										{
											"ID": "20250319231842-m6qndu6",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319231842-m6qndu6",
												"updated": "20250319231854"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "加载过大资源造成卡顿，解决方案："
												}
											]
										},
										{
											"ID": "20250319231857-v0hvzhh",
											"Type": "NodeList",
											"ListData": {
												"Typ": 1
											},
											"Properties": {
												"id": "20250319231857-v0hvzhh",
												"updated": "20250319231900"
											},
											"Children": [
												{
													"ID": "20250319231900-bkdt2ov",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "MS4=",
														"Num": 1
													},
													"Properties": {
														"id": "20250319231900-bkdt2ov",
														"updated": "20250319231900"
													},
													"Children": [
														{
															"ID": "20250319231900-hoxssyj",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319231900-hoxssyj",
																"updated": "20250319231903"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "预加载资源"
																}
															]
														}
													]
												},
												{
													"ID": "20250319231903-9hya6f4",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "Mi4=",
														"Num": 2
													},
													"Properties": {
														"id": "20250319231903-9hya6f4",
														"updated": "20250319231903"
													},
													"Children": [
														{
															"ID": "20250319231903-c2lipks",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319231903-c2lipks",
																"updated": "20250319231906"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "简化资源（修改图片大小，减少模型顶点、面数，压缩优化资源等）"
																}
															]
														}
													]
												},
												{
													"ID": "20250319231907-899teoh",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "My4=",
														"Num": 3
													},
													"Properties": {
														"id": "20250319231907-899teoh",
														"updated": "20250319231907"
													},
													"Children": [
														{
															"ID": "20250319231907-9znbxio",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319231907-9znbxio",
																"updated": "20250319231907"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "异步加载资源（分帧加载）"
																}
															]
														}
													]
												}
											]
										}
									]
								},
								{
									"ID": "20250319231848-pbz4ixw",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250319231848-pbz4ixw",
										"updated": "20250319231848"
									},
									"Children": [
										{
											"ID": "20250319231848-3u0u1g0",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319231848-3u0u1g0",
												"updated": "20250319231912"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "对象挂载的脚本中初始化耗时，解决方案："
												}
											]
										},
										{
											"ID": "20250319231915-f94hfpu",
											"Type": "NodeList",
											"ListData": {
												"Typ": 1
											},
											"Properties": {
												"id": "20250319231915-f94hfpu",
												"updated": "20250319231915"
											},
											"Children": [
												{
													"ID": "20250319231915-9qrs2zh",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "MS4=",
														"Num": 1
													},
													"Properties": {
														"id": "20250319231915-9qrs2zh",
														"updated": "20250319231915"
													},
													"Children": [
														{
															"ID": "20250319231915-z22qtrc",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319231915-z22qtrc",
																"updated": "20250319231915"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "减少序列化或反序列化信息"
																}
															]
														}
													]
												},
												{
													"ID": "20250319231918-ow0e4v9",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "Mi4=",
														"Num": 2
													},
													"Properties": {
														"id": "20250319231918-ow0e4v9",
														"updated": "20250319231918"
													},
													"Children": [
														{
															"ID": "20250319231918-q7s4vk7",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319231918-q7s4vk7",
																"updated": "20250319231918"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "优化初始化相关逻辑，提前初始化，分帧初始化等"
																}
															]
														}
													]
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20250319230402-yjqt1of",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250319230402-yjqt1of",
						"updated": "20250319230402"
					},
					"Children": [
						{
							"ID": "20250319230402-n60go9w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319230402-n60go9w",
								"updated": "20250319231821"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Unity 中 AssetBundle 的压缩方式有不压缩、LZMA、LZ4 三种，请问 LZMA 和 LZ4 有什么区别？"
								}
							]
						},
						{
							"ID": "20250319231943-qhrgu7m",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20250319231943-qhrgu7m",
								"updated": "20250319231946"
							},
							"Children": [
								{
									"ID": "20250319231946-1e4pkio",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319231946-1e4pkio",
										"updated": "20250319231946"
									},
									"Children": [
										{
											"ID": "20250319231946-k7nubdv",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319231946-k7nubdv",
												"updated": "20250319231956"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "LZMA：压缩算法为 Lempel-Ziv-Markov chain-Algorithm，"
												}
											]
										},
										{
											"ID": "20250319232000-7dan1mj",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319232000-7dan1mj",
												"updated": "20250319232000"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "压缩包最小（压缩率更高），但是解压过程较慢，耗时较长（因为它需要进行更多的解压缩操作）"
												}
											]
										}
									]
								},
								{
									"ID": "20250319232003-ostsroj",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319232003-ostsroj",
										"updated": "20250319232003"
									},
									"Children": [
										{
											"ID": "20250319232003-xsfkspj",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319232003-xsfkspj",
												"updated": "20250319232006"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "LZ4：压缩算法为Lempel-Ziv 4"
												}
											]
										},
										{
											"ID": "20250319232006-ih7vaap",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319232006-ih7vaap",
												"updated": "20250319232013"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "压缩包较大（压缩率较低），但是不要求完整的数据包就可以解压缩，无需解压完整压缩包，解压时间快（几乎可以立即解压 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "AssetBundle"
												},
												{
													"Type": "NodeText",
													"Data": "​）"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20250319230402-202r3iy",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250319230402-202r3iy",
						"updated": "20250319230402"
					},
					"Children": [
						{
							"ID": "20250319230402-yr6r9wm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319230402-yr6r9wm",
								"updated": "20250319230806"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity 中 DrawCall、Batches、SetPass Calls 的意思是什么"
								}
							]
						},
						{
							"ID": "20250319231221-0o88knj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319231221-0o88knj",
								"updated": "20250319231221"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeImage",
									"Data": "span",
									"Properties": {
										"style": "width: 325px;"
									},
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText",
											"Data": "image"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "assets/image-20250319231221-isz3zlt.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeKramdownSpanIAL",
									"Data": "{: style=\"width: 325px;\"}"
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						},
						{
							"ID": "20250319232058-oc9u5lk",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20250319232058-oc9u5lk",
								"updated": "20250319232101"
							},
							"Children": [
								{
									"ID": "20250319232101-zsxpr8t",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319232101-zsxpr8t",
										"updated": "20250319232101"
									},
									"Children": [
										{
											"ID": "20250319232101-zh6ehct",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319232101-zh6ehct",
												"updated": "20250319232101"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "Draw Call： 表示渲染请求的数量（每个 Draw Call 都会引起一次从 CPU 到 GPU 的数据传输）"
												}
											]
										},
										{
											"ID": "20250319232216-83x3sey",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319232216-83x3sey",
												"updated": "20250319232230"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "直接影响渲染性能，因为它决定了 CPU 和 GPU 之间的通信次数，\n减少 DrawCall 的数量通常是优化渲染性能的关键之一，可以通过使用批处理技术（Batching）来合并多个物体为一个 DrawCall 来实现"
												}
											]
										}
									]
								},
								{
									"ID": "20250319232112-n7931b6",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319232112-n7931b6",
										"updated": "20250319232112"
									},
									"Children": [
										{
											"ID": "20250319232112-w58hmne",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319232112-w58hmne",
												"updated": "20250319232112"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "Batches： 是一种将多个物体合并为一个 Draw Call 的渲染优化技术"
												}
											]
										},
										{
											"ID": "20250319232155-07ba6r9",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319232155-07ba6r9",
												"updated": "20250319232202"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "它将多个相似的物体合并成一个 Draw Call，从而减少 CPU 到 GPU 的数据传输和渲染开销\n可以使用静态批处理、动态批处理和 GPU Instancing 等技术来进一步优化 Batch"
												}
											]
										}
									]
								},
								{
									"ID": "20250319232118-pxeowsx",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319232118-pxeowsx",
										"updated": "20250319232118"
									},
									"Children": [
										{
											"ID": "20250319232118-z7hoxrf",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319232118-z7hoxrf",
												"updated": "20250319232140"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "SetPass Calls：渲染 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Pass"
												},
												{
													"Type": "NodeText",
													"Data": "​（Shader 中渲染通道）的数量，移动平台中尽量减少 Shader 中 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Pass"
												},
												{
													"Type": "NodeText",
													"Data": "​ 的数量可以提升性能"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20250319230402-rcikutt",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250319230402-rcikutt",
						"updated": "20250319230402"
					},
					"Children": [
						{
							"ID": "20250319230402-dhxdpjy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319230402-dhxdpjy",
								"updated": "20250319230809"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity Shader 中，深度测试是在做什么？"
								}
							]
						},
						{
							"ID": "20250319232332-u7yjlf6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319232332-u7yjlf6",
								"updated": "20250319232341"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "深度测试用于确定哪些像素应该被绘制到屏幕上，并决定它们的可见性。\n深度测试的主要目标是解决遮挡关系，确保前面的对象覆盖后面的对象，从而正确呈现场景"
								}
							]
						}
					]
				},
				{
					"ID": "20250319230402-y3s1q5j",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250319230402-y3s1q5j",
						"updated": "20250319232404"
					},
					"Children": [
						{
							"ID": "20250319230402-ux2t3lk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319230402-ux2t3lk",
								"updated": "20250319230812"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity Shader 中某片元通过了深度测试，但是没有开启深度写入，该片元的颜色信息是否写入到颜色缓冲区？"
								}
							]
						},
						{
							"ID": "20250319232345-lolfnxs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319232345-lolfnxs",
								"updated": "20250319232404"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "会写入颜色缓冲区，因为深度写入和颜色写入是两个独立的操作\n只要通过了深度测试，不管是否写入深度缓冲区，该片元的颜色信息都会写入到颜色缓冲区中"
								}
							]
						}
					]
				}
			]
		}
	]
}