{
	"ID": "20240717133104-d13rfmd",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20240717133104-d13rfmd",
		"title": "MIL4——模拟面试题",
		"type": "doc",
		"updated": "20240717134911"
	},
	"Children": [
		{
			"ID": "20240717133257-btnm8s0",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240717133257-btnm8s0",
				"updated": "20240717133811"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "问题"
				}
			]
		},
		{
			"ID": "20240717133257-jfdb7kn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240717133257-jfdb7kn",
				"updated": "20240717133257"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "C#"
				}
			]
		},
		{
			"ID": "20240717133257-5c1x5dy",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240717133257-5c1x5dy",
				"updated": "20240717133454"
			},
			"Children": [
				{
					"ID": "20240717133257-mdtrsrl",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240717133257-mdtrsrl",
						"updated": "20240717133322"
					},
					"Children": [
						{
							"ID": "20240717133257-geznnx2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133257-geznnx2",
								"updated": "20240717133322"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请说明字符串中 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "string str = null"
								},
								{
									"Type": "NodeText",
									"Data": "​、"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "string str = \u0026quot;\u0026quot;"
								},
								{
									"Type": "NodeText",
									"Data": "​、"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "string str = string.Empty"
								},
								{
									"Type": "NodeText",
									"Data": "​ 三者的区别"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133257-gnh9g3s",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240717133257-gnh9g3s",
						"updated": "20240717133410"
					},
					"Children": [
						{
							"ID": "20240717133257-9dxg2m9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133257-9dxg2m9",
								"updated": "20240717133410"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C"
								},
								{
									"Type": "NodeBackslash",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeText",
											"Data": "#"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 重载运算符，重载 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "=="
								},
								{
									"Type": "NodeText",
									"Data": "​ 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "!="
								},
								{
									"Type": "NodeText",
									"Data": "​ 以及 万物之父 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "object"
								},
								{
									"Type": "NodeText",
									"Data": "​ 基类中的虚方法 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "virtual bool Equals(Object obj)"
								},
								{
									"Type": "NodeText",
									"Data": "​ 对于我们的意义是什么？"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133257-6m4j6p2",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20240717133257-6m4j6p2",
						"updated": "20240717133423"
					},
					"Children": [
						{
							"ID": "20240717133257-bzfbkav",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133257-bzfbkav",
								"updated": "20240717133423"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在开发时，对 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "string"
								},
								{
									"Type": "NodeText",
									"Data": "​ 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "StringBuilder"
								},
								{
									"Type": "NodeText",
									"Data": "​ 我们应该如何选择"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133257-p119nzs",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20240717133257-p119nzs",
						"updated": "20240717133441"
					},
					"Children": [
						{
							"ID": "20240717133257-j0saho6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133257-j0saho6",
								"updated": "20240717133441"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请简要说明 .NET 跨语言原理"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133257-0gondmj",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20240717133257-0gondmj",
						"updated": "20240717133454"
					},
					"Children": [
						{
							"ID": "20240717133257-8id72gv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133257-8id72gv",
								"updated": "20240717133451"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请简要说明 .NET 跨平台原理"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240717133257-93simjj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240717133257-93simjj",
				"updated": "20240717133257"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Unity"
				}
			]
		},
		{
			"ID": "20240717133257-k06x5ev",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240717133257-k06x5ev",
				"updated": "20240717133811"
			},
			"Children": [
				{
					"ID": "20240717133257-0qmypq8",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240717133257-0qmypq8",
						"updated": "20240717133257"
					},
					"Children": [
						{
							"ID": "20240717133257-7ixo1pf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133257-7ixo1pf",
								"updated": "20240717133505"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity中的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Destroy"
								},
								{
									"Type": "NodeText",
									"Data": "​ 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "DestroyImmediate"
								},
								{
									"Type": "NodeText",
									"Data": "​ 的区别是什么？"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133257-1m9rqaq",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240717133257-1m9rqaq",
						"updated": "20240717133723"
					},
					"Children": [
						{
							"ID": "20240717133257-s9mpcjq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133257-s9mpcjq",
								"updated": "20240717133514"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请问最终打印的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "s"
								},
								{
									"Type": "NodeText",
									"Data": "​ 的结果为？"
								}
							]
						},
						{
							"ID": "20240717133516-38tu64a",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240717133516-38tu64a",
								"style": "line-height: 22px;",
								"updated": "20240717133723"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "string s = string.Empty;\nGameObject go = new GameObject();\nDestroyImmediate(go)\nif (!go)\n    s += \"A\";\nif (go is null)\n    s += \"B\"\nif (go == null)\n    s += \"C\"\nif ((System.Object)go == null)\n    s += \"D\"\nDebug.Log(s);\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133257-jelcwv7",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20240717133257-jelcwv7",
						"updated": "20240717133756"
					},
					"Children": [
						{
							"ID": "20240717133257-ouhrjjo",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133257-ouhrjjo",
								"updated": "20240717133756"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第一次执行 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "GameObject.Instantiate"
								},
								{
									"Type": "NodeText",
									"Data": "​ 时可能出现明显的卡顿 如何解决该问题？"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133257-ojv3mgt",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20240717133257-ojv3mgt",
						"updated": "20240717133806"
					},
					"Children": [
						{
							"ID": "20240717133257-enk14pn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133257-enk14pn",
								"updated": "20240717133806"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Lua如何实现面向对象的三大特性？"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133257-ixp7lf3",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20240717133257-ixp7lf3",
						"updated": "20240717133811"
					},
					"Children": [
						{
							"ID": "20240717133257-qz4fn6u",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133257-qz4fn6u",
								"updated": "20240717133811"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240717133257-6vhq3z7",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20240717133257-6vhq3z7",
				"updated": "20240717134911"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "答案"
				}
			]
		},
		{
			"ID": "20240717133846-2d4fjqv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240717133846-2d4fjqv",
				"updated": "20240717133846"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "C#"
				}
			]
		},
		{
			"ID": "20240717133846-qly02zy",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240717133846-qly02zy",
				"updated": "20240717134237"
			},
			"Children": [
				{
					"ID": "20240717133846-x5hvpl8",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240717133846-x5hvpl8",
						"updated": "20240717133846"
					},
					"Children": [
						{
							"ID": "20240717133846-guxih7b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133846-guxih7b",
								"updated": "20240717133846"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请说明字符串中 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "string str = null"
								},
								{
									"Type": "NodeText",
									"Data": "​、"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "string str = \u0026quot;\u0026quot;"
								},
								{
									"Type": "NodeText",
									"Data": "​、"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "string str = string.Empty"
								},
								{
									"Type": "NodeText",
									"Data": "​ 三者的区别"
								}
							]
						},
						{
							"ID": "20240717133851-c1ptf1v",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133851-c1ptf1v",
								"updated": "20240717133858"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "答案："
								}
							]
						},
						{
							"ID": "20240717133858-dujfys7",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20240717133858-dujfys7",
								"updated": "20240717133858"
							},
							"Children": [
								{
									"ID": "20240717133858-5tn7kq1",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240717133858-5tn7kq1",
										"updated": "20240717133858"
									},
									"Children": [
										{
											"ID": "20240717133858-d7j0fxk",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717133858-d7j0fxk",
												"updated": "20240717133914"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "str = null"
												},
												{
													"Type": "NodeText",
													"Data": "​ 在堆中没有分配内存地址\n"
												}
											]
										}
									]
								},
								{
									"ID": "20240717133858-ri68ow3",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240717133858-ri68ow3"
									},
									"Children": [
										{
											"ID": "20240717133858-2j9ch08",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717133858-2j9ch08",
												"updated": "20240717133911"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "str = \u0026quot;\u0026quot;"
												},
												{
													"Type": "NodeText",
													"Data": "​ 和 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "string.Empty"
												},
												{
													"Type": "NodeText",
													"Data": "​ 一样都是在堆内存中分配了空间，里面存储的是空字符串，而 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "string.Empty"
												},
												{
													"Type": "NodeText",
													"Data": "​ 是一个静态只读变量"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20240717133846-hnux9lz",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240717133846-hnux9lz",
						"updated": "20240717133846"
					},
					"Children": [
						{
							"ID": "20240717133846-gkd4y13",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133846-gkd4y13",
								"updated": "20240717133846"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C"
								},
								{
									"Type": "NodeBackslash",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeText",
											"Data": "#"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 重载运算符，重载 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "=="
								},
								{
									"Type": "NodeText",
									"Data": "​ 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "!="
								},
								{
									"Type": "NodeText",
									"Data": "​ 以及 万物之父 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "object"
								},
								{
									"Type": "NodeText",
									"Data": "​ 基类中的虚方法 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "virtual bool Equals(Object obj)"
								},
								{
									"Type": "NodeText",
									"Data": "​ 对于我们的意义是什么？"
								}
							]
						},
						{
							"ID": "20240717133924-l2wx01d",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133924-l2wx01d",
								"updated": "20240717133936"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "答案：\n"
								}
							]
						},
						{
							"ID": "20240717133937-fpyhcqy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133937-fpyhcqy",
								"updated": "20240717134008"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "为了判断两个对象的非引用地址相等，我们可以选择 使用 重载运算符 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "=="
								},
								{
									"Type": "NodeText",
									"Data": "​ 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "!="
								},
								{
									"Type": "NodeText",
									"Data": "​ 或者重写 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Equals"
								},
								{
									"Type": "NodeText",
									"Data": "​ 方法，来自定义判断两个对象是否相等\n如果想保留原有的引用地址相等判断，那么一般我们选择重写 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Equals"
								},
								{
									"Type": "NodeText",
									"Data": "​ 方法"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133846-d4ewiwq",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20240717133846-d4ewiwq",
						"updated": "20240717133846"
					},
					"Children": [
						{
							"ID": "20240717133846-xsps324",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133846-xsps324",
								"updated": "20240717133846"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在开发时，对 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "string"
								},
								{
									"Type": "NodeText",
									"Data": "​ 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "StringBuilder"
								},
								{
									"Type": "NodeText",
									"Data": "​ 我们应该如何选择"
								}
							]
						},
						{
							"ID": "20240717134029-pxi5xbp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134029-pxi5xbp",
								"updated": "20240717134035"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "答案：\n"
								}
							]
						},
						{
							"ID": "20240717134037-lkvl6ga",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134037-lkvl6ga",
								"updated": "20240717134049"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "string"
								},
								{
									"Type": "NodeText",
									"Data": "​ 在每次拼接时都会产生垃圾，而 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "StringBuilder"
								},
								{
									"Type": "NodeText",
									"Data": "​ 在拼接时，是在原空间中进行修改，不会产生垃圾，会自动帮助我们扩容\n所以当字符串需要频繁修改拼接时，我们使用 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "StringBuilder"
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133846-knegoo5",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20240717133846-knegoo5",
						"updated": "20240717133846"
					},
					"Children": [
						{
							"ID": "20240717133846-xm25f78",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133846-xm25f78",
								"updated": "20240717133846"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请简要说明 .NET 跨语言原理"
								}
							]
						},
						{
							"ID": "20240717134050-dl2mlhu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134050-dl2mlhu",
								"updated": "20240717134118"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "答案：\n"
								}
							]
						},
						{
							"ID": "20240717134119-jl157vp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134119-jl157vp",
								"updated": "20240717134154"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": ".NET 制定了 CLI 公共语言基础结构的规则，只要是按照该规则设计的语言在进行 .NET 相关开发时\n编译器会将源代码（C#、VB等等）编译为CIL通用中间代码。也就是说不管什么语言进行开发，最终都会统一规范变为中间代码\n最终通过CLR（公共语言运行时或者称为 .NET 虚拟机）将中间代码翻译为对应操作系统的原生代码（机器码）在操作系统（Windows）上运行"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133846-1rm36dr",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20240717133846-1rm36dr",
						"updated": "20240717134237"
					},
					"Children": [
						{
							"ID": "20240717133846-upt8th7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133846-upt8th7",
								"updated": "20240717133846"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请简要说明 .NET 跨平台原理"
								}
							]
						},
						{
							"ID": "20240717134157-nno1ubu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134157-nno1ubu",
								"updated": "20240717134203"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "答案：\n"
								}
							]
						},
						{
							"ID": "20240717134205-hbkoqix",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134205-hbkoqix",
								"updated": "20240717134237"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "由于 .NET Framework 中利用 CLI 和 CLR 实现了跨语言，CLR主要起到一个翻译、运行、管理中间代码的作用\n.NET Core 和 Mono 就是利用了 CLR 的这一特点，为不同操作系统实现对应 CLR（公共语言运行时或.NET虚拟机）\n那么不同操作系统对应的CLR就会将IL中间代码翻译为对应系统可以执行的原生代码（机器码）达到跨平台的目的"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240717133846-kcvgsuj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240717133846-kcvgsuj",
				"updated": "20240717133846"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Unity"
				}
			]
		},
		{
			"ID": "20240717133846-i95fnze",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20240717133846-i95fnze",
				"updated": "20240717134903"
			},
			"Children": [
				{
					"ID": "20240717133846-y1rk6ws",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20240717133846-y1rk6ws",
						"updated": "20240717133846"
					},
					"Children": [
						{
							"ID": "20240717133846-6js99da",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133846-6js99da",
								"updated": "20240717133846"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity中的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Destroy"
								},
								{
									"Type": "NodeText",
									"Data": "​ 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "DestroyImmediate"
								},
								{
									"Type": "NodeText",
									"Data": "​ 的区别是什么？"
								}
							]
						},
						{
							"ID": "20240717134248-gn9jcap",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134248-gn9jcap",
								"updated": "20240717134249"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "答案：\n"
								}
							]
						},
						{
							"ID": "20240717134252-is19c5h",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20240717134252-is19c5h",
								"updated": "20240717134253"
							},
							"Children": [
								{
									"ID": "20240717134253-6th0jti",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240717134253-6th0jti",
										"updated": "20240717134253"
									},
									"Children": [
										{
											"ID": "20240717134253-xq78hc0",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134253-xq78hc0",
												"updated": "20240717134308"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Destroy"
												},
												{
													"Type": "NodeText",
													"Data": "​ 方法\n可以指定删除的延迟时间，如果第二个参数不填写，最快也会在下一帧前完成删除。\n也就是如果 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Destroy"
												},
												{
													"Type": "NodeText",
													"Data": "​ 对象后马上判空，该对象不会为空。\n实际的对象销毁操作始终延迟到当前更新循环结束，但始终在渲染前完成"
												}
											]
										}
									]
								},
								{
									"ID": "20240717134255-v22714l",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240717134255-v22714l"
									},
									"Children": [
										{
											"ID": "20240717134255-k6e5kc0",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134255-k6e5kc0",
												"updated": "20240717134311"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "DestroyImmediate"
												},
												{
													"Type": "NodeText",
													"Data": "​ 方法，会立即销毁删除对象"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20240717133846-2v69rkl",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20240717133846-2v69rkl",
						"updated": "20240717133846"
					},
					"Children": [
						{
							"ID": "20240717133846-rgxulyy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133846-rgxulyy",
								"updated": "20240717133846"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请问最终打印的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "s"
								},
								{
									"Type": "NodeText",
									"Data": "​ 的结果为？"
								}
							]
						},
						{
							"ID": "20240717133846-je0t0rs",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20240717133846-je0t0rs",
								"style": "line-height: 22px;",
								"updated": "20240717133846"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "YyM="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "string s = string.Empty;\nGameObject go = new GameObject();\nDestroyImmediate(go)\nif (!go)\n    s += \"A\";\nif (go is null)\n    s += \"B\"\nif (go == null)\n    s += \"C\"\nif ((System.Object)go == null)\n    s += \"D\"\nDebug.Log(s);\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						},
						{
							"ID": "20240717134346-dylw8x6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134346-dylw8x6",
								"updated": "20240717134349"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "答案：AC\n"
								}
							]
						},
						{
							"ID": "20240717134351-x8yy2xa",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134351-x8yy2xa",
								"updated": "20240717134400"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "主要考点"
								}
							]
						},
						{
							"ID": "20240717134400-kxzzgib",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20240717134400-kxzzgib",
								"updated": "20240717134400"
							},
							"Children": [
								{
									"ID": "20240717134400-30kfrle",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20240717134400-30kfrle",
										"updated": "20240717134400"
									},
									"Children": [
										{
											"ID": "20240717134400-09apwdj",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134400-09apwdj",
												"updated": "20240717134406"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "DestroyImmediate"
												},
												{
													"Type": "NodeText",
													"Data": "​ 方法会立即将 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "GameObject"
												},
												{
													"Type": "NodeText",
													"Data": "​ 对象从场景上删除"
												}
											]
										}
									]
								},
								{
									"ID": "20240717134400-h9pt18h",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20240717134400-h9pt18h",
										"updated": "20240717134400"
									},
									"Children": [
										{
											"ID": "20240717134400-8bizsab",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134400-8bizsab",
												"updated": "20240717134501"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "​"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "UnityEngine.Object"
												},
												{
													"Type": "NodeText",
													"Data": "​ 中对 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "=="
												},
												{
													"Type": "NodeText",
													"Data": "​、"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "!="
												},
												{
													"Type": "NodeText",
													"Data": "​、"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "!"
												},
												{
													"Type": "NodeText",
													"Data": "​ 进行了重载，如果用 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "!go"
												},
												{
													"Type": "NodeText",
													"Data": "​ 和 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "go == null"
												},
												{
													"Type": "NodeText",
													"Data": "​ 去判断对象是否为空，\n由于重载了，所以能够返回正确的结果 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "true"
												},
												{
													"Type": "NodeText",
													"Data": "​ 和 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "false"
												},
												{
													"Type": "NodeText",
													"Data": "​"
												}
											]
										},
										{
											"ID": "20240717134451-xsbqhi0",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134451-xsbqhi0",
												"updated": "20240717134547"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "但是本质上此时的 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "go"
												},
												{
													"Type": "NodeText",
													"Data": "​ 还不是真正意义上的 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "null"
												},
												{
													"Type": "NodeText",
													"Data": "​，所以如果用 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "go is null"
												},
												{
													"Type": "NodeText",
													"Data": "​\n或者 将其转换为 万物之父 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "object"
												},
												{
													"Type": "NodeText",
													"Data": "​，"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "(System.Object)go == null"
												},
												{
													"Type": "NodeText",
													"Data": "​ 去判断时 并不会为true\n因此只会进入 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "AC"
												},
												{
													"Type": "NodeText",
													"Data": "​ 的 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "if"
												},
												{
													"Type": "NodeText",
													"Data": "​ 语句"
												}
											]
										}
									]
								}
							]
						},
						{
							"ID": "20240717134537-jrfdqy8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134537-jrfdqy8",
								"updated": "20240717134617"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "这里的重点内容就是 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UnityEngine.Object"
								},
								{
									"Type": "NodeText",
									"Data": "​ 中重载了 逻辑非 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "!"
								},
								{
									"Type": "NodeText",
									"Data": "​ 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "=="
								},
								{
									"Type": "NodeText",
									"Data": "​、"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "!="
								},
								{
									"Type": "NodeText",
									"Data": "​ 运算符，因为使用他们来判断 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "null"
								},
								{
									"Type": "NodeText",
									"Data": "​ 是可以的，\n但是此时的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "GameObject"
								},
								{
									"Type": "NodeText",
									"Data": "​ 在内部并不是真正意义的"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "null"
								},
								{
									"Type": "NodeText",
									"Data": "​，我们在使用时最好手动置空"
								}
							]
						}
					]
				},
				{
					"ID": "20240717133846-nockyy8",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20240717133846-nockyy8",
						"updated": "20240717133846"
					},
					"Children": [
						{
							"ID": "20240717133846-l5c9rmh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133846-l5c9rmh",
								"updated": "20240717133846"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第一次执行 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "GameObject.Instantiate"
								},
								{
									"Type": "NodeText",
									"Data": "​ 时可能出现明显的卡顿 如何解决该问题？"
								}
							]
						},
						{
							"ID": "20240717134648-pim1cas",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134648-pim1cas",
								"updated": "20240717134649"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "答案：\n"
								}
							]
						},
						{
							"ID": "20240717134651-ul2s9da",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134651-ul2s9da",
								"updated": "20240717134702"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "我们可以通过Unity自带的性能分析工具Profiler分析实例化时造成卡顿的原因"
								}
							]
						},
						{
							"ID": "20240717134702-ud7ivkm",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20240717134702-ud7ivkm",
								"updated": "20240717134702"
							},
							"Children": [
								{
									"ID": "20240717134702-v44tkjy",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240717134702-v44tkjy",
										"updated": "20240717134702"
									},
									"Children": [
										{
											"ID": "20240717134702-3e0jz7i",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134702-3e0jz7i",
												"updated": "20240717134702"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "程序上，一般我们可以从以下3个方面去优化它\n"
												}
											]
										},
										{
											"ID": "20240717134705-y1ujt5l",
											"Type": "NodeList",
											"ListData": {
												"Typ": 1
											},
											"Properties": {
												"id": "20240717134705-y1ujt5l",
												"updated": "20240717134710"
											},
											"Children": [
												{
													"ID": "20240717134710-7mtqemt",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "MS4=",
														"Num": 1
													},
													"Properties": {
														"id": "20240717134710-7mtqemt",
														"updated": "20240717134710"
													},
													"Children": [
														{
															"ID": "20240717134710-w3krqva",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20240717134710-w3krqva",
																"updated": "20240717134710"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "相关资源加载：如果是由于资源加载带来的卡顿，我们可以在进入场景时进行资源预加载，总体思路就是将较大资源提前或者分帧加载"
																}
															]
														}
													]
												},
												{
													"ID": "20240717134710-vh9gouc",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "Mi4=",
														"Num": 2
													},
													"Properties": {
														"id": "20240717134710-vh9gouc",
														"updated": "20240717134710"
													},
													"Children": [
														{
															"ID": "20240717134710-5khepwf",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20240717134710-5khepwf",
																"updated": "20240717134724"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "脚本初始化：实例化对象时，会同步执行它身上挂载所有脚本的初始化工作，\n我们可以策略性的改变一些初始化逻辑，尽量不要在 "
																},
																{
																	"Type": "NodeTextMark",
																	"TextMarkType": "code",
																	"TextMarkTextContent": "Awake"
																},
																{
																	"Type": "NodeText",
																	"Data": "​ 和 "
																},
																{
																	"Type": "NodeTextMark",
																	"TextMarkType": "code",
																	"TextMarkTextContent": "Start"
																},
																{
																	"Type": "NodeText",
																	"Data": "​ 中做较复杂的逻辑，或者将复杂逻辑提前或者分帧处理"
																}
															]
														}
													]
												},
												{
													"ID": "20240717134710-4ixx56y",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "My4=",
														"Num": 3
													},
													"Properties": {
														"id": "20240717134710-4ixx56y",
														"updated": "20240717134710"
													},
													"Children": [
														{
															"ID": "20240717134710-22h0rri",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20240717134710-22h0rri",
																"updated": "20240717134710"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "对于会频繁使用的对象，我们可以使用缓存池"
																}
															]
														}
													]
												}
											]
										}
									]
								},
								{
									"ID": "20240717134703-qrsda1z",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240717134703-qrsda1z"
									},
									"Children": [
										{
											"ID": "20240717134703-lxsemka",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134703-lxsemka"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "美术上\n"
												}
											]
										},
										{
											"ID": "20240717134732-czcqepa",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134732-czcqepa"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "不能只追求好的美术效果，而不考虑资源的消耗，要根据项目的实际情况，来设定模型的骨骼数、面数以及贴图的数量和大小上限。\n在制作粒子特效时，粒子数、粒子面积、贴图等都要尽量少和小。\n"
												}
											]
										},
										{
											"ID": "20240717134738-7996pi0",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134738-7996pi0"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "美术上要遵循：用最少的资源做出做好的效果，不能一味的用性能去换效果，最终会得不偿失"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20240717133846-gib3513",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20240717133846-gib3513",
						"updated": "20240717133846"
					},
					"Children": [
						{
							"ID": "20240717133846-rpac5uy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133846-rpac5uy",
								"updated": "20240717134640"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Lua 如何实现面向对象的三大特性？"
								}
							]
						},
						{
							"ID": "20240717134748-ys2mv7v",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134748-ys2mv7v",
								"updated": "20240717134757"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "答案：面向对象三大特性"
								}
							]
						},
						{
							"ID": "20240717134757-7irklid",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20240717134757-7irklid",
								"updated": "20240717134757"
							},
							"Children": [
								{
									"ID": "20240717134757-absklg3",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240717134757-absklg3",
										"updated": "20240717134757"
									},
									"Children": [
										{
											"ID": "20240717134757-r7adlbp",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134757-r7adlbp",
												"updated": "20240717134812"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "封装：利用 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "table"
												},
												{
													"Type": "NodeText",
													"Data": "​ 进行封装"
												}
											]
										}
									]
								},
								{
									"ID": "20240717134758-13ntjc6",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240717134758-13ntjc6"
									},
									"Children": [
										{
											"ID": "20240717134758-ragg8st",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134758-ragg8st",
												"updated": "20240717134833"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "继承：利用元表和 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "__index"
												},
												{
													"Type": "NodeText",
													"Data": "​ 模拟继承关系，设置子类的元表为父类，父类的 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "__index"
												},
												{
													"Type": "NodeText",
													"Data": "​ 为父类自己\n当子类身上找不到对应属性和方法时\n会查找元表的 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "__index"
												},
												{
													"Type": "NodeText",
													"Data": "​ 中的内容，也就是会查找父类中的内容，通过这种方式来模拟继承"
												}
											]
										}
									]
								},
								{
									"ID": "20240717134759-ib9aoh0",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20240717134759-ib9aoh0"
									},
									"Children": [
										{
											"ID": "20240717134759-ue9c0c3",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134759-ue9c0c3",
												"updated": "20240717134808"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "多态：子类自己去实现带"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": ":"
												},
												{
													"Type": "NodeText",
													"Data": "​的同名方法即可"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20240717133846-eqpdzsn",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20240717133846-eqpdzsn",
						"updated": "20240717134903"
					},
					"Children": [
						{
							"ID": "20240717133846-fz0nvd8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717133846-fz0nvd8",
								"updated": "20240717133846"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）"
								}
							]
						},
						{
							"ID": "20240717134847-8tpwptq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134847-8tpwptq",
								"updated": "20240717134853"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "答案："
								}
							]
						},
						{
							"ID": "20240717134856-0a3cb6j",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134856-0a3cb6j",
								"updated": "20240717134903"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用IL2CPP打包时，最可能出现的问题就是代码裁剪，IL2CPP会自动将它认为不会使用的代码裁剪掉，\n比如我们在使用Lua开发时，其实会用到很多UnityEngine或者我们自己写的C#代码，但是这些代码并不会在引擎中直接使用，\n都是在Lua中使用的，此时最容易出现的问题就是代码裁剪，导致打包后出现异常和报错。"
								}
							]
						},
						{
							"ID": "20240717134854-ibc3s9g",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20240717134854-ibc3s9g",
								"updated": "20240717134854"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "要避免IL2CPP的裁剪有3种方式，我们可以组合使用"
								}
							]
						},
						{
							"ID": "20240717134853-y4j0ygg",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20240717134853-y4j0ygg",
								"updated": "20240717134853"
							},
							"Children": [
								{
									"ID": "20240717134853-ty29jkw",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20240717134853-ty29jkw",
										"updated": "20240717134853"
									},
									"Children": [
										{
											"ID": "20240717134853-wic0fy7",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134853-wic0fy7",
												"updated": "20240717134853"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "设置打包时的裁剪等级"
												}
											]
										}
									]
								},
								{
									"ID": "20240717134853-rewqshy",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20240717134853-rewqshy",
										"updated": "20240717134853"
									},
									"Children": [
										{
											"ID": "20240717134853-8ahduod",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134853-8ahduod",
												"updated": "20240717134853"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "通过xml文件配置明确规定哪些内容不裁剪"
												}
											]
										}
									]
								},
								{
									"ID": "20240717134853-sbzmxg0",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "My4=",
										"Num": 3
									},
									"Properties": {
										"id": "20240717134853-sbzmxg0",
										"updated": "20240717134853"
									},
									"Children": [
										{
											"ID": "20240717134853-05o5byd",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20240717134853-05o5byd",
												"updated": "20240717134853"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "在静态方法中显示调用不想被裁剪的内容"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20240717134911-fmm7crh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20240717134911-fmm7crh"
			}
		}
	]
}