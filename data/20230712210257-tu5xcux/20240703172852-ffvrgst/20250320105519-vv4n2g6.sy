{
	"ID": "20250320105519-vv4n2g6",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20250320105519-vv4n2g6",
		"title": "MIL20——模拟面试题",
		"type": "doc",
		"updated": "20250327200739"
	},
	"Children": [
		{
			"ID": "20250327200739-awo0k4m",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250327200739-awo0k4m",
				"updated": "20250327200739"
			},
			"Children": [
				{
					"ID": "20250327200739-3ut9y7o",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250327200739-3ut9y7o",
						"updated": "20250327200739"
					},
					"Children": [
						{
							"ID": "20250327200739-bvo7quu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250327200739-bvo7quu",
								"updated": "20250327200739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 类中的函数是否占用内存空间？"
								}
							]
						}
					]
				},
				{
					"ID": "20250327200739-62zjdxs",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250327200739-62zjdxs",
						"updated": "20250327200739"
					},
					"Children": [
						{
							"ID": "20250327200739-az9d3z7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250327200739-az9d3z7",
								"updated": "20250327200739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 中的函数是何时被加载到内存中的呢？"
								}
							]
						}
					]
				},
				{
					"ID": "20250327200739-sm9qmii",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250327200739-sm9qmii",
						"updated": "20250327200739"
					},
					"Children": [
						{
							"ID": "20250327200739-ce27o2a",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250327200739-ce27o2a",
								"updated": "20250327200739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 函数中一般会声明一些临时变量，当函数被加载内存中后，所占的内存空间是否包含函数中的这些临时变量？"
								}
							]
						}
					]
				},
				{
					"ID": "20250327200739-33ilnz9",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250327200739-33ilnz9",
						"updated": "20250327200739"
					},
					"Children": [
						{
							"ID": "20250327200739-1zpbz72",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250327200739-1zpbz72",
								"updated": "20250327200739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 中委托的本质是什么？它是如何存储函数的？"
								}
							]
						}
					]
				},
				{
					"ID": "20250327200739-smu65yp",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250327200739-smu65yp",
						"updated": "20250327200739"
					},
					"Children": [
						{
							"ID": "20250327200739-pk4zcxr",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250327200739-pk4zcxr",
								"updated": "20250327200739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 中事件的本质是什么？"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250327200739-bqq2y2m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250327200739-bqq2y2m",
				"updated": "20250327200739"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Unity"
				}
			]
		},
		{
			"ID": "20250327200739-kih8521",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250327200739-kih8521",
				"updated": "20250327200739"
			},
			"Children": [
				{
					"ID": "20250327200739-fpx53y3",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250327200739-fpx53y3",
						"updated": "20250327200739"
					},
					"Children": [
						{
							"ID": "20250327200739-1bkaaej",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250327200739-1bkaaej",
								"updated": "20250327200739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity 在发布 Android 平台项目时，在加载 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Application.streamingAssetsPath"
								},
								{
									"Type": "NodeText",
									"Data": "​ 中文件时我们应该注意什么？"
								}
							]
						}
					]
				},
				{
					"ID": "20250327200739-q9ke8ih",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250327200739-q9ke8ih",
						"updated": "20250327200739"
					},
					"Children": [
						{
							"ID": "20250327200739-bsts1nx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250327200739-bsts1nx",
								"updated": "20250327200739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity 中安卓主流的纹理压缩格式 ETC 和 ETC2 的主要区别是什么？"
								}
							]
						}
					]
				},
				{
					"ID": "20250327200739-67ow36n",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250327200739-67ow36n",
						"updated": "20250327200739"
					},
					"Children": [
						{
							"ID": "20250327200739-fztdrdd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250327200739-fztdrdd",
								"updated": "20250327200739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Android 平台常用压缩格式 ETC 不支持透明通道，那我们的半透明纹理应该如何处理？"
								}
							]
						}
					]
				},
				{
					"ID": "20250327200739-fzi0zqb",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250327200739-fzi0zqb",
						"updated": "20250327200739"
					},
					"Children": [
						{
							"ID": "20250327200739-0sfanix",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250327200739-0sfanix",
								"updated": "20250327200739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity 中针对 IOS 平台我们使用的主流纹理压缩格式是什么？"
								}
							]
						}
					]
				},
				{
					"ID": "20250327200739-8f9naxi",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250327200739-8f9naxi",
						"updated": "20250327200739"
					},
					"Children": [
						{
							"ID": "20250327200739-u2ftgfe",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250327200739-u2ftgfe",
								"updated": "20250327200739"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请问为什么延迟渲染路径能够优化有大量光源的场景渲染"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250327200727-euoave2",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20250327200727-euoave2",
				"updated": "20250327200730"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "答案"
				}
			]
		},
		{
			"ID": "20250320105524-lw9au8g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250320105524-lw9au8g",
				"updated": "20250320105524"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "C#"
				}
			]
		},
		{
			"ID": "20250320105524-3qlk8ri",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250320105524-3qlk8ri",
				"updated": "20250320113301"
			},
			"Children": [
				{
					"ID": "20250320105524-opkgh99",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"fold": "1",
						"id": "20250320105524-opkgh99",
						"updated": "20250320105524"
					},
					"Children": [
						{
							"ID": "20250320105524-vf2tojm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320105524-vf2tojm",
								"updated": "20250320105524"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 类中的函数是否占用内存空间？"
								}
							]
						},
						{
							"ID": "20250320111727-gt82vfn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320111727-gt82vfn",
								"updated": "20250320111736"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "占用，但是它不再我们通常说的堆栈中，而是存储在内存中的文本段（Text Segment），它是存储可执行程序的代码的内存段"
								}
							]
						}
					]
				},
				{
					"ID": "20250320105524-6niy6oc",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"fold": "1",
						"id": "20250320105524-6niy6oc",
						"updated": "20250320105524"
					},
					"Children": [
						{
							"ID": "20250320105524-mfucinh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320105524-mfucinh",
								"updated": "20250320105524"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 中的函数是何时被加载到内存中的呢？"
								}
							]
						},
						{
							"ID": "20250320111802-dgx3orr",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320111802-dgx3orr",
								"updated": "20250320111818"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "CLR（公共语言运行时）会按需加载程序集和其中的类型和成员，程序执行到需要调用某个类的函数时，\nCLR 会负责将该函数的 IL 代码编译成本机代码，并将其加载到 Text Segment 中，\n一旦函数的代码被加载到内存中，它通常会一直存在于内存中，直到程序退出"
								}
							]
						},
						{
							"ID": "20250320111830-4vqwlk6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320111830-4vqwlk6",
								"updated": "20250320111831"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "运行可执行文件后的流程："
								}
							]
						},
						{
							"ID": "20250320111945-kfgbmsu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320111945-kfgbmsu",
								"updated": "20250320111945"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeImage",
									"Data": "span",
									"Properties": {
										"style": "width: 677px;"
									},
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText",
											"Data": "image"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "assets/image-20250320111945-iz3ejbh.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeKramdownSpanIAL",
									"Data": "{: style=\"width: 677px;\"}"
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						}
					]
				},
				{
					"ID": "20250320105524-2c0lw0j",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"fold": "1",
						"id": "20250320105524-2c0lw0j",
						"updated": "20250320105524"
					},
					"Children": [
						{
							"ID": "20250320105524-c726k6k",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320105524-c726k6k",
								"updated": "20250320105524"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 函数中一般会声明一些临时变量，当函数被加载内存中后，所占的内存空间是否包含函数中的这些临时变量？"
								}
							]
						},
						{
							"ID": "20250320112018-gbylqbu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320112018-gbylqbu",
								"updated": "20250320112040"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "不会包含。函数中的临时变量，不管是值类型还是引用类型都是在函数执行期间动态分配的。\n这些临时变量会在堆栈中进行内存分配，栈上的内存由 CLR 动态管理，用完会被销毁，堆上的内存有 GC 垃圾回收机制统一进行管理"
								}
							]
						}
					]
				},
				{
					"ID": "20250320105524-o9vqixx",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"fold": "1",
						"id": "20250320105524-o9vqixx",
						"updated": "20250320105524"
					},
					"Children": [
						{
							"ID": "20250320105524-kf3oxwg",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320105524-kf3oxwg",
								"updated": "20250320105524"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 中委托的本质是什么？它是如何存储函数的？"
								}
							]
						},
						{
							"ID": "20250320112149-d6gk086",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320112149-d6gk086",
								"updated": "20250320112239"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "委托的本质是一个类，当我们声明一个委托时，相当于声明了一个类。\n它会默认继承 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "System.MulticastDelegate"
								},
								{
									"Type": "NodeText",
									"Data": "​ 类（多播委托类） 而这个 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "System.MulticastDelegate"
								},
								{
									"Type": "NodeText",
									"Data": "​ 类，又继承 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Delegate"
								},
								{
									"Type": "NodeText",
									"Data": "​ 类（委托类）\n这些父类当中的一些方法，就是当我们对委托进行操作时真正会调用的内容，"
								}
							]
						},
						{
							"ID": "20250320112511-or6mfw7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320112511-or6mfw7",
								"updated": "20250320112511"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeImage",
									"Data": "span",
									"Properties": {
										"style": "width: 663px;"
									},
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText",
											"Data": "image"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "assets/image-20250320112511-pqsoupv.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeKramdownSpanIAL",
									"Data": "{: style=\"width: 663px;\"}"
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						},
						{
							"ID": "20250320112551-kfi4s8t",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320112551-kfi4s8t",
								"updated": "20250320112551"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeImage",
									"Data": "span",
									"Properties": {
										"style": "width: 941px;"
									},
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText",
											"Data": "image"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "assets/image-20250320112551-26jh4er.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeKramdownSpanIAL",
									"Data": "{: style=\"width: 941px;\"}"
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						},
						{
							"ID": "20250320112244-51l0xqs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320112244-51l0xqs",
								"updated": "20250320112300"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "通过这些父类中的方法我们其实可以简单推测出，委托中存储函数的本质：\n是通过一个委托类对象来存储对象的引用或者静态类的类型，然后再记录一个函数的名字。\n但是实际上，在内部会根据这些信息定位到："
								}
							]
						},
						{
							"ID": "20250320112300-gr9uphc",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250320112300-gr9uphc",
								"updated": "20250320112300"
							},
							"Children": [
								{
									"ID": "20250320112300-anvrupu",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250320112300-anvrupu",
										"updated": "20250320112300"
									},
									"Children": [
										{
											"ID": "20250320112300-chnei7u",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250320112300-chnei7u",
												"updated": "20250320112300"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "函数的引用（函数的内存地址） "
												}
											]
										}
									]
								},
								{
									"ID": "20250320112302-59t0fmw",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250320112302-59t0fmw",
										"updated": "20250320112302"
									},
									"Children": [
										{
											"ID": "20250320112302-ftl7izo",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250320112302-ftl7izo",
												"updated": "20250320112332"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "函数所在对象的引用（如果是实例方法），而当我们进行 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "+="
												},
												{
													"Type": "NodeText",
													"Data": "​ 操作时，其实 C"
												},
												{
													"Type": "NodeBackslash",
													"Data": "span",
													"Children": [
														{
															"Type": "NodeText",
															"Data": "#"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": " 内部会调用父类中的 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "Combine"
												},
												{
													"Type": "NodeText",
													"Data": "​ 结合方法，\n在底层帮助我们声明一个新的委托对象来记录对应函数的相关信息"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20250320105524-j8n7xkk",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"fold": "1",
						"id": "20250320105524-j8n7xkk",
						"updated": "20250320113301"
					},
					"Children": [
						{
							"ID": "20250320105524-ul3ppas",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320105524-ul3ppas",
								"updated": "20250320105524"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C# 中事件的本质是什么？"
								}
							]
						},
						{
							"ID": "20250320113226-67c097h",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320113226-67c097h",
								"updated": "20250320113256"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "通过对委托的理解，来帮助我们理解事件将会变得比较容易，\n我们在使用事件的时候往往是在类中声明成员变量时，当我们声明一个事件时，本质就是对委托进行私有访问限制的封装\n事件的本质其实就是委托 ，只不过系统会对 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "event"
								},
								{
									"Type": "NodeText",
									"Data": "​ 字段修饰的委托在编译时进行一些特殊处理，这些特殊处理包括："
								}
							]
						},
						{
							"ID": "20250320113259-8vk4hri",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250320113259-8vk4hri",
								"updated": "20250320113301"
							},
							"Children": [
								{
									"ID": "20250320113301-3awuibh",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250320113301-3awuibh",
										"updated": "20250320113301"
									},
									"Children": [
										{
											"ID": "20250320113301-000wbwz",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250320113301-000wbwz",
												"updated": "20250320113301"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "生成一个私有的委托变量"
												}
											]
										}
									]
								},
								{
									"ID": "20250320113304-6xitwcg",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250320113304-6xitwcg",
										"updated": "20250320113304"
									},
									"Children": [
										{
											"ID": "20250320113304-4lu33e0",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250320113304-4lu33e0",
												"updated": "20250320113314"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "添加两个事件访问器（用于在外部 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "+="
												},
												{
													"Type": "NodeText",
													"Data": "​ 和 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "-="
												},
												{
													"Type": "NodeText",
													"Data": "​）"
												}
											]
										}
									]
								},
								{
									"ID": "20250320113315-5ggsns6",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "My4=",
										"Num": 3
									},
									"Properties": {
										"id": "20250320113315-5ggsns6",
										"updated": "20250320113315"
									},
									"Children": [
										{
											"ID": "20250320113315-dlxtefo",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250320113315-dlxtefo",
												"updated": "20250320113315"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "禁止外部类对事件进行一些操作"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250320105524-uekk93w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250320105524-uekk93w",
				"updated": "20250320105524"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Unity"
				}
			]
		},
		{
			"ID": "20250320105524-3v09wfr",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250320105524-3v09wfr",
				"updated": "20250320114543"
			},
			"Children": [
				{
					"ID": "20250320105524-uxter67",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250320105524-uxter67",
						"updated": "20250320105524"
					},
					"Children": [
						{
							"ID": "20250320105524-6l4ezt6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320105524-6l4ezt6",
								"updated": "20250320105524"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity 在发布 Android 平台项目时，在加载 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Application.streamingAssetsPath"
								},
								{
									"Type": "NodeText",
									"Data": "​ 中文件时我们应该注意什么？"
								}
							]
						},
						{
							"ID": "20250320114111-pgboygh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320114111-pgboygh",
								"updated": "20250320114131"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "无法使用 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "File"
								},
								{
									"Type": "NodeText",
									"Data": "​ 中相关 API 进行加载，只能使用 Unity 中 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "WWW"
								},
								{
									"Type": "NodeText",
									"Data": "​、"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UnityWebRequest"
								},
								{
									"Type": "NodeText",
									"Data": "​、"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "AssetBundle"
								},
								{
									"Type": "NodeText",
									"Data": "​ 相关 API 进行加载"
								}
							]
						}
					]
				},
				{
					"ID": "20250320105524-816jlbk",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250320105524-816jlbk",
						"updated": "20250320105524"
					},
					"Children": [
						{
							"ID": "20250320105524-1v8w3sf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320105524-1v8w3sf",
								"updated": "20250320105524"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity 中安卓主流的纹理压缩格式 ETC 和 ETC2 的主要区别是什么？"
								}
							]
						},
						{
							"ID": "20250320114141-25eak7t",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250320114141-25eak7t",
								"updated": "20250320114148"
							},
							"Children": [
								{
									"ID": "20250320114148-rh1odlm",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250320114148-rh1odlm",
										"updated": "20250320114148"
									},
									"Children": [
										{
											"ID": "20250320114148-euzk7lm",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250320114148-euzk7lm",
												"updated": "20250320114209"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "透明通道"
												}
											]
										},
										{
											"ID": "20250320114209-jiodl2g",
											"Type": "NodeList",
											"ListData": {},
											"Properties": {
												"id": "20250320114209-jiodl2g",
												"updated": "20250320114210"
											},
											"Children": [
												{
													"ID": "20250320114210-wc769fq",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250320114210-wc769fq",
														"updated": "20250320114210"
													},
													"Children": [
														{
															"ID": "20250320114210-sjrl02d",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250320114210-sjrl02d",
																"updated": "20250320114213"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "ETC 不支持透明通道"
																}
															]
														}
													]
												},
												{
													"ID": "20250320114213-gyswv2n",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250320114213-gyswv2n",
														"updated": "20250320114213"
													},
													"Children": [
														{
															"ID": "20250320114213-obfq8sv",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250320114213-obfq8sv",
																"updated": "20250320114213"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "ETC2 支持透明通道"
																}
															]
														}
													]
												}
											]
										}
									]
								},
								{
									"ID": "20250320114200-wjr6b3i",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250320114200-wjr6b3i",
										"updated": "20250320114200"
									},
									"Children": [
										{
											"ID": "20250320114200-y4xdkpg",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250320114200-y4xdkpg",
												"updated": "20250320114215"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "压缩效率"
												}
											]
										},
										{
											"ID": "20250320114215-npomhnm",
											"Type": "NodeList",
											"ListData": {},
											"Properties": {
												"id": "20250320114215-npomhnm",
												"updated": "20250320114217"
											},
											"Children": [
												{
													"ID": "20250320114217-ncyalqv",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250320114217-ncyalqv",
														"updated": "20250320114217"
													},
													"Children": [
														{
															"ID": "20250320114217-413fdyj",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250320114217-413fdyj",
																"updated": "20250320114220"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "ETC2 相对 ETC 在相同压缩比下图像质量更好"
																}
															]
														}
													]
												}
											]
										}
									]
								},
								{
									"ID": "20250320114205-a0d8316",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "My4=",
										"Num": 3
									},
									"Properties": {
										"id": "20250320114205-a0d8316",
										"updated": "20250320114205"
									},
									"Children": [
										{
											"ID": "20250320114205-qihx3p3",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250320114205-qihx3p3",
												"updated": "20250320114224"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "支持设备"
												}
											]
										},
										{
											"ID": "20250320114224-0yj8ll7",
											"Type": "NodeList",
											"ListData": {},
											"Properties": {
												"id": "20250320114224-0yj8ll7",
												"updated": "20250320114225"
											},
											"Children": [
												{
													"ID": "20250320114225-3m684r7",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250320114225-3m684r7",
														"updated": "20250320114225"
													},
													"Children": [
														{
															"ID": "20250320114225-edyq5kf",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250320114225-edyq5kf",
																"updated": "20250320114235"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "ETC 基本支持所有 Android 设备，ETC2不支持低端设备"
																}
															]
														}
													]
												}
											]
										}
									]
								}
							]
						},
						{
							"ID": "20250320114236-ome8b85",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320114236-ome8b85",
								"updated": "20250320114303"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "目前 ETC2 在逐渐取代 ETC"
								}
							]
						}
					]
				},
				{
					"ID": "20250320105524-i5rzuw4",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250320105524-i5rzuw4",
						"updated": "20250320105524"
					},
					"Children": [
						{
							"ID": "20250320105524-obdcozt",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320105524-obdcozt",
								"updated": "20250320105524"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Android 平台常用压缩格式 ETC 不支持透明通道，那我们的半透明纹理应该如何处理？"
								}
							]
						},
						{
							"ID": "20250320114305-kaluvkd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320114305-kaluvkd",
								"updated": "20250320114401"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将纹理的透明通道分离，1 张存 RGB，1 张存 A，\n利用自定义 Shader 将其组合使用，ETC 的内存占用相对 RGBA32 会降低为之前的 1/4，效率也会提升\n因此即使分成 2 张图，内存占用也会减少到之前的 1/2"
								}
							]
						}
					]
				},
				{
					"ID": "20250320105524-l75ta3f",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250320105524-l75ta3f",
						"updated": "20250320105524"
					},
					"Children": [
						{
							"ID": "20250320105524-p7sz1c9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320105524-p7sz1c9",
								"updated": "20250320105524"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Unity 中针对 IOS 平台我们使用的主流纹理压缩格式是什么？"
								}
							]
						},
						{
							"ID": "20250320114406-yp8ufsj",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250320114406-yp8ufsj",
								"updated": "20250320114416"
							},
							"Children": [
								{
									"ID": "20250320114416-eumbu0b",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250320114416-eumbu0b",
										"updated": "20250320114416"
									},
									"Children": [
										{
											"ID": "20250320114416-6c87g5l",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250320114416-6c87g5l",
												"updated": "20250320114443"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "PVRTC：最主流最常用，支持所有 IOS 设备"
												}
											]
										}
									]
								},
								{
									"ID": "20250320114418-qr34dyy",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250320114418-qr34dyy",
										"updated": "20250320114418"
									},
									"Children": [
										{
											"ID": "20250320114418-lntra2l",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250320114418-lntra2l",
												"updated": "20250320114455"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "ASTC（如果设备支持，推荐使用）和 ETC2，iPhone 5s 及以上型号的 iPhone 手机，iPad Air 及以上型号的 iPad 平板电脑"
												}
											]
										}
									]
								}
							]
						},
						{
							"ID": "20250320114439-4218fhf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320114439-4218fhf",
								"updated": "20250320114440"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "他们都支持透明通道，因此我们无需进行额外处理"
								}
							]
						}
					]
				},
				{
					"ID": "20250320105524-2bq1k1z",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250320105524-2bq1k1z",
						"updated": "20250320114543"
					},
					"Children": [
						{
							"ID": "20250320105524-vgk8lq2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320105524-vgk8lq2",
								"updated": "20250320105524"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请问为什么延迟渲染路径能够优化有大量光源的场景渲染"
								}
							]
						},
						{
							"ID": "20250320114528-fq06wjc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250320114528-fq06wjc",
								"updated": "20250320114543"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "因为延迟渲染路径利用了 G 缓存来存储最终可见的片元信息，\n当我们真正进行光照计算时，只会计算 G 缓冲区中存储的各片元信息，这会减少很多不必要的光照计算"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250320114518-sxl4j1s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250320114518-sxl4j1s",
				"updated": "20250320114518"
			}
		}
	]
}