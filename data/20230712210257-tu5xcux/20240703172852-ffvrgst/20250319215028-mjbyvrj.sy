{
	"ID": "20250319215028-mjbyvrj",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20250319215028-mjbyvrj",
		"title": "MIL11——模拟面试题",
		"type": "doc",
		"updated": "20250319220021"
	},
	"Children": [
		{
			"ID": "20250319215030-9btavmk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250319215030-9btavmk",
				"updated": "20250319215030"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "C#"
				}
			]
		},
		{
			"ID": "20250319215030-gkp5d8q",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250319215030-gkp5d8q",
				"updated": "20250319215440"
			},
			"Children": [
				{
					"ID": "20250319215106-joqx6t8",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250319215106-joqx6t8",
						"updated": "20250319215106"
					},
					"Children": [
						{
							"ID": "20250319215106-ad166jz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319215106-ad166jz",
								"updated": "20250319215106"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "文件中保存了文本信息，但是打开后却是乱码，一般是什么原因造成的？"
								}
							]
						}
					]
				},
				{
					"ID": "20250319215106-i2056hy",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250319215106-i2056hy",
						"updated": "20250319215153"
					},
					"Children": [
						{
							"ID": "20250319215106-zojemtp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319215106-zojemtp",
								"updated": "20250319215153"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C"
								},
								{
									"Type": "NodeBackslash",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeText",
											"Data": "#"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 中 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "new"
								},
								{
									"Type": "NodeText",
									"Data": "​ 关键字的作用（至少说出3种）"
								}
							]
						}
					]
				},
				{
					"ID": "20250319215106-zutwk0m",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250319215106-zutwk0m",
						"updated": "20250319215159"
					},
					"Children": [
						{
							"ID": "20250319215106-7e18svb",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319215106-7e18svb",
								"updated": "20250319215159"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "同步方法和异步方法的区别是什么？异步编程是什么意思？对于我们来说，什么时候需要使用异步编程？（至少说出3种）"
								}
							]
						}
					]
				},
				{
					"ID": "20250319215106-o72y6p4",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250319215106-o72y6p4",
						"updated": "20250319215106"
					},
					"Children": [
						{
							"ID": "20250319215106-dtogfpy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319215106-dtogfpy",
								"updated": "20250319215106"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）"
								}
							]
						}
					]
				},
				{
					"ID": "20250319215106-wwx52jr",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250319215106-wwx52jr",
						"updated": "20250319215440"
					},
					"Children": [
						{
							"ID": "20250319215106-u0tnsd8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319215106-u0tnsd8",
								"updated": "20250319215440"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如何用一个 int 变量，记录 32 种状态？（注意：状态可以并存）"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250319215030-yba6pc6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250319215030-yba6pc6",
				"updated": "20250319215030"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Unity"
				}
			]
		},
		{
			"ID": "20250319215030-75h8q8g",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250319215030-75h8q8g",
				"updated": "20250319215148"
			},
			"Children": [
				{
					"ID": "20250319215129-tw32d89",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250319215129-tw32d89",
						"updated": "20250319215133"
					},
					"Children": [
						{
							"ID": "20250319215129-mwofnek",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319215129-mwofnek",
								"updated": "20250319215133"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请解释 Unity 中的 Prefab 是什么，以及它在游戏开发中的作用是什么？"
								}
							]
						}
					]
				},
				{
					"ID": "20250319215129-7ivz5bd",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250319215129-7ivz5bd",
						"updated": "20250319215141"
					},
					"Children": [
						{
							"ID": "20250319215129-qsyd15y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319215129-qsyd15y",
								"updated": "20250319215141"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Unity 中，什么是 Shader？它有什么作用，以及如何编写一个基本的 Shader？"
								}
							]
						}
					]
				},
				{
					"ID": "20250319215129-enivrnu",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250319215129-enivrnu",
						"updated": "20250319215146"
					},
					"Children": [
						{
							"ID": "20250319215129-nug7i5i",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319215129-nug7i5i",
								"updated": "20250319215146"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Unity 中，什么是常见的性能优化技巧？请举例说明。"
								}
							]
						}
					]
				},
				{
					"ID": "20250319215129-4bij6f3",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250319215129-4bij6f3",
						"updated": "20250319215144"
					},
					"Children": [
						{
							"ID": "20250319215129-90ziycs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319215129-90ziycs",
								"updated": "20250319215144"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Unity 中，什么是协程（Coroutine）？它有什么作用，以及如何使用它？"
								}
							]
						}
					]
				},
				{
					"ID": "20250319215129-3tgdnsf",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250319215129-3tgdnsf",
						"updated": "20250319215148"
					},
					"Children": [
						{
							"ID": "20250319215129-rh16och",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319215129-rh16och",
								"updated": "20250319215148"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "解释一下 Unity 中的渲染管线（Rendering Pipeline）是什么，如何使用它，并举例说明它在游戏开发中的应用场景。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250319215236-eqrxdod",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20250319215236-eqrxdod",
				"updated": "20250319220021"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "答案"
				}
			]
		},
		{
			"ID": "20250319220021-nt9gqih",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250319220021-nt9gqih",
				"updated": "20250319220021"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "C#"
				}
			]
		},
		{
			"ID": "20250319220021-2srs7fx",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250319220021-2srs7fx",
				"updated": "20250319220510"
			},
			"Children": [
				{
					"ID": "20250319220021-q6z4moi",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250319220021-q6z4moi",
						"updated": "20250319220021"
					},
					"Children": [
						{
							"ID": "20250319220021-135vf5y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220021-135vf5y",
								"updated": "20250319220021"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "文件中保存了文本信息，但是打开后却是乱码，一般是什么原因造成的？"
								}
							]
						},
						{
							"ID": "20250319220030-cmr2nsq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220030-cmr2nsq",
								"updated": "20250319220031"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "序列化和反序列化字符串时使用的编码格式不统一"
								}
							]
						}
					]
				},
				{
					"ID": "20250319220021-s3yvabe",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250319220021-s3yvabe",
						"updated": "20250319220021"
					},
					"Children": [
						{
							"ID": "20250319220021-izzdaxs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220021-izzdaxs",
								"updated": "20250319220045"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C"
								},
								{
									"Type": "NodeBackslash",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeText",
											"Data": "#"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 中 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "new"
								},
								{
									"Type": "NodeText",
									"Data": "​ 关键字的作用（至少说出 3 种）"
								}
							]
						},
						{
							"ID": "20250319220042-njdrw31",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250319220042-njdrw31",
								"updated": "20250319220042"
							},
							"Children": [
								{
									"ID": "20250319220042-g1uta5r",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250319220042-g1uta5r",
										"updated": "20250319220042"
									},
									"Children": [
										{
											"ID": "20250319220042-fgenarf",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220042-fgenarf",
												"updated": "20250319220048"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "创建新对象"
												}
											]
										}
									]
								},
								{
									"ID": "20250319220048-lozjabo",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250319220048-lozjabo",
										"updated": "20250319220048"
									},
									"Children": [
										{
											"ID": "20250319220048-6u4w2i2",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220048-6u4w2i2",
												"updated": "20250319220057"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "子类函数声明时加上 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "new"
												},
												{
													"Type": "NodeText",
													"Data": "​ 关键字，可以隐藏掉父类方法"
												}
											]
										}
									]
								},
								{
									"ID": "20250319220058-epu0s82",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "My4=",
										"Num": 3
									},
									"Properties": {
										"id": "20250319220058-epu0s82",
										"updated": "20250319220058"
									},
									"Children": [
										{
											"ID": "20250319220058-59zszhx",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220058-59zszhx",
												"updated": "20250319220102"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "泛型约束中使用 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "new"
												},
												{
													"Type": "NodeText",
													"Data": "​ 关键词，表示需要无参构造"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20250319220021-j7vgcg6",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250319220021-j7vgcg6",
						"updated": "20250319220021"
					},
					"Children": [
						{
							"ID": "20250319220021-3nes2y0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220021-3nes2y0",
								"updated": "20250319220021"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "同步方法和异步方法的区别是什么？异步编程是什么意思？对于我们来说，什么时候需要使用异步编程？（至少说出3种）"
								}
							]
						},
						{
							"ID": "20250319220247-n1j813h",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20250319220247-n1j813h",
								"updated": "20250319220252"
							},
							"Children": [
								{
									"ID": "20250319220252-z18y4tu",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319220252-z18y4tu",
										"updated": "20250319220252"
									},
									"Children": [
										{
											"ID": "20250319220252-wt6k5nc",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220252-wt6k5nc",
												"updated": "20250319220256"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "同步方法： 当一个方法被调用时，调用者需要等待该方法执行完毕后返回才能继续执行"
												}
											]
										}
									]
								},
								{
									"ID": "20250319220256-cm5u2ne",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319220256-cm5u2ne",
										"updated": "20250319220256"
									},
									"Children": [
										{
											"ID": "20250319220256-k8q7quf",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220256-k8q7quf",
												"updated": "20250319220304"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "异步方法： 当一个方法被调用时立即返回，并获取一个线程执行该方法内部的逻辑，调用者不用等待该方法执行完毕"
												}
											]
										}
									]
								},
								{
									"ID": "20250319220304-8f8s49j",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319220304-8f8s49j",
										"updated": "20250319220304"
									},
									"Children": [
										{
											"ID": "20250319220304-rt9mswg",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220304-rt9mswg",
												"updated": "20250319220312"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "异步编程： 在日常开发时把一些不需要立即得到结果且耗时的逻辑设置为异步执行，\n这样可以提高程序的运行效率，避免由于复杂逻辑带来的的线程阻塞"
												}
											]
										}
									]
								},
								{
									"ID": "20250319220310-yo5dace",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319220310-yo5dace",
										"updated": "20250319220310"
									},
									"Children": [
										{
											"ID": "20250319220310-prdrd64",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220310-prdrd64",
												"updated": "20250319220310"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "什么时候需要使用异步编程： "
												}
											]
										},
										{
											"ID": "20250319220316-5mm99eq",
											"Type": "NodeList",
											"ListData": {
												"Typ": 1
											},
											"Properties": {
												"id": "20250319220316-5mm99eq",
												"updated": "20250319220317"
											},
											"Children": [
												{
													"ID": "20250319220317-jhyw1hm",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "MS4=",
														"Num": 1
													},
													"Properties": {
														"id": "20250319220317-jhyw1hm",
														"updated": "20250319220317"
													},
													"Children": [
														{
															"ID": "20250319220317-tyro4j1",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319220317-tyro4j1",
																"updated": "20250319220320"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "复杂逻辑计算时，比如寻路算法等"
																}
															]
														}
													]
												},
												{
													"ID": "20250319220320-v7svppk",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "Mi4=",
														"Num": 2
													},
													"Properties": {
														"id": "20250319220320-v7svppk",
														"updated": "20250319220320"
													},
													"Children": [
														{
															"ID": "20250319220320-mmcns0h",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319220320-mmcns0h",
																"updated": "20250319220335"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "网络下载、网络通讯"
																}
															]
														}
													]
												},
												{
													"ID": "20250319220322-6mmvagb",
													"Type": "NodeListItem",
													"ListData": {
														"Typ": 1,
														"Delimiter": 46,
														"Marker": "My4=",
														"Num": 3
													},
													"Properties": {
														"id": "20250319220322-6mmvagb",
														"updated": "20250319220322"
													},
													"Children": [
														{
															"ID": "20250319220322-1i71kkc",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319220322-1i71kkc",
																"updated": "20250319220325"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "资源加载时"
																}
															]
														}
													]
												}
											]
										},
										{
											"ID": "20250319220326-nostff2",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220326-nostff2",
												"updated": "20250319220330"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "等等"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20250319220021-nsql2o4",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250319220021-nsql2o4",
						"updated": "20250319220021"
					},
					"Children": [
						{
							"ID": "20250319220021-l2uxnde",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220021-l2uxnde",
								"updated": "20250319220021"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）"
								}
							]
						},
						{
							"ID": "20250319220419-uv7yb4i",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220419-uv7yb4i",
								"updated": "20250319220424"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "回调函数指在程序设计中，将一个函数作为参数传递给另一个函数，并在另一个函数执行完毕后被调用的函数，在 C# 中，一般以委托形式出现"
								}
							]
						},
						{
							"ID": "20250319220425-ajlpo4l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220425-ajlpo4l",
								"updated": "20250319220433"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "什么时候使用："
								}
							]
						},
						{
							"ID": "20250319220433-0budvsa",
							"Type": "NodeList",
							"ListData": {
								"Typ": 1
							},
							"Properties": {
								"id": "20250319220433-0budvsa",
								"updated": "20250319220435"
							},
							"Children": [
								{
									"ID": "20250319220435-e2blqbr",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "MS4=",
										"Num": 1
									},
									"Properties": {
										"id": "20250319220435-e2blqbr",
										"updated": "20250319220435"
									},
									"Children": [
										{
											"ID": "20250319220435-cc4r2da",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220435-cc4r2da",
												"updated": "20250319220437"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "异步编程：异步逻辑执行完毕后，再执行回调函数"
												}
											]
										}
									]
								},
								{
									"ID": "20250319220437-lvimrde",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "Mi4=",
										"Num": 2
									},
									"Properties": {
										"id": "20250319220437-lvimrde",
										"updated": "20250319220437"
									},
									"Children": [
										{
											"ID": "20250319220437-6oykea4",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220437-6oykea4",
												"updated": "20250319220440"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "事件中心 "
												}
											]
										}
									]
								},
								{
									"ID": "20250319220441-ewmgj1n",
									"Type": "NodeListItem",
									"ListData": {
										"Typ": 1,
										"Delimiter": 46,
										"Marker": "My4=",
										"Num": 3
									},
									"Properties": {
										"id": "20250319220441-ewmgj1n",
										"updated": "20250319220441"
									},
									"Children": [
										{
											"ID": "20250319220441-aweqrqm",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220441-aweqrqm",
												"updated": "20250319220444"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "UI 界面中的空间逻辑回调，比如按钮点击"
												}
											]
										}
									]
								}
							]
						},
						{
							"ID": "20250319220444-tl4mgcm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220444-tl4mgcm",
								"updated": "20250319220448"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "等等"
								}
							]
						}
					]
				},
				{
					"ID": "20250319220021-psl7npf",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250319220021-psl7npf",
						"updated": "20250319220510"
					},
					"Children": [
						{
							"ID": "20250319220021-zubapvf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220021-zubapvf",
								"updated": "20250319220021"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如何用一个 int 变量，记录 32 种状态？（注意：状态可以并存）"
								}
							]
						},
						{
							"ID": "20250319220456-z399zgx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220456-z399zgx",
								"updated": "20250319220510"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "int"
								},
								{
									"Type": "NodeText",
									"Data": "​ 在 C# 中占4个字节，共32位，我们可以按位记录状态，每一位代表一个状态，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "1"
								},
								{
									"Type": "NodeText",
									"Data": "​ 为存在，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "0"
								},
								{
									"Type": "NodeText",
									"Data": "​ 为不存在"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250319220021-tbdjmou",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250319220021-tbdjmou",
				"updated": "20250319220021"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Unity"
				}
			]
		},
		{
			"ID": "20250319220021-foqpj6r",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20250319220021-foqpj6r",
				"updated": "20250319220021"
			},
			"Children": [
				{
					"ID": "20250319220021-pyhklqm",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20250319220021-pyhklqm",
						"updated": "20250319220021"
					},
					"Children": [
						{
							"ID": "20250319220021-4jm9e20",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220021-4jm9e20",
								"updated": "20250319220021"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "请解释 Unity 中的 Prefab 是什么，以及它在游戏开发中的作用是什么？"
								}
							]
						},
						{
							"ID": "20250319220551-o9vfhv5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220551-o9vfhv5",
								"updated": "20250319220614"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Unity 中，Prefab 是一种游戏对象的预制件或者模板。\n它允许你在编辑器中创建一个游戏对象，并将其保存为Prefab，以便在需要时可以实例化多个相同的对象。\n当你在场景中使用一个 Prefab 实例时，它将保留与原始 Prefab 相同的组件、属性和位置，使得你可以轻松地创建和管理大量相似的游戏对象。  "
								}
							]
						},
						{
							"ID": "20250319220616-jguhet4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220616-jguhet4",
								"updated": "20250319220630"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Prefab 在游戏开发中的作用非常重要，因为它们允许你创建可重用的游戏对象，并且可以在开发过程中快速迭代和修改。\n例如，当你需要在游戏中生成大量相似的敌人时，使用一个敌人 Prefab 可以使得你仅需创建和修改一个敌人对象，而不必重复编写和调整代码。\n此外，Prefab 还允许你在编辑器中预览和调整游戏对象的属性和组件，使得你可以快速地进行修改和测试，从而加快开发进程。"
								}
							]
						}
					]
				},
				{
					"ID": "20250319220021-tijj0e8",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20250319220021-tijj0e8",
						"updated": "20250319220021"
					},
					"Children": [
						{
							"ID": "20250319220021-3li55x9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220021-3li55x9",
								"updated": "20250319220021"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Unity 中，什么是 Shader？它有什么作用，以及如何编写一个基本的 Shader？"
								}
							]
						},
						{
							"ID": "20250319220739-3finmmj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220739-3finmmj",
								"updated": "20250319220816"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Unity 中，Shader是一种用于定义渲染对象的程序。它描述了对象的外观、材质和光照效果。\n在渲染场景时，每个对象都会使用其对应的 Shader 来生成像素颜色，并最终呈现到屏幕上。\n在 Unity 中，可以使用着色器语言（ShaderLab）和高级着色器语言（HLSL）编写自定义的 Shader。\n"
								}
							]
						},
						{
							"ID": "20250319220821-x6cgyvo",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220821-x6cgyvo",
								"updated": "20250319220821"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Shader 在游戏开发中具有非常重要的作用。它们控制了游戏对象的外观和性能，\n并且可以根据需要创建各种各样的视觉效果，比如透明度、反射、阴影、发光等等。\n使用自定义 Shader 还可以实现一些特定的效果，例如水波纹、烟雾、火焰等等。"
								}
							]
						}
					]
				},
				{
					"ID": "20250319220021-6xuug77",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20250319220021-6xuug77",
						"updated": "20250319220021"
					},
					"Children": [
						{
							"ID": "20250319220021-8kizhsc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220021-8kizhsc",
								"updated": "20250319220021"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Unity 中，什么是常见的性能优化技巧？请举例说明。"
								}
							]
						},
						{
							"ID": "20250319220937-izq82v9",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20250319220937-izq82v9",
								"updated": "20250319220938"
							},
							"Children": [
								{
									"ID": "20250319220938-6y5de5m",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319220938-6y5de5m",
										"updated": "20250319220938"
									},
									"Children": [
										{
											"ID": "20250319220938-rtidmyj",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220938-rtidmyj",
												"updated": "20250319220943"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "从内存的角度来说"
												}
											]
										},
										{
											"ID": "20250319220954-rfh76qj",
											"Type": "NodeList",
											"ListData": {},
											"Properties": {
												"id": "20250319220954-rfh76qj",
												"updated": "20250319220957"
											},
											"Children": [
												{
													"ID": "20250319220957-mg9rwl1",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250319220957-mg9rwl1",
														"updated": "20250319220957"
													},
													"Children": [
														{
															"ID": "20250319220957-qrynvlb",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319220957-qrynvlb",
																"updated": "20250319221012"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "尽量要占用少"
																}
															]
														},
														{
															"ID": "20250319221028-exj8q9f",
															"Type": "NodeList",
															"ListData": {},
															"Properties": {
																"id": "20250319221028-exj8q9f",
																"updated": "20250319221038"
															},
															"Children": [
																{
																	"ID": "20250319221038-evl2eul",
																	"Type": "NodeListItem",
																	"ListData": {
																		"BulletChar": 42,
																		"Marker": "Kg=="
																	},
																	"Properties": {
																		"id": "20250319221038-evl2eul",
																		"updated": "20250319221038"
																	},
																	"Children": [
																		{
																			"ID": "20250319221038-s4z8y40",
																			"Type": "NodeParagraph",
																			"Properties": {
																				"id": "20250319221038-s4z8y40",
																				"updated": "20250319221045"
																			},
																			"Children": [
																				{
																					"Type": "NodeText",
																					"Data": "使用对象池：对象池是一种常见的技术，用于缓存和重复使用游戏对象，而不是频繁地创建和销毁它们。\n使用对象池可以减少内存分配和垃圾回收的开销，从而提高游戏性能。"
																				}
																			]
																		}
																	]
																},
																{
																	"ID": "20250319221046-eg50psi",
																	"Type": "NodeListItem",
																	"ListData": {
																		"BulletChar": 42,
																		"Marker": "Kg=="
																	},
																	"Properties": {
																		"id": "20250319221046-eg50psi",
																		"updated": "20250319221046"
																	},
																	"Children": [
																		{
																			"ID": "20250319221046-7iz1kuw",
																			"Type": "NodeParagraph",
																			"Properties": {
																				"id": "20250319221046-7iz1kuw",
																				"updated": "20250319221049"
																			},
																			"Children": [
																				{
																					"Type": "NodeText",
																					"Data": "减少资源占用：在开发过程中，应该尽量避免使用过多的高分辨率纹理和复杂的模型。\n可以使用纹理压缩、减少纹理尺寸、使用轻量级的模型等方式来减小资源占用。"
																				}
																			]
																		}
																	]
																},
																{
																	"ID": "20250319221053-mhfjdng",
																	"Type": "NodeListItem",
																	"ListData": {
																		"BulletChar": 42,
																		"Marker": "Kg=="
																	},
																	"Properties": {
																		"id": "20250319221053-mhfjdng",
																		"updated": "20250319221053"
																	},
																	"Children": [
																		{
																			"ID": "20250319221053-opdis6p",
																			"Type": "NodeParagraph",
																			"Properties": {
																				"id": "20250319221053-opdis6p",
																				"updated": "20250319221056"
																			},
																			"Children": [
																				{
																					"Type": "NodeText",
																					"Data": "及时销毁不再使用的对象：当游戏中不再需要使用某些对象时，应该及时销毁它们，以释放它们占用的内存。\n尤其是一些长时间存在的对象，如粒子系统、音频和视频资源等，都应该及时销毁。"
																				}
																			]
																		}
																	]
																},
																{
																	"ID": "20250319221100-mozpzdz",
																	"Type": "NodeListItem",
																	"ListData": {
																		"BulletChar": 42,
																		"Marker": "Kg=="
																	},
																	"Properties": {
																		"id": "20250319221100-mozpzdz",
																		"updated": "20250319221100"
																	},
																	"Children": [
																		{
																			"ID": "20250319221100-62zz98q",
																			"Type": "NodeParagraph",
																			"Properties": {
																				"id": "20250319221100-62zz98q",
																				"updated": "20250319221136"
																			},
																			"Children": [
																				{
																					"Type": "NodeText",
																					"Data": "使用异步加载：如果游戏中需要加载大量的资源，可以使用异步加载技术。\n异步加载可以减少游戏卡顿和内存占用，从而提高游戏性能。\n可以使用 Unity 提供的异步加载 API 或者自定义异步加载方式来实现异步加载。"
																				}
																			]
																		}
																	]
																},
																{
																	"ID": "20250319221113-8g6drrc",
																	"Type": "NodeListItem",
																	"ListData": {
																		"BulletChar": 42,
																		"Marker": "Kg=="
																	},
																	"Properties": {
																		"id": "20250319221113-8g6drrc",
																		"updated": "20250319221113"
																	},
																	"Children": [
																		{
																			"ID": "20250319221113-hrt0s5s",
																			"Type": "NodeParagraph",
																			"Properties": {
																				"id": "20250319221113-hrt0s5s",
																				"updated": "20250319221132"
																			},
																			"Children": [
																				{
																					"Type": "NodeText",
																					"Data": "使用资源打包：在打包游戏时，可以使用资源打包技术来减少游戏的内存占用。\n资源打包可以将多个资源打包成一个单独的文件，从而减小游戏的内存占用。\n可以使用 Unity 提供的 AssetBundle 功能或者自定义打包方式来实现资源打包。"
																				}
																			]
																		}
																	]
																}
															]
														}
													]
												},
												{
													"ID": "20250319221013-1bxpnrk",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250319221013-1bxpnrk",
														"updated": "20250319221013"
													},
													"Children": [
														{
															"ID": "20250319221013-21zsgpq",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319221013-21zsgpq",
																"updated": "20250319221026"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "尽量要减少 GC"
																}
															]
														}
													]
												}
											]
										}
									]
								},
								{
									"ID": "20250319220943-1hrix4k",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319220943-1hrix4k",
										"updated": "20250319220943"
									},
									"Children": [
										{
											"ID": "20250319220943-rgr8py7",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319220943-rgr8py7",
												"updated": "20250319220953"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "从 CPU/GPU 的角度来说"
												}
											]
										},
										{
											"ID": "20250319221150-zqx21z7",
											"Type": "NodeList",
											"ListData": {},
											"Properties": {
												"id": "20250319221150-zqx21z7",
												"updated": "20250319221150"
											},
											"Children": [
												{
													"ID": "20250319221149-lud0km6",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250319221149-lud0km6",
														"updated": "20250319221149"
													},
													"Children": [
														{
															"ID": "20250319221149-2aiwfcc",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319221149-2aiwfcc",
																"updated": "20250319221156"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "减少 Draw Call：在 Unity 中，每次渲染一个物体都会使用一个 Draw Call。过多的Draw Call会导致渲染性能下降，因此应该尽量减少它们的数量。可以通过合并网格、使用物体批处理和减少物体数量等方式来减少Draw Call。"
																}
															]
														}
													]
												},
												{
													"ID": "20250319221202-p6v8pjh",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250319221202-p6v8pjh",
														"updated": "20250319221202"
													},
													"Children": [
														{
															"ID": "20250319221202-15l9kyo",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319221202-15l9kyo",
																"updated": "20250319221209"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "使用级别 LOD：如果场景中有大量的物体，可以使用级别 LOD 技术来优化性能。\n通过在远离玩家的位置使用低分辨率的网格，可以降低渲染开销，提高性能。"
																}
															]
														}
													]
												},
												{
													"ID": "20250319221213-esg3ct9",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250319221213-esg3ct9",
														"updated": "20250319221213"
													},
													"Children": [
														{
															"ID": "20250319221213-7yb8vcu",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319221213-7yb8vcu",
																"updated": "20250319221218"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "合理使用资源：在开发过程中，应该尽量避免使用过多的高分辨率纹理和复杂的模型。\n可以使用纹理压缩、减少纹理尺寸、使用轻量级的模型等方式来减小资源占用。"
																}
															]
														}
													]
												},
												{
													"ID": "20250319221221-p9bbsxk",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250319221221-p9bbsxk",
														"updated": "20250319221221"
													},
													"Children": [
														{
															"ID": "20250319221221-wxlnj5l",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319221221-wxlnj5l",
																"updated": "20250319221225"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "使用光照贴图：在游戏中，光照是非常重要的，但是使用动态光照会带来很大的渲染开销。\n因此，可以使用光照贴图来减少动态光照的数量。光照贴图可以在编辑器中生成，并且可以有效地提高游戏的性能。"
																}
															]
														}
													]
												},
												{
													"ID": "20250319221229-gyulenr",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20250319221229-gyulenr",
														"updated": "20250319221229"
													},
													"Children": [
														{
															"ID": "20250319221229-74vnw9k",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20250319221229-74vnw9k",
																"updated": "20250319221232"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "使用对象池：对象池是一种常见的技术，用于缓存和重复使用游戏对象，而不是频繁地创建和销毁它们。\n使用对象池可以减少内存分配和垃圾回收的开销，从而提高游戏性能。"
																}
															]
														}
													]
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20250319220021-uy85jku",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20250319220021-uy85jku",
						"updated": "20250319220021"
					},
					"Children": [
						{
							"ID": "20250319220021-63j2n4v",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220021-63j2n4v",
								"updated": "20250319220021"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Unity 中，什么是协程（Coroutine）？它有什么作用，以及如何使用它？"
								}
							]
						},
						{
							"ID": "20250319221302-t6216ql",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221302-t6216ql",
								"updated": "20250319221314"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "协程（Coroutine）是一种在 Unity 中常用的编程技术，用于在运行时控制代码的执行顺序。\n协程可以将代码执行分为多个阶段，可以在其中暂停和恢复代码执行，从而实现异步执行和任务管理等功能。"
								}
							]
						},
						{
							"ID": "20250319221331-qsokt50",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319221331-qsokt50",
								"updated": "20250319221331"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "协程的主要作用包括："
								}
							]
						},
						{
							"ID": "20250319221317-9jr0c3b",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20250319221317-9jr0c3b",
								"updated": "20250319221319"
							},
							"Children": [
								{
									"ID": "20250319221319-0mrwwll",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319221319-0mrwwll",
										"updated": "20250319221319"
									},
									"Children": [
										{
											"ID": "20250319221319-r5f6hew",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319221319-r5f6hew",
												"updated": "20250319221319"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "延迟执行：协程可以延迟执行某个任务，从而在指定时间后执行相应的操作。"
												}
											]
										}
									]
								},
								{
									"ID": "20250319221323-mzonpi6",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319221323-mzonpi6",
										"updated": "20250319221323"
									},
									"Children": [
										{
											"ID": "20250319221323-1sstaqj",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319221323-1sstaqj",
												"updated": "20250319221323"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "异步执行：协程可以在后台执行任务，从而避免卡顿和阻塞主线程。"
												}
											]
										}
									]
								},
								{
									"ID": "20250319221328-2ooujat",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319221328-2ooujat",
										"updated": "20250319221328"
									},
									"Children": [
										{
											"ID": "20250319221328-x49a5if",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319221328-x49a5if",
												"updated": "20250319221328"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "任务管理：协程可以管理多个任务，从而实现更灵活和可控的代码执行顺序。"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20250319220021-d6lbt0v",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20250319220021-d6lbt0v",
						"updated": "20250319220021"
					},
					"Children": [
						{
							"ID": "20250319220021-7bgxoso",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250319220021-7bgxoso",
								"updated": "20250319220021"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "解释一下 Unity 中的渲染管线（Rendering Pipeline）是什么，如何使用它，并举例说明它在游戏开发中的应用场景。"
								}
							]
						},
						{
							"ID": "20250319221346-dsz31d0",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20250319221346-dsz31d0",
								"updated": "20250319221353"
							},
							"Children": [
								{
									"ID": "20250319221353-gn29t3j",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319221353-gn29t3j",
										"updated": "20250319221353"
									},
									"Children": [
										{
											"ID": "20250319221353-b8ru7p9",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319221353-b8ru7p9",
												"updated": "20250319221353"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "几何图形的准备：将场景中的几何图形转换为渲染引擎可以理解的形式，例如将3D模型转换为网格数据（Mesh）和材质信息。"
												}
											]
										}
									]
								},
								{
									"ID": "20250319221358-qv8q59w",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319221358-qv8q59w",
										"updated": "20250319221358"
									},
									"Children": [
										{
											"ID": "20250319221358-ex2xyuw",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319221358-ex2xyuw",
												"updated": "20250319221358"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "光照计算：计算场景中每个几何图形的光照效果，包括直接光照和间接光照。"
												}
											]
										}
									]
								},
								{
									"ID": "20250319221402-130jzu2",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319221402-130jzu2",
										"updated": "20250319221402"
									},
									"Children": [
										{
											"ID": "20250319221402-9gsnu76",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319221402-9gsnu76",
												"updated": "20250319221402"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "视点变换：根据摄像机的位置和方向将场景中的几何图形转换为摄像机的视图空间（View Space）坐标系下的形式。"
												}
											]
										}
									]
								},
								{
									"ID": "20250319221406-ucyeiy5",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319221406-ucyeiy5",
										"updated": "20250319221406"
									},
									"Children": [
										{
											"ID": "20250319221406-jxa53x4",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319221406-jxa53x4",
												"updated": "20250319221406"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "投影变换：将摄像机的视图空间坐标系下的几何图形转换为投影坐标系下的形式。"
												}
											]
										}
									]
								},
								{
									"ID": "20250319221409-cez9nuv",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319221409-cez9nuv",
										"updated": "20250319221409"
									},
									"Children": [
										{
											"ID": "20250319221409-syaieym",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319221409-syaieym",
												"updated": "20250319221415"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "图像空间计算：将投影坐标系下的几何图形转换为屏幕上的像素坐标。"
												}
											]
										}
									]
								},
								{
									"ID": "20250319221415-w7r1m7y",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319221415-w7r1m7y",
										"updated": "20250319221415"
									},
									"Children": [
										{
											"ID": "20250319221415-694qqb2",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319221415-694qqb2",
												"updated": "20250319221415"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "着色：根据材质信息和光照信息对几何图形进行着色，计算每个像素的颜色值。"
												}
											]
										}
									]
								},
								{
									"ID": "20250319221419-jn07kja",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250319221419-jn07kja",
										"updated": "20250319221419"
									},
									"Children": [
										{
											"ID": "20250319221419-h04tyx6",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250319221419-h04tyx6",
												"updated": "20250319221419"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "合成：将所有的像素颜色值按照一定的顺序合成为最终的图像，输出到屏幕上。"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		}
	]
}